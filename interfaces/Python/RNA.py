# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

from . import _RNA

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def new_intP(nelements):
    return _RNA.new_intP(nelements)

def delete_intP(ary):
    return _RNA.delete_intP(ary)

def intP_getitem(ary, index):
    return _RNA.intP_getitem(ary, index)

def intP_setitem(ary, index, value):
    return _RNA.intP_setitem(ary, index, value)
class intArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements):
        _RNA.intArray_swiginit(self, _RNA.new_intArray(nelements))
    __swig_destroy__ = _RNA.delete_intArray

    def __getitem__(self, index):
        return _RNA.intArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _RNA.intArray___setitem__(self, index, value)

    def cast(self):
        return _RNA.intArray_cast(self)

    @staticmethod
    def frompointer(t):
        return _RNA.intArray_frompointer(t)

# Register intArray in _RNA:
_RNA.intArray_swigregister(intArray)

def intArray_frompointer(t):
    return _RNA.intArray_frompointer(t)


def new_floatP(nelements):
    return _RNA.new_floatP(nelements)

def delete_floatP(ary):
    return _RNA.delete_floatP(ary)

def floatP_getitem(ary, index):
    return _RNA.floatP_getitem(ary, index)

def floatP_setitem(ary, index, value):
    return _RNA.floatP_setitem(ary, index, value)
class floatArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements):
        _RNA.floatArray_swiginit(self, _RNA.new_floatArray(nelements))
    __swig_destroy__ = _RNA.delete_floatArray

    def __getitem__(self, index):
        return _RNA.floatArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _RNA.floatArray___setitem__(self, index, value)

    def cast(self):
        return _RNA.floatArray_cast(self)

    @staticmethod
    def frompointer(t):
        return _RNA.floatArray_frompointer(t)

# Register floatArray in _RNA:
_RNA.floatArray_swigregister(floatArray)

def floatArray_frompointer(t):
    return _RNA.floatArray_frompointer(t)


def new_doubleP(nelements):
    return _RNA.new_doubleP(nelements)

def delete_doubleP(ary):
    return _RNA.delete_doubleP(ary)

def doubleP_getitem(ary, index):
    return _RNA.doubleP_getitem(ary, index)

def doubleP_setitem(ary, index, value):
    return _RNA.doubleP_setitem(ary, index, value)
class doubleArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements):
        _RNA.doubleArray_swiginit(self, _RNA.new_doubleArray(nelements))
    __swig_destroy__ = _RNA.delete_doubleArray

    def __getitem__(self, index):
        return _RNA.doubleArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _RNA.doubleArray___setitem__(self, index, value)

    def cast(self):
        return _RNA.doubleArray_cast(self)

    @staticmethod
    def frompointer(t):
        return _RNA.doubleArray_frompointer(t)

# Register doubleArray in _RNA:
_RNA.doubleArray_swigregister(doubleArray)

def doubleArray_frompointer(t):
    return _RNA.doubleArray_frompointer(t)


def new_ushortP(nelements):
    return _RNA.new_ushortP(nelements)

def delete_ushortP(ary):
    return _RNA.delete_ushortP(ary)

def ushortP_getitem(ary, index):
    return _RNA.ushortP_getitem(ary, index)

def ushortP_setitem(ary, index, value):
    return _RNA.ushortP_setitem(ary, index, value)

def new_shortP(nelements):
    return _RNA.new_shortP(nelements)

def delete_shortP(ary):
    return _RNA.delete_shortP(ary)

def shortP_getitem(ary, index):
    return _RNA.shortP_getitem(ary, index)

def shortP_setitem(ary, index, value):
    return _RNA.shortP_setitem(ary, index, value)

def cdata(ptr, nelements=1):
    return _RNA.cdata(ptr, nelements)

def memmove(data, indata):
    return _RNA.memmove(data, indata)

__version__ = '2.6.4'

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _RNA.delete_SwigPyIterator

    def value(self):
        return _RNA.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _RNA.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _RNA.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _RNA.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _RNA.SwigPyIterator_equal(self, x)

    def copy(self):
        return _RNA.SwigPyIterator_copy(self)

    def next(self):
        return _RNA.SwigPyIterator_next(self)

    def __next__(self):
        return _RNA.SwigPyIterator___next__(self)

    def previous(self):
        return _RNA.SwigPyIterator_previous(self)

    def advance(self, n):
        return _RNA.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _RNA.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _RNA.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _RNA.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _RNA.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _RNA.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _RNA.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _RNA:
_RNA.SwigPyIterator_swigregister(SwigPyIterator)

class DoublePair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _RNA.DoublePair_swiginit(self, _RNA.new_DoublePair(*args))
    first = property(_RNA.DoublePair_first_get, _RNA.DoublePair_first_set)
    second = property(_RNA.DoublePair_second_get, _RNA.DoublePair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _RNA.delete_DoublePair

# Register DoublePair in _RNA:
_RNA.DoublePair_swigregister(DoublePair)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.IntVector___nonzero__(self)

    def __bool__(self):
        return _RNA.IntVector___bool__(self)

    def __len__(self):
        return _RNA.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.IntVector___setitem__(self, *args)

    def pop(self):
        return _RNA.IntVector_pop(self)

    def append(self, x):
        return _RNA.IntVector_append(self, x)

    def empty(self):
        return _RNA.IntVector_empty(self)

    def size(self):
        return _RNA.IntVector_size(self)

    def swap(self, v):
        return _RNA.IntVector_swap(self, v)

    def begin(self):
        return _RNA.IntVector_begin(self)

    def end(self):
        return _RNA.IntVector_end(self)

    def rbegin(self):
        return _RNA.IntVector_rbegin(self)

    def rend(self):
        return _RNA.IntVector_rend(self)

    def clear(self):
        return _RNA.IntVector_clear(self)

    def get_allocator(self):
        return _RNA.IntVector_get_allocator(self)

    def pop_back(self):
        return _RNA.IntVector_pop_back(self)

    def erase(self, *args):
        return _RNA.IntVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.IntVector_swiginit(self, _RNA.new_IntVector(*args))

    def push_back(self, x):
        return _RNA.IntVector_push_back(self, x)

    def front(self):
        return _RNA.IntVector_front(self)

    def back(self):
        return _RNA.IntVector_back(self)

    def assign(self, n, x):
        return _RNA.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.IntVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.IntVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.IntVector_reserve(self, n)

    def capacity(self):
        return _RNA.IntVector_capacity(self)
    __swig_destroy__ = _RNA.delete_IntVector

# Register IntVector in _RNA:
_RNA.IntVector_swigregister(IntVector)

class UIntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.UIntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.UIntVector___nonzero__(self)

    def __bool__(self):
        return _RNA.UIntVector___bool__(self)

    def __len__(self):
        return _RNA.UIntVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.UIntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.UIntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.UIntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.UIntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.UIntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.UIntVector___setitem__(self, *args)

    def pop(self):
        return _RNA.UIntVector_pop(self)

    def append(self, x):
        return _RNA.UIntVector_append(self, x)

    def empty(self):
        return _RNA.UIntVector_empty(self)

    def size(self):
        return _RNA.UIntVector_size(self)

    def swap(self, v):
        return _RNA.UIntVector_swap(self, v)

    def begin(self):
        return _RNA.UIntVector_begin(self)

    def end(self):
        return _RNA.UIntVector_end(self)

    def rbegin(self):
        return _RNA.UIntVector_rbegin(self)

    def rend(self):
        return _RNA.UIntVector_rend(self)

    def clear(self):
        return _RNA.UIntVector_clear(self)

    def get_allocator(self):
        return _RNA.UIntVector_get_allocator(self)

    def pop_back(self):
        return _RNA.UIntVector_pop_back(self)

    def erase(self, *args):
        return _RNA.UIntVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.UIntVector_swiginit(self, _RNA.new_UIntVector(*args))

    def push_back(self, x):
        return _RNA.UIntVector_push_back(self, x)

    def front(self):
        return _RNA.UIntVector_front(self)

    def back(self):
        return _RNA.UIntVector_back(self)

    def assign(self, n, x):
        return _RNA.UIntVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.UIntVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.UIntVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.UIntVector_reserve(self, n)

    def capacity(self):
        return _RNA.UIntVector_capacity(self)
    __swig_destroy__ = _RNA.delete_UIntVector

# Register UIntVector in _RNA:
_RNA.UIntVector_swigregister(UIntVector)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _RNA.DoubleVector___bool__(self)

    def __len__(self):
        return _RNA.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _RNA.DoubleVector_pop(self)

    def append(self, x):
        return _RNA.DoubleVector_append(self, x)

    def empty(self):
        return _RNA.DoubleVector_empty(self)

    def size(self):
        return _RNA.DoubleVector_size(self)

    def swap(self, v):
        return _RNA.DoubleVector_swap(self, v)

    def begin(self):
        return _RNA.DoubleVector_begin(self)

    def end(self):
        return _RNA.DoubleVector_end(self)

    def rbegin(self):
        return _RNA.DoubleVector_rbegin(self)

    def rend(self):
        return _RNA.DoubleVector_rend(self)

    def clear(self):
        return _RNA.DoubleVector_clear(self)

    def get_allocator(self):
        return _RNA.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _RNA.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _RNA.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.DoubleVector_swiginit(self, _RNA.new_DoubleVector(*args))

    def push_back(self, x):
        return _RNA.DoubleVector_push_back(self, x)

    def front(self):
        return _RNA.DoubleVector_front(self)

    def back(self):
        return _RNA.DoubleVector_back(self)

    def assign(self, n, x):
        return _RNA.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.DoubleVector_reserve(self, n)

    def capacity(self):
        return _RNA.DoubleVector_capacity(self)
    __swig_destroy__ = _RNA.delete_DoubleVector

# Register DoubleVector in _RNA:
_RNA.DoubleVector_swigregister(DoubleVector)

class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.StringVector___nonzero__(self)

    def __bool__(self):
        return _RNA.StringVector___bool__(self)

    def __len__(self):
        return _RNA.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.StringVector___setitem__(self, *args)

    def pop(self):
        return _RNA.StringVector_pop(self)

    def append(self, x):
        return _RNA.StringVector_append(self, x)

    def empty(self):
        return _RNA.StringVector_empty(self)

    def size(self):
        return _RNA.StringVector_size(self)

    def swap(self, v):
        return _RNA.StringVector_swap(self, v)

    def begin(self):
        return _RNA.StringVector_begin(self)

    def end(self):
        return _RNA.StringVector_end(self)

    def rbegin(self):
        return _RNA.StringVector_rbegin(self)

    def rend(self):
        return _RNA.StringVector_rend(self)

    def clear(self):
        return _RNA.StringVector_clear(self)

    def get_allocator(self):
        return _RNA.StringVector_get_allocator(self)

    def pop_back(self):
        return _RNA.StringVector_pop_back(self)

    def erase(self, *args):
        return _RNA.StringVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.StringVector_swiginit(self, _RNA.new_StringVector(*args))

    def push_back(self, x):
        return _RNA.StringVector_push_back(self, x)

    def front(self):
        return _RNA.StringVector_front(self)

    def back(self):
        return _RNA.StringVector_back(self)

    def assign(self, n, x):
        return _RNA.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.StringVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.StringVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.StringVector_reserve(self, n)

    def capacity(self):
        return _RNA.StringVector_capacity(self)
    __swig_destroy__ = _RNA.delete_StringVector

# Register StringVector in _RNA:
_RNA.StringVector_swigregister(StringVector)

class ConstCharVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.ConstCharVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.ConstCharVector___nonzero__(self)

    def __bool__(self):
        return _RNA.ConstCharVector___bool__(self)

    def __len__(self):
        return _RNA.ConstCharVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.ConstCharVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.ConstCharVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.ConstCharVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.ConstCharVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.ConstCharVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.ConstCharVector___setitem__(self, *args)

    def pop(self):
        return _RNA.ConstCharVector_pop(self)

    def append(self, x):
        return _RNA.ConstCharVector_append(self, x)

    def empty(self):
        return _RNA.ConstCharVector_empty(self)

    def size(self):
        return _RNA.ConstCharVector_size(self)

    def swap(self, v):
        return _RNA.ConstCharVector_swap(self, v)

    def begin(self):
        return _RNA.ConstCharVector_begin(self)

    def end(self):
        return _RNA.ConstCharVector_end(self)

    def rbegin(self):
        return _RNA.ConstCharVector_rbegin(self)

    def rend(self):
        return _RNA.ConstCharVector_rend(self)

    def clear(self):
        return _RNA.ConstCharVector_clear(self)

    def get_allocator(self):
        return _RNA.ConstCharVector_get_allocator(self)

    def pop_back(self):
        return _RNA.ConstCharVector_pop_back(self)

    def erase(self, *args):
        return _RNA.ConstCharVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.ConstCharVector_swiginit(self, _RNA.new_ConstCharVector(*args))

    def push_back(self, x):
        return _RNA.ConstCharVector_push_back(self, x)

    def front(self):
        return _RNA.ConstCharVector_front(self)

    def back(self):
        return _RNA.ConstCharVector_back(self)

    def assign(self, n, x):
        return _RNA.ConstCharVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.ConstCharVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.ConstCharVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.ConstCharVector_reserve(self, n)

    def capacity(self):
        return _RNA.ConstCharVector_capacity(self)
    __swig_destroy__ = _RNA.delete_ConstCharVector

# Register ConstCharVector in _RNA:
_RNA.ConstCharVector_swigregister(ConstCharVector)

class SOLUTIONVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.SOLUTIONVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.SOLUTIONVector___nonzero__(self)

    def __bool__(self):
        return _RNA.SOLUTIONVector___bool__(self)

    def __len__(self):
        return _RNA.SOLUTIONVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.SOLUTIONVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.SOLUTIONVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.SOLUTIONVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.SOLUTIONVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.SOLUTIONVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.SOLUTIONVector___setitem__(self, *args)

    def pop(self):
        return _RNA.SOLUTIONVector_pop(self)

    def append(self, x):
        return _RNA.SOLUTIONVector_append(self, x)

    def empty(self):
        return _RNA.SOLUTIONVector_empty(self)

    def size(self):
        return _RNA.SOLUTIONVector_size(self)

    def swap(self, v):
        return _RNA.SOLUTIONVector_swap(self, v)

    def begin(self):
        return _RNA.SOLUTIONVector_begin(self)

    def end(self):
        return _RNA.SOLUTIONVector_end(self)

    def rbegin(self):
        return _RNA.SOLUTIONVector_rbegin(self)

    def rend(self):
        return _RNA.SOLUTIONVector_rend(self)

    def clear(self):
        return _RNA.SOLUTIONVector_clear(self)

    def get_allocator(self):
        return _RNA.SOLUTIONVector_get_allocator(self)

    def pop_back(self):
        return _RNA.SOLUTIONVector_pop_back(self)

    def erase(self, *args):
        return _RNA.SOLUTIONVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.SOLUTIONVector_swiginit(self, _RNA.new_SOLUTIONVector(*args))

    def push_back(self, x):
        return _RNA.SOLUTIONVector_push_back(self, x)

    def front(self):
        return _RNA.SOLUTIONVector_front(self)

    def back(self):
        return _RNA.SOLUTIONVector_back(self)

    def assign(self, n, x):
        return _RNA.SOLUTIONVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.SOLUTIONVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.SOLUTIONVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.SOLUTIONVector_reserve(self, n)

    def capacity(self):
        return _RNA.SOLUTIONVector_capacity(self)
    __swig_destroy__ = _RNA.delete_SOLUTIONVector

# Register SOLUTIONVector in _RNA:
_RNA.SOLUTIONVector_swigregister(SOLUTIONVector)

class CoordinateVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.CoordinateVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.CoordinateVector___nonzero__(self)

    def __bool__(self):
        return _RNA.CoordinateVector___bool__(self)

    def __len__(self):
        return _RNA.CoordinateVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.CoordinateVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.CoordinateVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.CoordinateVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.CoordinateVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.CoordinateVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.CoordinateVector___setitem__(self, *args)

    def pop(self):
        return _RNA.CoordinateVector_pop(self)

    def append(self, x):
        return _RNA.CoordinateVector_append(self, x)

    def empty(self):
        return _RNA.CoordinateVector_empty(self)

    def size(self):
        return _RNA.CoordinateVector_size(self)

    def swap(self, v):
        return _RNA.CoordinateVector_swap(self, v)

    def begin(self):
        return _RNA.CoordinateVector_begin(self)

    def end(self):
        return _RNA.CoordinateVector_end(self)

    def rbegin(self):
        return _RNA.CoordinateVector_rbegin(self)

    def rend(self):
        return _RNA.CoordinateVector_rend(self)

    def clear(self):
        return _RNA.CoordinateVector_clear(self)

    def get_allocator(self):
        return _RNA.CoordinateVector_get_allocator(self)

    def pop_back(self):
        return _RNA.CoordinateVector_pop_back(self)

    def erase(self, *args):
        return _RNA.CoordinateVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.CoordinateVector_swiginit(self, _RNA.new_CoordinateVector(*args))

    def push_back(self, x):
        return _RNA.CoordinateVector_push_back(self, x)

    def front(self):
        return _RNA.CoordinateVector_front(self)

    def back(self):
        return _RNA.CoordinateVector_back(self)

    def assign(self, n, x):
        return _RNA.CoordinateVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.CoordinateVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.CoordinateVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.CoordinateVector_reserve(self, n)

    def capacity(self):
        return _RNA.CoordinateVector_capacity(self)
    __swig_destroy__ = _RNA.delete_CoordinateVector

# Register CoordinateVector in _RNA:
_RNA.CoordinateVector_swigregister(CoordinateVector)

class DoubleDoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.DoubleDoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.DoubleDoubleVector___nonzero__(self)

    def __bool__(self):
        return _RNA.DoubleDoubleVector___bool__(self)

    def __len__(self):
        return _RNA.DoubleDoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.DoubleDoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.DoubleDoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.DoubleDoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.DoubleDoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.DoubleDoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.DoubleDoubleVector___setitem__(self, *args)

    def pop(self):
        return _RNA.DoubleDoubleVector_pop(self)

    def append(self, x):
        return _RNA.DoubleDoubleVector_append(self, x)

    def empty(self):
        return _RNA.DoubleDoubleVector_empty(self)

    def size(self):
        return _RNA.DoubleDoubleVector_size(self)

    def swap(self, v):
        return _RNA.DoubleDoubleVector_swap(self, v)

    def begin(self):
        return _RNA.DoubleDoubleVector_begin(self)

    def end(self):
        return _RNA.DoubleDoubleVector_end(self)

    def rbegin(self):
        return _RNA.DoubleDoubleVector_rbegin(self)

    def rend(self):
        return _RNA.DoubleDoubleVector_rend(self)

    def clear(self):
        return _RNA.DoubleDoubleVector_clear(self)

    def get_allocator(self):
        return _RNA.DoubleDoubleVector_get_allocator(self)

    def pop_back(self):
        return _RNA.DoubleDoubleVector_pop_back(self)

    def erase(self, *args):
        return _RNA.DoubleDoubleVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.DoubleDoubleVector_swiginit(self, _RNA.new_DoubleDoubleVector(*args))

    def push_back(self, x):
        return _RNA.DoubleDoubleVector_push_back(self, x)

    def front(self):
        return _RNA.DoubleDoubleVector_front(self)

    def back(self):
        return _RNA.DoubleDoubleVector_back(self)

    def assign(self, n, x):
        return _RNA.DoubleDoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.DoubleDoubleVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.DoubleDoubleVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.DoubleDoubleVector_reserve(self, n)

    def capacity(self):
        return _RNA.DoubleDoubleVector_capacity(self)
    __swig_destroy__ = _RNA.delete_DoubleDoubleVector

# Register DoubleDoubleVector in _RNA:
_RNA.DoubleDoubleVector_swigregister(DoubleDoubleVector)

class IntIntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.IntIntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.IntIntVector___nonzero__(self)

    def __bool__(self):
        return _RNA.IntIntVector___bool__(self)

    def __len__(self):
        return _RNA.IntIntVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.IntIntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.IntIntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.IntIntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.IntIntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.IntIntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.IntIntVector___setitem__(self, *args)

    def pop(self):
        return _RNA.IntIntVector_pop(self)

    def append(self, x):
        return _RNA.IntIntVector_append(self, x)

    def empty(self):
        return _RNA.IntIntVector_empty(self)

    def size(self):
        return _RNA.IntIntVector_size(self)

    def swap(self, v):
        return _RNA.IntIntVector_swap(self, v)

    def begin(self):
        return _RNA.IntIntVector_begin(self)

    def end(self):
        return _RNA.IntIntVector_end(self)

    def rbegin(self):
        return _RNA.IntIntVector_rbegin(self)

    def rend(self):
        return _RNA.IntIntVector_rend(self)

    def clear(self):
        return _RNA.IntIntVector_clear(self)

    def get_allocator(self):
        return _RNA.IntIntVector_get_allocator(self)

    def pop_back(self):
        return _RNA.IntIntVector_pop_back(self)

    def erase(self, *args):
        return _RNA.IntIntVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.IntIntVector_swiginit(self, _RNA.new_IntIntVector(*args))

    def push_back(self, x):
        return _RNA.IntIntVector_push_back(self, x)

    def front(self):
        return _RNA.IntIntVector_front(self)

    def back(self):
        return _RNA.IntIntVector_back(self)

    def assign(self, n, x):
        return _RNA.IntIntVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.IntIntVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.IntIntVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.IntIntVector_reserve(self, n)

    def capacity(self):
        return _RNA.IntIntVector_capacity(self)
    __swig_destroy__ = _RNA.delete_IntIntVector

# Register IntIntVector in _RNA:
_RNA.IntIntVector_swigregister(IntIntVector)

class ElemProbVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.ElemProbVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.ElemProbVector___nonzero__(self)

    def __bool__(self):
        return _RNA.ElemProbVector___bool__(self)

    def __len__(self):
        return _RNA.ElemProbVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.ElemProbVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.ElemProbVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.ElemProbVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.ElemProbVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.ElemProbVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.ElemProbVector___setitem__(self, *args)

    def pop(self):
        return _RNA.ElemProbVector_pop(self)

    def append(self, x):
        return _RNA.ElemProbVector_append(self, x)

    def empty(self):
        return _RNA.ElemProbVector_empty(self)

    def size(self):
        return _RNA.ElemProbVector_size(self)

    def swap(self, v):
        return _RNA.ElemProbVector_swap(self, v)

    def begin(self):
        return _RNA.ElemProbVector_begin(self)

    def end(self):
        return _RNA.ElemProbVector_end(self)

    def rbegin(self):
        return _RNA.ElemProbVector_rbegin(self)

    def rend(self):
        return _RNA.ElemProbVector_rend(self)

    def clear(self):
        return _RNA.ElemProbVector_clear(self)

    def get_allocator(self):
        return _RNA.ElemProbVector_get_allocator(self)

    def pop_back(self):
        return _RNA.ElemProbVector_pop_back(self)

    def erase(self, *args):
        return _RNA.ElemProbVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.ElemProbVector_swiginit(self, _RNA.new_ElemProbVector(*args))

    def push_back(self, x):
        return _RNA.ElemProbVector_push_back(self, x)

    def front(self):
        return _RNA.ElemProbVector_front(self)

    def back(self):
        return _RNA.ElemProbVector_back(self)

    def assign(self, n, x):
        return _RNA.ElemProbVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.ElemProbVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.ElemProbVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.ElemProbVector_reserve(self, n)

    def capacity(self):
        return _RNA.ElemProbVector_capacity(self)
    __swig_destroy__ = _RNA.delete_ElemProbVector

# Register ElemProbVector in _RNA:
_RNA.ElemProbVector_swigregister(ElemProbVector)

class HelixVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.HelixVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.HelixVector___nonzero__(self)

    def __bool__(self):
        return _RNA.HelixVector___bool__(self)

    def __len__(self):
        return _RNA.HelixVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.HelixVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.HelixVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.HelixVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.HelixVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.HelixVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.HelixVector___setitem__(self, *args)

    def pop(self):
        return _RNA.HelixVector_pop(self)

    def append(self, x):
        return _RNA.HelixVector_append(self, x)

    def empty(self):
        return _RNA.HelixVector_empty(self)

    def size(self):
        return _RNA.HelixVector_size(self)

    def swap(self, v):
        return _RNA.HelixVector_swap(self, v)

    def begin(self):
        return _RNA.HelixVector_begin(self)

    def end(self):
        return _RNA.HelixVector_end(self)

    def rbegin(self):
        return _RNA.HelixVector_rbegin(self)

    def rend(self):
        return _RNA.HelixVector_rend(self)

    def clear(self):
        return _RNA.HelixVector_clear(self)

    def get_allocator(self):
        return _RNA.HelixVector_get_allocator(self)

    def pop_back(self):
        return _RNA.HelixVector_pop_back(self)

    def erase(self, *args):
        return _RNA.HelixVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.HelixVector_swiginit(self, _RNA.new_HelixVector(*args))

    def push_back(self, x):
        return _RNA.HelixVector_push_back(self, x)

    def front(self):
        return _RNA.HelixVector_front(self)

    def back(self):
        return _RNA.HelixVector_back(self)

    def assign(self, n, x):
        return _RNA.HelixVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.HelixVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.HelixVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.HelixVector_reserve(self, n)

    def capacity(self):
        return _RNA.HelixVector_capacity(self)
    __swig_destroy__ = _RNA.delete_HelixVector

# Register HelixVector in _RNA:
_RNA.HelixVector_swigregister(HelixVector)

class PathVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.PathVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.PathVector___nonzero__(self)

    def __bool__(self):
        return _RNA.PathVector___bool__(self)

    def __len__(self):
        return _RNA.PathVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.PathVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.PathVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.PathVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.PathVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.PathVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.PathVector___setitem__(self, *args)

    def pop(self):
        return _RNA.PathVector_pop(self)

    def append(self, x):
        return _RNA.PathVector_append(self, x)

    def empty(self):
        return _RNA.PathVector_empty(self)

    def size(self):
        return _RNA.PathVector_size(self)

    def swap(self, v):
        return _RNA.PathVector_swap(self, v)

    def begin(self):
        return _RNA.PathVector_begin(self)

    def end(self):
        return _RNA.PathVector_end(self)

    def rbegin(self):
        return _RNA.PathVector_rbegin(self)

    def rend(self):
        return _RNA.PathVector_rend(self)

    def clear(self):
        return _RNA.PathVector_clear(self)

    def get_allocator(self):
        return _RNA.PathVector_get_allocator(self)

    def pop_back(self):
        return _RNA.PathVector_pop_back(self)

    def erase(self, *args):
        return _RNA.PathVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.PathVector_swiginit(self, _RNA.new_PathVector(*args))

    def push_back(self, x):
        return _RNA.PathVector_push_back(self, x)

    def front(self):
        return _RNA.PathVector_front(self)

    def back(self):
        return _RNA.PathVector_back(self)

    def assign(self, n, x):
        return _RNA.PathVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.PathVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.PathVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.PathVector_reserve(self, n)

    def capacity(self):
        return _RNA.PathVector_capacity(self)
    __swig_destroy__ = _RNA.delete_PathVector

# Register PathVector in _RNA:
_RNA.PathVector_swigregister(PathVector)

class MoveVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.MoveVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.MoveVector___nonzero__(self)

    def __bool__(self):
        return _RNA.MoveVector___bool__(self)

    def __len__(self):
        return _RNA.MoveVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.MoveVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.MoveVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.MoveVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.MoveVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.MoveVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.MoveVector___setitem__(self, *args)

    def pop(self):
        return _RNA.MoveVector_pop(self)

    def append(self, x):
        return _RNA.MoveVector_append(self, x)

    def empty(self):
        return _RNA.MoveVector_empty(self)

    def size(self):
        return _RNA.MoveVector_size(self)

    def swap(self, v):
        return _RNA.MoveVector_swap(self, v)

    def begin(self):
        return _RNA.MoveVector_begin(self)

    def end(self):
        return _RNA.MoveVector_end(self)

    def rbegin(self):
        return _RNA.MoveVector_rbegin(self)

    def rend(self):
        return _RNA.MoveVector_rend(self)

    def clear(self):
        return _RNA.MoveVector_clear(self)

    def get_allocator(self):
        return _RNA.MoveVector_get_allocator(self)

    def pop_back(self):
        return _RNA.MoveVector_pop_back(self)

    def erase(self, *args):
        return _RNA.MoveVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.MoveVector_swiginit(self, _RNA.new_MoveVector(*args))

    def push_back(self, x):
        return _RNA.MoveVector_push_back(self, x)

    def front(self):
        return _RNA.MoveVector_front(self)

    def back(self):
        return _RNA.MoveVector_back(self)

    def assign(self, n, x):
        return _RNA.MoveVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.MoveVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.MoveVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.MoveVector_reserve(self, n)

    def capacity(self):
        return _RNA.MoveVector_capacity(self)
    __swig_destroy__ = _RNA.delete_MoveVector

# Register MoveVector in _RNA:
_RNA.MoveVector_swigregister(MoveVector)


class var_array_Iterator:
    def __init__(self, var_arr):
        self.index = 0
        self.var_arr = var_arr
    def __iter__(self):
        return self
    def next(self):
        if self.index >= self.var_arr.size():
            raise StopIteration;
        ret = self.var_arr.get(self.index)
        self.index += 1
        return ret
    __next__ = next

class varArrayUChar(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d, type):
        _RNA.varArrayUChar_swiginit(self, _RNA.new_varArrayUChar(d, type))
    __swig_destroy__ = _RNA.delete_varArrayUChar

    def type(self):
        return _RNA.varArrayUChar_type(self)

    def size(self):
        return _RNA.varArrayUChar_size(self)

    def __len__(self):
        return _RNA.varArrayUChar___len__(self)

    def get(self, i):
        return _RNA.varArrayUChar_get(self, i)

    def __setitem__(self, i, d):
        return _RNA.varArrayUChar___setitem__(self, i, d)

    def __str__(self):
        return "{ data: [" + ",".join([str(s) for s in self]) + "], type: " + self.type() + "}"

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 

    def __iter__(self):
        return var_array_Iterator(self)



    def __getitem__(self, *args):
        return _RNA.varArrayUChar___getitem__(self, *args)

# Register varArrayUChar in _RNA:
_RNA.varArrayUChar_swigregister(varArrayUChar)

class varArrayChar(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d, type):
        _RNA.varArrayChar_swiginit(self, _RNA.new_varArrayChar(d, type))
    __swig_destroy__ = _RNA.delete_varArrayChar

    def type(self):
        return _RNA.varArrayChar_type(self)

    def size(self):
        return _RNA.varArrayChar_size(self)

    def __len__(self):
        return _RNA.varArrayChar___len__(self)

    def get(self, i):
        return _RNA.varArrayChar_get(self, i)

    def __setitem__(self, i, d):
        return _RNA.varArrayChar___setitem__(self, i, d)

    def __str__(self):
        return "{ data: [" + ",".join([str(s) for s in self]) + "], type: " + self.type() + "}"

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 

    def __iter__(self):
        return var_array_Iterator(self)



    def __getitem__(self, *args):
        return _RNA.varArrayChar___getitem__(self, *args)

# Register varArrayChar in _RNA:
_RNA.varArrayChar_swigregister(varArrayChar)

class varArrayShort(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RNA.delete_varArrayShort

    def type(self):
        return _RNA.varArrayShort_type(self)

    def size(self):
        return _RNA.varArrayShort_size(self)

    def __len__(self):
        return _RNA.varArrayShort___len__(self)

    def get(self, i):
        return _RNA.varArrayShort_get(self, i)

    def __setitem__(self, i, d):
        return _RNA.varArrayShort___setitem__(self, i, d)

    def __str__(self):
        return "{ data: [" + ",".join([str(s) for s in self]) + "], type: " + self.type() + "}"

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 

    def __iter__(self):
        return var_array_Iterator(self)



    def __init__(self, *args):
        _RNA.varArrayShort_swiginit(self, _RNA.new_varArrayShort(*args))

    def __getitem__(self, *args):
        return _RNA.varArrayShort___getitem__(self, *args)

# Register varArrayShort in _RNA:
_RNA.varArrayShort_swigregister(varArrayShort)

class varArrayUInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d, type):
        _RNA.varArrayUInt_swiginit(self, _RNA.new_varArrayUInt(d, type))
    __swig_destroy__ = _RNA.delete_varArrayUInt

    def type(self):
        return _RNA.varArrayUInt_type(self)

    def size(self):
        return _RNA.varArrayUInt_size(self)

    def __len__(self):
        return _RNA.varArrayUInt___len__(self)

    def get(self, i):
        return _RNA.varArrayUInt_get(self, i)

    def __setitem__(self, i, d):
        return _RNA.varArrayUInt___setitem__(self, i, d)

    def __str__(self):
        return "{ data: [" + ",".join([str(s) for s in self]) + "], type: " + self.type() + "}"

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 

    def __iter__(self):
        return var_array_Iterator(self)



    def __getitem__(self, *args):
        return _RNA.varArrayUInt___getitem__(self, *args)

# Register varArrayUInt in _RNA:
_RNA.varArrayUInt_swigregister(varArrayUInt)

class varArrayInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d, type):
        _RNA.varArrayInt_swiginit(self, _RNA.new_varArrayInt(d, type))
    __swig_destroy__ = _RNA.delete_varArrayInt

    def type(self):
        return _RNA.varArrayInt_type(self)

    def size(self):
        return _RNA.varArrayInt_size(self)

    def __len__(self):
        return _RNA.varArrayInt___len__(self)

    def get(self, i):
        return _RNA.varArrayInt_get(self, i)

    def __setitem__(self, i, d):
        return _RNA.varArrayInt___setitem__(self, i, d)

    def __str__(self):
        return "{ data: [" + ",".join([str(s) for s in self]) + "], type: " + self.type() + "}"

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 

    def __iter__(self):
        return var_array_Iterator(self)



    def __getitem__(self, *args):
        return _RNA.varArrayInt___getitem__(self, *args)

# Register varArrayInt in _RNA:
_RNA.varArrayInt_swigregister(varArrayInt)

class varArrayFLTorDBL(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d, type):
        _RNA.varArrayFLTorDBL_swiginit(self, _RNA.new_varArrayFLTorDBL(d, type))
    __swig_destroy__ = _RNA.delete_varArrayFLTorDBL

    def type(self):
        return _RNA.varArrayFLTorDBL_type(self)

    def size(self):
        return _RNA.varArrayFLTorDBL_size(self)

    def __len__(self):
        return _RNA.varArrayFLTorDBL___len__(self)

    def get(self, i):
        return _RNA.varArrayFLTorDBL_get(self, i)

    def __setitem__(self, i, d):
        return _RNA.varArrayFLTorDBL___setitem__(self, i, d)

    def __str__(self):
        return "{ data: [" + ",".join([str(s) for s in self]) + "], type: " + self.type() + "}"

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 

    def __iter__(self):
        return var_array_Iterator(self)



    def __getitem__(self, *args):
        return _RNA.varArrayFLTorDBL___getitem__(self, *args)

# Register varArrayFLTorDBL in _RNA:
_RNA.varArrayFLTorDBL_swigregister(varArrayFLTorDBL)

class varArrayMove(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d, type):
        _RNA.varArrayMove_swiginit(self, _RNA.new_varArrayMove(d, type))
    __swig_destroy__ = _RNA.delete_varArrayMove

    def type(self):
        return _RNA.varArrayMove_type(self)

    def size(self):
        return _RNA.varArrayMove_size(self)

    def __len__(self):
        return _RNA.varArrayMove___len__(self)

    def get(self, i):
        return _RNA.varArrayMove_get(self, i)

    def __setitem__(self, i, d):
        return _RNA.varArrayMove___setitem__(self, i, d)

    def __str__(self):
        return "{ data: [" + ",".join([str(s) for s in self]) + "], type: " + self.type() + "}"

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 

    def __iter__(self):
        return var_array_Iterator(self)



    def __getitem__(self, *args):
        return _RNA.varArrayMove___getitem__(self, *args)

# Register varArrayMove in _RNA:
_RNA.varArrayMove_swigregister(varArrayMove)

VAR_ARRAY_LINEAR = _RNA.VAR_ARRAY_LINEAR
VAR_ARRAY_TRI = _RNA.VAR_ARRAY_TRI
VAR_ARRAY_SQR = _RNA.VAR_ARRAY_SQR
VAR_ARRAY_ONE_BASED = _RNA.VAR_ARRAY_ONE_BASED
VAR_ARRAY_OWNED = _RNA.VAR_ARRAY_OWNED
class param(object):
    r"""


    The datastructure that contains temperature scaled energy parameters.  

    Attributes
    ----------
    id : int  

    stack : int  

    hairpin : int  

    bulge : int  

    internal_loop : int  

    mismatchExt : int  

    mismatchI : int  

    mismatch1nI : int  

    mismatch23I : int  

    mismatchH : int  

    mismatchM : int  

    dangle5 : int  

    dangle3 : int  

    int11 : int  

    int21 : int  

    int22 : int  

    ninio : int  

    lxc : double  

    MLbase : int  

    MLintern : int  

    MLclosing : int  

    TerminalAU : int  

    DuplexInit : int  

    Tetraloop_E : int  

    Tetraloops : char  

    Triloop_E : int  

    Triloops : char  

    Hexaloop_E : int  

    Hexaloops : char  

    TripleC : int  

    MultipleCA : int  

    MultipleCB : int  

    gquad : int  

    gquadLayerMismatch : int  

    gquadLayerMismatchMax : int  

    temperature : double  
        Temperature used for loop contribution scaling.  

    model_details : vrna_md_t  
        Model details to be used in the recursions.  

    param_file : char  
        The filename the parameters were derived from, or empty string if they represent the default.  

    SaltStack : int  

    SaltLoop : int  

    SaltLoopDbl : double  

    SaltMLbase : int  

    SaltMLintern : int  

    SaltMLclosing : int  

    SaltDPXInit : int  

    C++ includes: ViennaRNA/params/basic.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    id = property(_RNA.param_id_get)
    stack = property(_RNA.param_stack_get)
    hairpin = property(_RNA.param_hairpin_get)
    bulge = property(_RNA.param_bulge_get)
    internal_loop = property(_RNA.param_internal_loop_get)
    mismatchExt = property(_RNA.param_mismatchExt_get)
    mismatchI = property(_RNA.param_mismatchI_get)
    mismatch1nI = property(_RNA.param_mismatch1nI_get)
    mismatch23I = property(_RNA.param_mismatch23I_get)
    mismatchH = property(_RNA.param_mismatchH_get)
    mismatchM = property(_RNA.param_mismatchM_get)
    dangle5 = property(_RNA.param_dangle5_get)
    dangle3 = property(_RNA.param_dangle3_get)
    int11 = property(_RNA.param_int11_get)
    int21 = property(_RNA.param_int21_get)
    int22 = property(_RNA.param_int22_get)
    ninio = property(_RNA.param_ninio_get)
    lxc = property(_RNA.param_lxc_get)
    MLbase = property(_RNA.param_MLbase_get)
    MLintern = property(_RNA.param_MLintern_get)
    MLclosing = property(_RNA.param_MLclosing_get)
    TerminalAU = property(_RNA.param_TerminalAU_get)
    DuplexInit = property(_RNA.param_DuplexInit_get)
    Tetraloop_E = property(_RNA.param_Tetraloop_E_get)
    Tetraloops = property(_RNA.param_Tetraloops_get)
    Triloop_E = property(_RNA.param_Triloop_E_get)
    Triloops = property(_RNA.param_Triloops_get)
    Hexaloop_E = property(_RNA.param_Hexaloop_E_get)
    Hexaloops = property(_RNA.param_Hexaloops_get)
    TripleC = property(_RNA.param_TripleC_get)
    MultipleCA = property(_RNA.param_MultipleCA_get)
    MultipleCB = property(_RNA.param_MultipleCB_get)
    gquad = property(_RNA.param_gquad_get)
    gquadLayerMismatch = property(_RNA.param_gquadLayerMismatch_get)
    gquadLayerMismatchMax = property(_RNA.param_gquadLayerMismatchMax_get)
    temperature = property(_RNA.param_temperature_get)
    model_details = property(_RNA.param_model_details_get)
    param_file = property(_RNA.param_param_file_get)
    SaltStack = property(_RNA.param_SaltStack_get)
    SaltLoop = property(_RNA.param_SaltLoop_get)
    SaltLoopDbl = property(_RNA.param_SaltLoopDbl_get)
    SaltMLbase = property(_RNA.param_SaltMLbase_get)
    SaltMLintern = property(_RNA.param_SaltMLintern_get)
    SaltMLclosing = property(_RNA.param_SaltMLclosing_get)
    SaltDPXInit = property(_RNA.param_SaltDPXInit_get)

    def __init__(self, model_details=None):
        r"""


        The datastructure that contains temperature scaled energy parameters.  

        Attributes
        ----------
        id : int  

        stack : int  

        hairpin : int  

        bulge : int  

        internal_loop : int  

        mismatchExt : int  

        mismatchI : int  

        mismatch1nI : int  

        mismatch23I : int  

        mismatchH : int  

        mismatchM : int  

        dangle5 : int  

        dangle3 : int  

        int11 : int  

        int21 : int  

        int22 : int  

        ninio : int  

        lxc : double  

        MLbase : int  

        MLintern : int  

        MLclosing : int  

        TerminalAU : int  

        DuplexInit : int  

        Tetraloop_E : int  

        Tetraloops : char  

        Triloop_E : int  

        Triloops : char  

        Hexaloop_E : int  

        Hexaloops : char  

        TripleC : int  

        MultipleCA : int  

        MultipleCB : int  

        gquad : int  

        gquadLayerMismatch : int  

        gquadLayerMismatchMax : int  

        temperature : double  
            Temperature used for loop contribution scaling.  

        model_details : vrna_md_t  
            Model details to be used in the recursions.  

        param_file : char  
            The filename the parameters were derived from, or empty string if they represent the default.  

        SaltStack : int  

        SaltLoop : int  

        SaltLoopDbl : double  

        SaltMLbase : int  

        SaltMLintern : int  

        SaltMLclosing : int  

        SaltDPXInit : int  

        C++ includes: ViennaRNA/params/basic.h

        """
        _RNA.param_swiginit(self, _RNA.new_param(model_details))
    __swig_destroy__ = _RNA.delete_param

    def __str__(self):
        return _RNA.param___str__(self)

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 


# Register param in _RNA:
_RNA.param_swigregister(param)

class exp_param(object):
    r"""


    The data structure that contains temperature scaled Boltzmann weights of the energy parameters.  

    Attributes
    ----------
    id : int  
        An identifier for the data structure.  

        .. deprecated:: 2.6.4
            This attribute will be removed in version 3  

    expstack : double  

    exphairpin : double  

    expbulge : double  

    expinternal : double  

    expmismatchExt : double  

    expmismatchI : double  

    expmismatch23I : double  

    expmismatch1nI : double  

    expmismatchH : double  

    expmismatchM : double  

    expdangle5 : double  

    expdangle3 : double  

    expint11 : double  

    expint21 : double  

    expint22 : double  

    expninio : double  

    lxc : double  

    expMLbase : double  

    expMLintern : double  

    expMLclosing : double  

    expTermAU : double  

    expDuplexInit : double  

    exptetra : double  

    exptri : double  

    exphex : double  

    Tetraloops : char  

    expTriloop : double  

    Triloops : char  

    Hexaloops : char  

    expTripleC : double  

    expMultipleCA : double  

    expMultipleCB : double  

    expgquad : double  

    expgquadLayerMismatch : double  

    gquadLayerMismatchMax : int  

    kT : double  

    pf_scale : double  
        Scaling factor to avoid over-/underflows.  

    temperature : double  
        Temperature used for loop contribution scaling.  

    alpha : double  
        Scaling factor for the thermodynamic temperature.  

        This allows for temperature scaling in Boltzmann factors independently from the energy
        contributions. The resulting Boltzmann factors are then computed by :math:`e^{-E/(\alpha \cdot
        K \cdot T)}`  

    model_details : vrna_md_t  
        Model details to be used in the recursions.  

    param_file : char  
        The filename the parameters were derived from, or empty string if they represent the default.  

    expSaltStack : double  

    expSaltLoop : double  

    SaltLoopDbl : double  

    SaltMLbase : int  

    SaltMLintern : int  

    SaltMLclosing : int  

    SaltDPXInit : int  

    C++ includes: ViennaRNA/params/basic.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    id = property(_RNA.exp_param_id_get)
    expstack = property(_RNA.exp_param_expstack_get)
    exphairpin = property(_RNA.exp_param_exphairpin_get)
    expbulge = property(_RNA.exp_param_expbulge_get)
    expinternal = property(_RNA.exp_param_expinternal_get)
    expmismatchExt = property(_RNA.exp_param_expmismatchExt_get)
    expmismatchI = property(_RNA.exp_param_expmismatchI_get)
    expmismatch23I = property(_RNA.exp_param_expmismatch23I_get)
    expmismatch1nI = property(_RNA.exp_param_expmismatch1nI_get)
    expmismatchH = property(_RNA.exp_param_expmismatchH_get)
    expmismatchM = property(_RNA.exp_param_expmismatchM_get)
    expdangle5 = property(_RNA.exp_param_expdangle5_get)
    expdangle3 = property(_RNA.exp_param_expdangle3_get)
    expint11 = property(_RNA.exp_param_expint11_get)
    expint21 = property(_RNA.exp_param_expint21_get)
    expint22 = property(_RNA.exp_param_expint22_get)
    expninio = property(_RNA.exp_param_expninio_get)
    lxc = property(_RNA.exp_param_lxc_get)
    expMLbase = property(_RNA.exp_param_expMLbase_get)
    expMLintern = property(_RNA.exp_param_expMLintern_get)
    expMLclosing = property(_RNA.exp_param_expMLclosing_get)
    expTermAU = property(_RNA.exp_param_expTermAU_get)
    expDuplexInit = property(_RNA.exp_param_expDuplexInit_get)
    exptetra = property(_RNA.exp_param_exptetra_get)
    exptri = property(_RNA.exp_param_exptri_get)
    exphex = property(_RNA.exp_param_exphex_get)
    Tetraloops = property(_RNA.exp_param_Tetraloops_get)
    expTriloop = property(_RNA.exp_param_expTriloop_get)
    Triloops = property(_RNA.exp_param_Triloops_get)
    Hexaloops = property(_RNA.exp_param_Hexaloops_get)
    expTripleC = property(_RNA.exp_param_expTripleC_get)
    expMultipleCA = property(_RNA.exp_param_expMultipleCA_get)
    expMultipleCB = property(_RNA.exp_param_expMultipleCB_get)
    expgquad = property(_RNA.exp_param_expgquad_get)
    expgquadLayerMismatch = property(_RNA.exp_param_expgquadLayerMismatch_get)
    gquadLayerMismatchMax = property(_RNA.exp_param_gquadLayerMismatchMax_get)
    kT = property(_RNA.exp_param_kT_get)
    pf_scale = property(_RNA.exp_param_pf_scale_get)
    temperature = property(_RNA.exp_param_temperature_get)
    alpha = property(_RNA.exp_param_alpha_get)
    model_details = property(_RNA.exp_param_model_details_get)
    param_file = property(_RNA.exp_param_param_file_get)
    expSaltStack = property(_RNA.exp_param_expSaltStack_get)
    expSaltLoop = property(_RNA.exp_param_expSaltLoop_get)
    SaltLoopDbl = property(_RNA.exp_param_SaltLoopDbl_get)
    SaltMLbase = property(_RNA.exp_param_SaltMLbase_get)
    SaltMLintern = property(_RNA.exp_param_SaltMLintern_get)
    SaltMLclosing = property(_RNA.exp_param_SaltMLclosing_get)
    SaltDPXInit = property(_RNA.exp_param_SaltDPXInit_get)

    def __init__(self, model_details=None):
        r"""


        The data structure that contains temperature scaled Boltzmann weights of the energy parameters.  

        Attributes
        ----------
        id : int  
            An identifier for the data structure.  

            .. deprecated:: 2.6.4
                This attribute will be removed in version 3  

        expstack : double  

        exphairpin : double  

        expbulge : double  

        expinternal : double  

        expmismatchExt : double  

        expmismatchI : double  

        expmismatch23I : double  

        expmismatch1nI : double  

        expmismatchH : double  

        expmismatchM : double  

        expdangle5 : double  

        expdangle3 : double  

        expint11 : double  

        expint21 : double  

        expint22 : double  

        expninio : double  

        lxc : double  

        expMLbase : double  

        expMLintern : double  

        expMLclosing : double  

        expTermAU : double  

        expDuplexInit : double  

        exptetra : double  

        exptri : double  

        exphex : double  

        Tetraloops : char  

        expTriloop : double  

        Triloops : char  

        Hexaloops : char  

        expTripleC : double  

        expMultipleCA : double  

        expMultipleCB : double  

        expgquad : double  

        expgquadLayerMismatch : double  

        gquadLayerMismatchMax : int  

        kT : double  

        pf_scale : double  
            Scaling factor to avoid over-/underflows.  

        temperature : double  
            Temperature used for loop contribution scaling.  

        alpha : double  
            Scaling factor for the thermodynamic temperature.  

            This allows for temperature scaling in Boltzmann factors independently from the energy
            contributions. The resulting Boltzmann factors are then computed by :math:`e^{-E/(\alpha \cdot
            K \cdot T)}`  

        model_details : vrna_md_t  
            Model details to be used in the recursions.  

        param_file : char  
            The filename the parameters were derived from, or empty string if they represent the default.  

        expSaltStack : double  

        expSaltLoop : double  

        SaltLoopDbl : double  

        SaltMLbase : int  

        SaltMLintern : int  

        SaltMLclosing : int  

        SaltDPXInit : int  

        C++ includes: ViennaRNA/params/basic.h

        """
        _RNA.exp_param_swiginit(self, _RNA.new_exp_param(model_details))
    __swig_destroy__ = _RNA.delete_exp_param

    def __str__(self):
        return _RNA.exp_param___str__(self)

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 


# Register exp_param in _RNA:
_RNA.exp_param_swigregister(exp_param)


def params_load(*args, **kwargs):
    r"""
    params_load(std::string filename="", unsigned int options=) -> int


    Load energy parameters from a file.  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `params_load`(fname="",
        options=RNA.PARAMETER_FORMAT_DEFAULT). Here, the empty filename string indicates to load
        default RNA parameters, i.e. this is equivalent to calling RNA.params_load_defaults(). See,
        e.g.  :py:func:`RNA.fold_compound.params_load()` in the :doc:`/api_python`.  

    Parameters
    ----------
    fname : const char
        The path to the file containing the energy parameters  
    options : unsigned int
        File format bit-mask (usually RNA.PARAMETER_FORMAT_DEFAULT)  

    Returns
    -------
    int  
        Non-zero on success, 0 on failure  

    See Also
    --------
    RNA.params_load_from_string(), RNA.params_save(), RNA.params_load_defaults(),
    RNA.params_load_RNA_Turner2004(), RNA.params_load_RNA_Turner1999(),
    RNA.params_load_RNA_Andronescu2007(), RNA.params_load_RNA_Langdon2018(),
    RNA.params_load_RNA_misc_special_hairpins(), RNA.params_load_DNA_Mathews2004(),
    RNA.params_load_DNA_Mathews1999()  

    """
    return _RNA.params_load(*args, **kwargs)

def params_save(*args, **kwargs):
    r"""
    params_save(std::string filename, unsigned int options=) -> int


    Save energy parameters to a file.  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `params_save`(fname,
        options=RNA.PARAMETER_FORMAT_DEFAULT). See, e.g.  :py:func:`RNA.params_save()` in the
        :doc:`/api_python`.  

    Parameters
    ----------
    fname : const char
        A filename (path) for the file where the current energy parameters will be written to  
    options : unsigned int
        File format bit-mask (usually RNA.PARAMETER_FORMAT_DEFAULT)  

    Returns
    -------
    int  
        Non-zero on success, 0 on failure  

    See Also
    --------
    RNA.params_load()  

    """
    return _RNA.params_save(*args, **kwargs)

def params_load_from_string(*args, **kwargs):
    r"""
    params_load_from_string(std::string parameters, std::string name="", unsigned int options=) -> int


    Load energy paramters from string.  

    The string must follow the default energy parameter file convention! The optional `name` argument
    allows one to specify a name for the parameter set which is stored internally.  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `params_load_from_string`(string, name="",
        options=RNA.PARAMETER_FORMAT_DEFAULT). See, e.g.  :py:func:`RNA.params_load_from_string()` in
        the :doc:`/api_python`.  

    Parameters
    ----------
    string : const char *
        A 0-terminated string containing energy parameters  
    name : const char *
        A name for the parameter set in `string` (Maybe `NULL`)  
    options : unsigned int
        File format bit-mask (usually RNA.PARAMETER_FORMAT_DEFAULT)  

    Returns
    -------
    int  
        Non-zero on success, 0 on failure  

    See Also
    --------
    RNA.params_load(), RNA.params_save(), RNA.params_load_defaults(),
    RNA.params_load_RNA_Turner2004(), RNA.params_load_RNA_Turner1999(),
    RNA.params_load_RNA_Andronescu2007(), RNA.params_load_RNA_Langdon2018(),
    RNA.params_load_RNA_misc_special_hairpins(), RNA.params_load_DNA_Mathews2004(),
    RNA.params_load_DNA_Mathews1999()  

    """
    return _RNA.params_load_from_string(*args, **kwargs)
PARAMETER_FORMAT_DEFAULT = _RNA.PARAMETER_FORMAT_DEFAULT
r"""


    Default Energy Parameter File format.  

    See Also
    --------
    RNA.params_load(), RNA.params_load_from_string(), RNA.params_save()  

    """

def params_load_RNA_Turner2004():
    r"""


    Load Turner 2004 RNA energy parameter set.  

    **SWIG Wrapper Notes**
        This function is available as function `params_load_RNA_Turner2004()`. See, e.g.
        :py:func:`RNA.params_load_RNA_Turner2004()` in the :doc:`/api_python`.  

    Returns
    -------
    int  
        Non-zero on success, 0 on failure  

    Warnings
    --------
    This function also resets the default geometric parameters as stored in RNA.md() to those of RNA.
    Only subsequently initialized RNA.md() structures will be affected by this change.  

    See Also
    --------
    RNA.params_load(), RNA.params_load_from_string(), RNA.params_save(), RNA.params_load_defaults(),
    RNA.params_load_RNA_Turner1999(), RNA.params_load_RNA_Andronescu2007(),
    RNA.params_load_RNA_Langdon2018(), RNA.params_load_RNA_misc_special_hairpins(),
    RNA.params_load_DNA_Mathews2004(), RNA.params_load_DNA_Mathews1999()  

    """
    return _RNA.params_load_RNA_Turner2004()

def params_load_RNA_Turner1999():
    r"""


    Load Turner 1999 RNA energy parameter set.  

    **SWIG Wrapper Notes**
        This function is available as function `params_load_RNA_Turner1999()`. See, e.g.
        :py:func:`RNA.params_load_RNA_Turner1999()` in the :doc:`/api_python`.  

    Returns
    -------
    int  
        Non-zero on success, 0 on failure  

    Warnings
    --------
    This function also resets the default geometric parameters as stored in RNA.md() to those of RNA.
    Only subsequently initialized RNA.md() structures will be affected by this change.  

    See Also
    --------
    RNA.params_load(), RNA.params_load_from_string(), RNA.params_save(),
    RNA.params_load_RNA_Turner2004(), RNA.params_load_defaults(),
    RNA.params_load_RNA_Andronescu2007(), RNA.params_load_RNA_Langdon2018(),
    RNA.params_load_RNA_misc_special_hairpins(), RNA.params_load_DNA_Mathews2004(),
    RNA.params_load_DNA_Mathews1999()  

    """
    return _RNA.params_load_RNA_Turner1999()

def params_load_RNA_Andronescu2007():
    r"""


    Load Andronsecu 2007 RNA energy parameter set.  

    **SWIG Wrapper Notes**
        This function is available as function `params_load_RNA_Andronescu2007()`. See, e.g.
        :py:func:`RNA.params_load_RNA_Andronescu2007()` in the :doc:`/api_python`.  

    Returns
    -------
    int  
        Non-zero on success, 0 on failure  

    Warnings
    --------
    This function also resets the default geometric parameters as stored in RNA.md() to those of RNA.
    Only subsequently initialized RNA.md() structures will be affected by this change.  

    See Also
    --------
    RNA.params_load(), RNA.params_load_from_string(), RNA.params_save(),
    RNA.params_load_RNA_Turner2004(), RNA.params_load_RNA_Turner1999(), RNA.params_load_defaults(),
    RNA.params_load_RNA_Langdon2018(), RNA.params_load_RNA_misc_special_hairpins(),
    RNA.params_load_DNA_Mathews2004(), RNA.params_load_DNA_Mathews1999()  

    """
    return _RNA.params_load_RNA_Andronescu2007()

def params_load_RNA_Langdon2018():
    r"""


    Load Langdon 2018 RNA energy parameter set.  

    **SWIG Wrapper Notes**
        This function is available as function `params_load_RNA_Langdon2018()`. See, e.g.
        :py:func:`RNA.params_load_RNA_Langdon2018()` in the :doc:`/api_python`.  

    Returns
    -------
    int  
        Non-zero on success, 0 on failure  

    Warnings
    --------
    This function also resets the default geometric parameters as stored in RNA.md() to those of RNA.
    Only subsequently initialized RNA.md() structures will be affected by this change.  

    See Also
    --------
    RNA.params_load(), RNA.params_load_from_string(), RNA.params_save(),
    RNA.params_load_RNA_Turner2004(), RNA.params_load_RNA_Turner1999(),
    RNA.params_load_RNA_Andronescu2007(), RNA.params_load_defaults(),
    RNA.params_load_RNA_misc_special_hairpins(), RNA.params_load_DNA_Mathews2004(),
    RNA.params_load_DNA_Mathews1999()  

    """
    return _RNA.params_load_RNA_Langdon2018()

def params_load_RNA_misc_special_hairpins():
    r"""


    Load Misc Special Hairpin RNA energy parameter set.  

    **SWIG Wrapper Notes**
        This function is available as function `params_load_RNA_misc_special_hairpins()`. See, e.g.
        :py:func:`RNA.params_load_RNA_misc_special_hairpins()` in the :doc:`/api_python`.  

    Returns
    -------
    int  
        Non-zero on success, 0 on failure  

    Warnings
    --------
    This function also resets the default geometric parameters as stored in RNA.md() to those of RNA.
    Only subsequently initialized RNA.md() structures will be affected by this change.  

    See Also
    --------
    RNA.params_load(), RNA.params_load_from_string(), RNA.params_save(),
    RNA.params_load_RNA_Turner2004(), RNA.params_load_RNA_Turner1999(),
    RNA.params_load_RNA_Andronescu2007(), RNA.params_load_RNA_Langdon2018(),
    RNA.params_load_defaults(), RNA.params_load_DNA_Mathews2004(), RNA.params_load_DNA_Mathews1999()  

    """
    return _RNA.params_load_RNA_misc_special_hairpins()

def params_load_DNA_Mathews2004():
    r"""


    Load Mathews 2004 DNA energy parameter set.  

    **SWIG Wrapper Notes**
        This function is available as function `params_load_DNA_Mathews2004()`. See, e.g.
        :py:func:`RNA.params_load_DNA_Mathews2004()` in the :doc:`/api_python`.  

    Returns
    -------
    int  
        Non-zero on success, 0 on failure  

    Warnings
    --------
    This function also resets the default geometric parameters as stored in RNA.md() to those of DNA.
    Only subsequently initialized RNA.md() structures will be affected by this change.  

    See Also
    --------
    RNA.params_load(), RNA.params_load_from_string(), RNA.params_save(),
    RNA.params_load_RNA_Turner2004(), RNA.params_load_RNA_Turner1999(),
    RNA.params_load_RNA_Andronescu2007(), RNA.params_load_RNA_Langdon2018(),
    RNA.params_load_RNA_misc_special_hairpins(), RNA.params_load_defaults(),
    RNA.params_load_DNA_Mathews1999()  

    """
    return _RNA.params_load_DNA_Mathews2004()

def params_load_DNA_Mathews1999():
    r"""


    Load Mathews 1999 DNA energy parameter set.  

    **SWIG Wrapper Notes**
        This function is available as function `params_load_DNA_Mathews1999()`. See, e.g.
        :py:func:`RNA.params_load_DNA_Mathews1999()` in the :doc:`/api_python`.  

    Returns
    -------
    int  
        Non-zero on success, 0 on failure  

    Warnings
    --------
    This function also resets the default geometric parameters as stored in RNA.md() to those of DNA.
    Only subsequently initialized RNA.md() structures will be affected by this change.  

    See Also
    --------
    RNA.params_load(), RNA.params_load_from_string(), RNA.params_save(),
    RNA.params_load_RNA_Turner2004(), RNA.params_load_RNA_Turner1999(),
    RNA.params_load_RNA_Andronescu2007(), RNA.params_load_RNA_Langdon2018(),
    RNA.params_load_RNA_misc_special_hairpins(), RNA.params_load_DNA_Mathews2004(),
    RNA.params_load_defaults()  

    """
    return _RNA.params_load_DNA_Mathews1999()
UNKNOWN = _RNA.UNKNOWN
QUIT = _RNA.QUIT
S = _RNA.S
S_H = _RNA.S_H
HP = _RNA.HP
HP_H = _RNA.HP_H
B = _RNA.B
B_H = _RNA.B_H
IL = _RNA.IL
IL_H = _RNA.IL_H
MMH = _RNA.MMH
MMH_H = _RNA.MMH_H
MMI = _RNA.MMI
MMI_H = _RNA.MMI_H
MMI1N = _RNA.MMI1N
MMI1N_H = _RNA.MMI1N_H
MMI23 = _RNA.MMI23
MMI23_H = _RNA.MMI23_H
MMM = _RNA.MMM
MMM_H = _RNA.MMM_H
MME = _RNA.MME
MME_H = _RNA.MME_H
D5 = _RNA.D5
D5_H = _RNA.D5_H
D3 = _RNA.D3
D3_H = _RNA.D3_H
INT11 = _RNA.INT11
INT11_H = _RNA.INT11_H
INT21 = _RNA.INT21
INT21_H = _RNA.INT21_H
INT22 = _RNA.INT22
INT22_H = _RNA.INT22_H
ML = _RNA.ML
TL = _RNA.TL
TRI = _RNA.TRI
HEX = _RNA.HEX
NIN = _RNA.NIN
MISC = _RNA.MISC

def last_parameter_file():
    r"""


    Get the file name of the parameter file that was most recently loaded.  

    Returns
    -------
    const char *  
        The file name of the last parameter file, or NULL if parameters are still at defaults  

    """
    return _RNA.last_parameter_file()

def read_parameter_file(fname):
    r"""


    Read energy parameters from a file.  

    .. deprecated:: 2.6.4
        Use RNA.params_load() instead!  

    Parameters
    ----------
    fname : const char
        The path to the file containing the energy parameters  

    """
    return _RNA.read_parameter_file(fname)

def write_parameter_file(fname):
    r"""


    Write energy parameters to a file.  

    .. deprecated:: 2.6.4
        Use RNA.params_save() instead!  

    Parameters
    ----------
    fname : const char
        A filename (path) for the file where the current energy parameters will be written to  

    """
    return _RNA.write_parameter_file(fname)

def gettype(ident):
    r"""


    """
    return _RNA.gettype(ident)

def settype(s):
    r"""


    """
    return _RNA.settype(s)

def salt_loop(L, salt, T, backbonelen):
    r"""


    Get salt correction for a loop at a given salt concentration and temperature.  

    Parameters
    ----------
    L : int
        backbone number in loop  
    salt : double
        salt concentration (M)  
    T : double
        absolute temperature (K)  
    backbonelen : double
        Backbone Length, phosphate-to-phosphate distance (typically 6 for RNA, 6.76 for DNA)  

    Returns
    -------
    double  
        Salt correction for loop in dcal/mol  

    """
    return _RNA.salt_loop(L, salt, T, backbonelen)

def salt_loop_int(L, salt, T, backbonelen):
    r"""


    Get salt correction for a loop at a given salt concentration and temperature.  

    This functions is same as RNA.salt_loop but returns rounded salt correction in integer  

    Parameters
    ----------
    L : int
        backbone number in loop  
    salt : double
        salt concentration (M)  
    T : double
        absolute temperature (K)  
    backbonelen : double
        Backbone Length, phosphate-to-phosphate distance (typically 6 for RNA, 6.76 for DNA)  

    Returns
    -------
    int  
        Rounded salt correction for loop in dcal/mol  

    See Also
    --------
    RNA.salt_loop  

    """
    return _RNA.salt_loop_int(L, salt, T, backbonelen)

def salt_stack(salt, T, hrise):
    r"""


    Get salt correction for a stack at a given salt concentration and temperature.  

    Parameters
    ----------
    salt : double
        salt concentration (M)  
    T : double
        absolute temperature (K)  
    hrise : double
        Helical Rise (typically 2.8 for RNA, 3.4 for DNA)  

    Returns
    -------
    int  
        Rounded salt correction for stack in dcal/mol  

    """
    return _RNA.salt_stack(salt, T, hrise)

def salt_ml(saltLoop, lower, upper, m, b):
    r"""


    Fit linear function to loop salt correction.  

    For a given range of loop size (backbone number), we perform a linear fitting on loop salt
    correction  

    .. math::

      \text{Loop correction} \approx m \cdot L + b.  

    Parameters
    ----------
    saltLoop : double
        List of loop salt correction of size from 1  
    lower : int
        Define the size lower bound for fitting  
    upper : int
        Define the size upper bound for fitting  
    m : int *
        pointer to store the parameter m in fitting result  
    b : int *
        pointer to store the parameter b in fitting result  

    See Also
    --------
    RNA.salt_loop()  

    """
    return _RNA.salt_ml(saltLoop, lower, upper, m, b)

def salt_duplex_init(md):
    r"""


    Get salt correction for duplex initialization at a given salt concentration.  

    Parameters
    ----------
    md : RNA.md() *
        Model details data structure that specfifies salt concentration in buffer (M)  

    Returns
    -------
    int  
        Rounded correction for duplex initialization in dcal/mol  

    """
    return _RNA.salt_duplex_init(md)
GASCONST = _RNA.GASCONST
r"""


    The gas constant  

    """
K0 = _RNA.K0
r"""


    0 deg Celsius in Kelvin  

    """
INF = _RNA.INF
r"""


    Infinity as used in minimization routines  

    """
EMAX = _RNA.EMAX
r"""


    """
FORBIDDEN = _RNA.FORBIDDEN
r"""


    forbidden  

    """
BONUS = _RNA.BONUS
r"""


    bonus contribution  

    """
NBPAIRS = _RNA.NBPAIRS
r"""


    The number of distinguishable base pairs  

    """
TURN = _RNA.TURN
r"""


    The minimum loop length  

    """
MAXLOOP = _RNA.MAXLOOP
r"""


    The maximum loop length  

    """
UNIT = _RNA.UNIT
r"""


    """
MINPSCORE = _RNA.MINPSCORE
r"""


    """
class md(object):
    r"""


    The data structure that contains the complete model details used throughout the calculations.  

    For convenience reasons, we provide the type name RNA.md() to address this data structure without
    the use of the struct keyword  

    See Also
    --------
    RNA.md.reset(), set_model_details(), RNA.md_update(), RNA.md()  

    **SWIG Wrapper Notes**
        This data structure is wrapped as an object `md` with multiple related functions attached as
        methods.  

        A new set of default parameters can be obtained by calling the constructure of `md:`  

        *   `md()`-- Initialize with default settings  

        The resulting object has a list of attached methods which directly correspond to functions that
        mainly operate on the corresponding *C* data structure:  

        *   `reset()` - RNA.md.reset()  
        *   `set_from_globals()` - set_model_details()  
        *   `option_string()` - RNA.md.option_string()  

        Note, that default parameters can be modified by directly setting any of the following global
        variables. Internally, getting/setting default parameters using their global variable
        representative translates into calls of the following functions, therefore these wrappers for
        these functions do not exist in the scripting language interface(s):  


    global variable  

    `C getter`  

    `C setter`  

    temperature  

    RNA.md_defaults_temperature_get()  

    RNA.md_defaults_temperature()  

    dangles  

    RNA.md_defaults_dangles_get()  

    RNA.md_defaults_dangles()  

    betaScale  

    RNA.md_defaults_betaScale_get()  

    RNA.md_defaults_betaScale()  

    tetra_loop  

    this is an alias of *special_hp*  


    special_hp  

    RNA.md_defaults_special_hp_get()  

    RNA.md_defaults_special_hp()  

    noLonelyPairs  

    this is an alias of *noLP*  


    noLP  

    RNA.md_defaults_noLP_get()  

    RNA.md_defaults_noLP()  

    noGU  

    RNA.md_defaults_noGU_get()  

    RNA.md_defaults_noGU()  

    no_closingGU  

    this is an alias of *noGUclosure*  


    noGUclosure  

    RNA.md_defaults_noGUclosure_get()  

    RNA.md_defaults_noGUclosure()  

    logML  

    RNA.md_defaults_logML_get()  

    RNA.md_defaults_logML()  

    circ  

    RNA.md_defaults_circ_get()  

    RNA.md_defaults_circ()  

    gquad  

    RNA.md_defaults_gquad_get()  

    RNA.md_defaults_gquad()  

    uniq_ML  

    RNA.md_defaults_uniq_ML_get()  

    RNA.md_defaults_uniq_ML()  

    energy_set  

    RNA.md_defaults_energy_set_get()  

    RNA.md_defaults_energy_set()  

    backtrack  

    RNA.md_defaults_backtrack_get()  

    RNA.md_defaults_backtrack()  

    backtrack_type  

    RNA.md_defaults_backtrack_type_get()  

    RNA.md_defaults_backtrack_type()  

    do_backtrack  

    this is an alias of *compute_bpp*  


    compute_bpp  

    RNA.md_defaults_compute_bpp_get()  

    RNA.md_defaults_compute_bpp()  

    max_bp_span  

    RNA.md_defaults_max_bp_span_get()  

    RNA.md_defaults_max_bp_span()  

    min_loop_size  

    RNA.md_defaults_min_loop_size_get()  

    RNA.md_defaults_min_loop_size()  

    window_size  

    RNA.md_defaults_window_size_get()  

    RNA.md_defaults_window_size()  

    oldAliEn  

    RNA.md_defaults_oldAliEn_get()  

    RNA.md_defaults_oldAliEn()  

    ribo  

    RNA.md_defaults_ribo_get()  

    RNA.md_defaults_ribo()  

    cv_fact  

    RNA.md_defaults_cv_fact_get()  

    RNA.md_defaults_cv_fact()  

    nc_fact  

    RNA.md_defaults_nc_fact_get()  

    RNA.md_defaults_nc_fact()  

    sfact  

    RNA.md_defaults_sfact_get()  

    RNA.md_defaults_sfact()  

    Attributes
    ----------
    temperature : double  
        The temperature used to scale the thermodynamic parameters.  

    betaScale : double  
        A scaling factor for the thermodynamic temperature of the Boltzmann factors.  

    pf_smooth : int  
        A flat specifying whether energies in Boltzmann factors need to be smoothed.  

    dangles : int  
        Specifies the dangle model used in any energy evaluation (0,1,2 or 3)  

        If set to 0 no stabilizing energies are assigned to bases adjacent to helices in free ends and
        multiloops (so called dangling ends). Normally (dangles = 1) dangling end energies are assigned
        only to unpaired bases and a base cannot participate simultaneously in two dangling ends. In the
        partition function algorithm RNA.fold_compound.pf() these checks are neglected. To provide comparability
        between free energy minimization and partition function algorithms, the default setting is 2.
        This treatment of dangling ends gives more favorable energies to helices directly adjacent to
        one another, which can be beneficial since such helices often do engage in stabilizing
        interactions through co-axial stacking.  
        If set to 3 co-axial stacking is explicitly included for adjacent helices in multiloops. The
        option affects only mfe folding and energy evaluation (RNA.mfe() and RNA.eval_structure()), as
        well as suboptimal folding (RNA.subopt()) via re-evaluation of energies. Co-axial stacking with
        one intervening mismatch is not considered so far. Note, that some function do not implement all
        dangle model but only a subset of (0,1,2,3). In particular, partition function algorithms can
        only handle 0 and 2. Read the documentation of the particular recurrences or energy evaluation
        function for information about the provided dangle model.  

    special_hp : int  
        Include special hairpin contributions for tri, tetra and hexaloops.  

    noLP : int  
        Only consider canonical structures, i.e. no 'lonely' base pairs.  

    noGU : int  
        Do not allow GU pairs.  

    noGUclosure : int  
        Do not allow loops to be closed by GU pair.  

    logML : int  
        Use logarithmic scaling for multiloops.  

    circ : int  
        Assume RNA to be circular instead of linear.  

    gquad : int  
        Include G-quadruplexes in structure prediction.  

    uniq_ML : int  
        Flag to ensure unique multi-branch loop decomposition during folding.  

    energy_set : int  
        Specifies the energy set that defines set of compatible base pairs.  

    backtrack : int  
        Specifies whether or not secondary structures should be backtraced.  

    backtrack_type : char  
        Specifies in which matrix to backtrack.  

    compute_bpp : int  
        Specifies whether or not backward recursions for base pair probability (bpp) computation will be
        performed.  

    nonstandards : char  
        contains allowed non standard bases  

    max_bp_span : int  
        maximum allowed base pair span  

    min_loop_size : int  
        Minimum size of hairpin loops.  

        The default value for this field is TURN, however, it may be 0 in cofolding context.  

    window_size : int  
        Size of the sliding window for locally optimal structure prediction.  

    oldAliEn : int  
        Use old alifold energy model.  

    ribo : int  
        Use ribosum scoring table in alifold energy model.  

    cv_fact : double  
        Co-variance scaling factor for consensus structure prediction.  

    nc_fact : double  
        Scaling factor to weight co-variance contributions of non-canonical pairs.  

    sfact : double  
        Scaling factor for partition function scaling.  

    rtype : int  
        Reverse base pair type array.  

    alias : short  
        alias of an integer nucleotide representation  

    pair : int  
        Integer representation of a base pair.  

    pair_dist : float  
        Base pair dissimilarity, a.k.a. distance matrix.  

    salt : double  
        Salt (monovalent) concentration (M) in buffer.  

    saltMLLower : int  
        Lower bound of multiloop size to use in loop salt correction linear fitting.  

    saltMLUpper : int  
        Upper bound of multiloop size to use in loop salt correction linear fitting.  

    saltDPXInit : int  
        User-provided salt correction for duplex initialization (in dcal/mol). If set to 99999 the
        default salt correction is used. If set to 0 there is no salt correction for duplex
        initialization.  

    saltDPXInitFact : float  


    helical_rise : float  


    backbone_length : float  


    C++ includes: ViennaRNA/model.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    temperature = property(_RNA.md_temperature_get, _RNA.md_temperature_set)
    betaScale = property(_RNA.md_betaScale_get, _RNA.md_betaScale_set)
    pf_smooth = property(_RNA.md_pf_smooth_get, _RNA.md_pf_smooth_set)
    dangles = property(_RNA.md_dangles_get, _RNA.md_dangles_set)
    special_hp = property(_RNA.md_special_hp_get, _RNA.md_special_hp_set)
    noLP = property(_RNA.md_noLP_get, _RNA.md_noLP_set)
    noGU = property(_RNA.md_noGU_get, _RNA.md_noGU_set)
    noGUclosure = property(_RNA.md_noGUclosure_get, _RNA.md_noGUclosure_set)
    logML = property(_RNA.md_logML_get, _RNA.md_logML_set)
    circ = property(_RNA.md_circ_get, _RNA.md_circ_set)
    gquad = property(_RNA.md_gquad_get, _RNA.md_gquad_set)
    uniq_ML = property(_RNA.md_uniq_ML_get, _RNA.md_uniq_ML_set)
    energy_set = property(_RNA.md_energy_set_get, _RNA.md_energy_set_set)
    backtrack = property(_RNA.md_backtrack_get, _RNA.md_backtrack_set)
    backtrack_type = property(_RNA.md_backtrack_type_get, _RNA.md_backtrack_type_set)
    compute_bpp = property(_RNA.md_compute_bpp_get, _RNA.md_compute_bpp_set)
    nonstandards = property(_RNA.md_nonstandards_get, _RNA.md_nonstandards_set)
    max_bp_span = property(_RNA.md_max_bp_span_get, _RNA.md_max_bp_span_set)
    min_loop_size = property(_RNA.md_min_loop_size_get, _RNA.md_min_loop_size_set)
    window_size = property(_RNA.md_window_size_get, _RNA.md_window_size_set)
    oldAliEn = property(_RNA.md_oldAliEn_get, _RNA.md_oldAliEn_set)
    ribo = property(_RNA.md_ribo_get, _RNA.md_ribo_set)
    cv_fact = property(_RNA.md_cv_fact_get, _RNA.md_cv_fact_set)
    nc_fact = property(_RNA.md_nc_fact_get, _RNA.md_nc_fact_set)
    sfact = property(_RNA.md_sfact_get, _RNA.md_sfact_set)
    rtype = property(_RNA.md_rtype_get)
    alias = property(_RNA.md_alias_get)
    pair = property(_RNA.md_pair_get)
    salt = property(_RNA.md_salt_get, _RNA.md_salt_set)
    saltMLLower = property(_RNA.md_saltMLLower_get, _RNA.md_saltMLLower_set)
    saltMLUpper = property(_RNA.md_saltMLUpper_get, _RNA.md_saltMLUpper_set)
    saltDPXInit = property(_RNA.md_saltDPXInit_get, _RNA.md_saltDPXInit_set)
    saltDPXInitFact = property(_RNA.md_saltDPXInitFact_get, _RNA.md_saltDPXInitFact_set)
    helical_rise = property(_RNA.md_helical_rise_get, _RNA.md_helical_rise_set)
    backbone_length = property(_RNA.md_backbone_length_get, _RNA.md_backbone_length_set)

    def __init__(self, *args, **kwargs):
        r"""


        The data structure that contains the complete model details used throughout the calculations.  

        For convenience reasons, we provide the type name RNA.md() to address this data structure without
        the use of the struct keyword  

        See Also
        --------
        RNA.md.reset(), set_model_details(), RNA.md_update(), RNA.md()  

        **SWIG Wrapper Notes**
            This data structure is wrapped as an object `md` with multiple related functions attached as
            methods.  

            A new set of default parameters can be obtained by calling the constructure of `md:`  

            *   `md()`-- Initialize with default settings  

            The resulting object has a list of attached methods which directly correspond to functions that
            mainly operate on the corresponding *C* data structure:  

            *   `reset()` - RNA.md.reset()  
            *   `set_from_globals()` - set_model_details()  
            *   `option_string()` - RNA.md.option_string()  

            Note, that default parameters can be modified by directly setting any of the following global
            variables. Internally, getting/setting default parameters using their global variable
            representative translates into calls of the following functions, therefore these wrappers for
            these functions do not exist in the scripting language interface(s):  


        global variable  

        `C getter`  

        `C setter`  

        temperature  

        RNA.md_defaults_temperature_get()  

        RNA.md_defaults_temperature()  

        dangles  

        RNA.md_defaults_dangles_get()  

        RNA.md_defaults_dangles()  

        betaScale  

        RNA.md_defaults_betaScale_get()  

        RNA.md_defaults_betaScale()  

        tetra_loop  

        this is an alias of *special_hp*  


        special_hp  

        RNA.md_defaults_special_hp_get()  

        RNA.md_defaults_special_hp()  

        noLonelyPairs  

        this is an alias of *noLP*  


        noLP  

        RNA.md_defaults_noLP_get()  

        RNA.md_defaults_noLP()  

        noGU  

        RNA.md_defaults_noGU_get()  

        RNA.md_defaults_noGU()  

        no_closingGU  

        this is an alias of *noGUclosure*  


        noGUclosure  

        RNA.md_defaults_noGUclosure_get()  

        RNA.md_defaults_noGUclosure()  

        logML  

        RNA.md_defaults_logML_get()  

        RNA.md_defaults_logML()  

        circ  

        RNA.md_defaults_circ_get()  

        RNA.md_defaults_circ()  

        gquad  

        RNA.md_defaults_gquad_get()  

        RNA.md_defaults_gquad()  

        uniq_ML  

        RNA.md_defaults_uniq_ML_get()  

        RNA.md_defaults_uniq_ML()  

        energy_set  

        RNA.md_defaults_energy_set_get()  

        RNA.md_defaults_energy_set()  

        backtrack  

        RNA.md_defaults_backtrack_get()  

        RNA.md_defaults_backtrack()  

        backtrack_type  

        RNA.md_defaults_backtrack_type_get()  

        RNA.md_defaults_backtrack_type()  

        do_backtrack  

        this is an alias of *compute_bpp*  


        compute_bpp  

        RNA.md_defaults_compute_bpp_get()  

        RNA.md_defaults_compute_bpp()  

        max_bp_span  

        RNA.md_defaults_max_bp_span_get()  

        RNA.md_defaults_max_bp_span()  

        min_loop_size  

        RNA.md_defaults_min_loop_size_get()  

        RNA.md_defaults_min_loop_size()  

        window_size  

        RNA.md_defaults_window_size_get()  

        RNA.md_defaults_window_size()  

        oldAliEn  

        RNA.md_defaults_oldAliEn_get()  

        RNA.md_defaults_oldAliEn()  

        ribo  

        RNA.md_defaults_ribo_get()  

        RNA.md_defaults_ribo()  

        cv_fact  

        RNA.md_defaults_cv_fact_get()  

        RNA.md_defaults_cv_fact()  

        nc_fact  

        RNA.md_defaults_nc_fact_get()  

        RNA.md_defaults_nc_fact()  

        sfact  

        RNA.md_defaults_sfact_get()  

        RNA.md_defaults_sfact()  

        Attributes
        ----------
        temperature : double  
            The temperature used to scale the thermodynamic parameters.  

        betaScale : double  
            A scaling factor for the thermodynamic temperature of the Boltzmann factors.  

        pf_smooth : int  
            A flat specifying whether energies in Boltzmann factors need to be smoothed.  

        dangles : int  
            Specifies the dangle model used in any energy evaluation (0,1,2 or 3)  

            If set to 0 no stabilizing energies are assigned to bases adjacent to helices in free ends and
            multiloops (so called dangling ends). Normally (dangles = 1) dangling end energies are assigned
            only to unpaired bases and a base cannot participate simultaneously in two dangling ends. In the
            partition function algorithm RNA.fold_compound.pf() these checks are neglected. To provide comparability
            between free energy minimization and partition function algorithms, the default setting is 2.
            This treatment of dangling ends gives more favorable energies to helices directly adjacent to
            one another, which can be beneficial since such helices often do engage in stabilizing
            interactions through co-axial stacking.  
            If set to 3 co-axial stacking is explicitly included for adjacent helices in multiloops. The
            option affects only mfe folding and energy evaluation (RNA.mfe() and RNA.eval_structure()), as
            well as suboptimal folding (RNA.subopt()) via re-evaluation of energies. Co-axial stacking with
            one intervening mismatch is not considered so far. Note, that some function do not implement all
            dangle model but only a subset of (0,1,2,3). In particular, partition function algorithms can
            only handle 0 and 2. Read the documentation of the particular recurrences or energy evaluation
            function for information about the provided dangle model.  

        special_hp : int  
            Include special hairpin contributions for tri, tetra and hexaloops.  

        noLP : int  
            Only consider canonical structures, i.e. no 'lonely' base pairs.  

        noGU : int  
            Do not allow GU pairs.  

        noGUclosure : int  
            Do not allow loops to be closed by GU pair.  

        logML : int  
            Use logarithmic scaling for multiloops.  

        circ : int  
            Assume RNA to be circular instead of linear.  

        gquad : int  
            Include G-quadruplexes in structure prediction.  

        uniq_ML : int  
            Flag to ensure unique multi-branch loop decomposition during folding.  

        energy_set : int  
            Specifies the energy set that defines set of compatible base pairs.  

        backtrack : int  
            Specifies whether or not secondary structures should be backtraced.  

        backtrack_type : char  
            Specifies in which matrix to backtrack.  

        compute_bpp : int  
            Specifies whether or not backward recursions for base pair probability (bpp) computation will be
            performed.  

        nonstandards : char  
            contains allowed non standard bases  

        max_bp_span : int  
            maximum allowed base pair span  

        min_loop_size : int  
            Minimum size of hairpin loops.  

            The default value for this field is TURN, however, it may be 0 in cofolding context.  

        window_size : int  
            Size of the sliding window for locally optimal structure prediction.  

        oldAliEn : int  
            Use old alifold energy model.  

        ribo : int  
            Use ribosum scoring table in alifold energy model.  

        cv_fact : double  
            Co-variance scaling factor for consensus structure prediction.  

        nc_fact : double  
            Scaling factor to weight co-variance contributions of non-canonical pairs.  

        sfact : double  
            Scaling factor for partition function scaling.  

        rtype : int  
            Reverse base pair type array.  

        alias : short  
            alias of an integer nucleotide representation  

        pair : int  
            Integer representation of a base pair.  

        pair_dist : float  
            Base pair dissimilarity, a.k.a. distance matrix.  

        salt : double  
            Salt (monovalent) concentration (M) in buffer.  

        saltMLLower : int  
            Lower bound of multiloop size to use in loop salt correction linear fitting.  

        saltMLUpper : int  
            Upper bound of multiloop size to use in loop salt correction linear fitting.  

        saltDPXInit : int  
            User-provided salt correction for duplex initialization (in dcal/mol). If set to 99999 the
            default salt correction is used. If set to 0 there is no salt correction for duplex
            initialization.  

        saltDPXInitFact : float  


        helical_rise : float  


        backbone_length : float  


        C++ includes: ViennaRNA/model.h

        """
        _RNA.md_swiginit(self, _RNA.new_md(*args, **kwargs))
    __swig_destroy__ = _RNA.delete_md

    def reset(self):
        r"""


        Apply default model details to a provided RNA.md() data structure.  

        Use this function to initialize a RNA.md() data structure with its default values  

        Parameters
        ----------  

        """
        return _RNA.md_reset(self)

    def set_from_globals(self):
        return _RNA.md_set_from_globals(self)

    def option_string(self):
        r"""


        Get a corresponding commandline parameter string of the options in a RNA.md().  

        Note
        ----
        This function is not threadsafe!  

        """
        return _RNA.md_option_string(self)

    def __str__(self):
        return _RNA.md___str__(self)

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 


# Register md in _RNA:
_RNA.md_swigregister(md)
cvar = _RNA.cvar
lxc37 = cvar.lxc37
stack37 = cvar.stack37
stackdH = cvar.stackdH
hairpin37 = cvar.hairpin37
hairpindH = cvar.hairpindH
bulge37 = cvar.bulge37
bulgedH = cvar.bulgedH
internal_loop37 = cvar.internal_loop37
internal_loopdH = cvar.internal_loopdH
mismatchI37 = cvar.mismatchI37
mismatchIdH = cvar.mismatchIdH
mismatch1nI37 = cvar.mismatch1nI37
mismatch23I37 = cvar.mismatch23I37
mismatch1nIdH = cvar.mismatch1nIdH
mismatch23IdH = cvar.mismatch23IdH
mismatchH37 = cvar.mismatchH37
mismatchM37 = cvar.mismatchM37
mismatchHdH = cvar.mismatchHdH
mismatchMdH = cvar.mismatchMdH
mismatchExt37 = cvar.mismatchExt37
mismatchExtdH = cvar.mismatchExtdH
dangle5_37 = cvar.dangle5_37
dangle3_37 = cvar.dangle3_37
dangle3_dH = cvar.dangle3_dH
dangle5_dH = cvar.dangle5_dH
int11_37 = cvar.int11_37
int11_dH = cvar.int11_dH
int21_37 = cvar.int21_37
int21_dH = cvar.int21_dH
int22_37 = cvar.int22_37
int22_dH = cvar.int22_dH
ML_BASE37 = cvar.ML_BASE37
ML_BASEdH = cvar.ML_BASEdH
ML_closing37 = cvar.ML_closing37
ML_closingdH = cvar.ML_closingdH
ML_intern37 = cvar.ML_intern37
ML_interndH = cvar.ML_interndH
TripleC37 = cvar.TripleC37
TripleCdH = cvar.TripleCdH
MultipleCA37 = cvar.MultipleCA37
MultipleCAdH = cvar.MultipleCAdH
MultipleCB37 = cvar.MultipleCB37
MultipleCBdH = cvar.MultipleCBdH
MAX_NINIO = cvar.MAX_NINIO
ninio37 = cvar.ninio37
niniodH = cvar.niniodH
TerminalAU37 = cvar.TerminalAU37
TerminalAUdH = cvar.TerminalAUdH
DuplexInit37 = cvar.DuplexInit37
DuplexInitdH = cvar.DuplexInitdH
Tetraloops = cvar.Tetraloops
Tetraloop37 = cvar.Tetraloop37
TetraloopdH = cvar.TetraloopdH
Triloops = cvar.Triloops
Triloop37 = cvar.Triloop37
TriloopdH = cvar.TriloopdH
Hexaloops = cvar.Hexaloops
Hexaloop37 = cvar.Hexaloop37
HexaloopdH = cvar.HexaloopdH
GQuadAlpha37 = cvar.GQuadAlpha37
GQuadAlphadH = cvar.GQuadAlphadH
GQuadBeta37 = cvar.GQuadBeta37
GQuadBetadH = cvar.GQuadBetadH
GQuadLayerMismatch37 = cvar.GQuadLayerMismatch37
GQuadLayerMismatchH = cvar.GQuadLayerMismatchH
GQuadLayerMismatchMax = cvar.GQuadLayerMismatchMax
Tmeasure = cvar.Tmeasure

MODEL_DEFAULT_TEMPERATURE = _RNA.MODEL_DEFAULT_TEMPERATURE
r"""


     Default temperature for structure prediction and free energy evaluation in &#176C  Default
    temperature for structure prediction and free energy evaluation in $^\circ C$  

    See Also
    --------
    RNA.md().temperature, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_PF_SCALE = _RNA.MODEL_DEFAULT_PF_SCALE
r"""


    Default scaling factor for partition function computations.  

    See Also
    --------
    RNA.exp_param().pf_scale, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_BETA_SCALE = _RNA.MODEL_DEFAULT_BETA_SCALE
r"""


    Default scaling factor for absolute thermodynamic temperature in Boltzmann factors.  

    See Also
    --------
    RNA.exp_param().alpha, RNA.md().betaScale, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_DANGLES = _RNA.MODEL_DEFAULT_DANGLES
r"""


    Default dangling end model.  

    See Also
    --------
    RNA.md().dangles, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_SPECIAL_HP = _RNA.MODEL_DEFAULT_SPECIAL_HP
r"""


    Default model behavior for lookup of special tri-, tetra-, and hexa-loops.  

    See Also
    --------
    RNA.md().special_hp, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_NO_LP = _RNA.MODEL_DEFAULT_NO_LP
r"""


    Default model behavior for so-called 'lonely pairs'.  

    See Also
    --------
    RNA.md().noLP, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_NO_GU = _RNA.MODEL_DEFAULT_NO_GU
r"""


    Default model behavior for G-U base pairs.  

    See Also
    --------
    RNA.md().noGU, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_NO_GU_CLOSURE = _RNA.MODEL_DEFAULT_NO_GU_CLOSURE
r"""


    Default model behavior for G-U base pairs closing a loop.  

    See Also
    --------
    RNA.md().noGUclosure, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_CIRC = _RNA.MODEL_DEFAULT_CIRC
r"""


    Default model behavior to treat a molecule as a circular RNA (DNA)  

    See Also
    --------
    RNA.md().circ, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_GQUAD = _RNA.MODEL_DEFAULT_GQUAD
r"""


    Default model behavior regarding the treatment of G-Quadruplexes.  

    See Also
    --------
    RNA.md().gquad, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_UNIQ_ML = _RNA.MODEL_DEFAULT_UNIQ_ML
r"""


    Default behavior of the model regarding unique multi-branch loop decomposition.  

    See Also
    --------
    RNA.md().uniq_ML, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_ENERGY_SET = _RNA.MODEL_DEFAULT_ENERGY_SET
r"""


    Default model behavior on which energy set to use.  

    See Also
    --------
    RNA.md().energy_set, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_BACKTRACK = _RNA.MODEL_DEFAULT_BACKTRACK
r"""


    Default model behavior with regards to backtracking of structures.  

    See Also
    --------
    RNA.md().backtrack, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_BACKTRACK_TYPE = _RNA.MODEL_DEFAULT_BACKTRACK_TYPE
r"""


    Default model behavior on what type of backtracking to perform.  

    See Also
    --------
    RNA.md().backtrack_type, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_COMPUTE_BPP = _RNA.MODEL_DEFAULT_COMPUTE_BPP
r"""


    Default model behavior with regards to computing base pair probabilities.  

    See Also
    --------
    RNA.md().compute_bpp, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_MAX_BP_SPAN = _RNA.MODEL_DEFAULT_MAX_BP_SPAN
r"""


    Default model behavior for the allowed maximum base pair span.  

    See Also
    --------
    RNA.md().max_bp_span, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_WINDOW_SIZE = _RNA.MODEL_DEFAULT_WINDOW_SIZE
r"""


    Default model behavior for the sliding window approach.  

    See Also
    --------
    RNA.md().window_size, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_LOG_ML = _RNA.MODEL_DEFAULT_LOG_ML
r"""


    Default model behavior on how to evaluate the energy contribution of multi-branch loops.  

    See Also
    --------
    RNA.md().logML, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_ALI_OLD_EN = _RNA.MODEL_DEFAULT_ALI_OLD_EN
r"""


    Default model behavior for consensus structure energy evaluation.  

    See Also
    --------
    RNA.md().oldAliEn, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_ALI_RIBO = _RNA.MODEL_DEFAULT_ALI_RIBO
r"""


    Default model behavior for consensus structure co-variance contribution assessment.  

    See Also
    --------
    RNA.md().ribo, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_ALI_CV_FACT = _RNA.MODEL_DEFAULT_ALI_CV_FACT
r"""


    Default model behavior for weighting the co-variance score in consensus structure prediction.  

    See Also
    --------
    RNA.md().cv_fact, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_ALI_NC_FACT = _RNA.MODEL_DEFAULT_ALI_NC_FACT
r"""


    Default model behavior for weighting the nucleotide conservation? in consensus structure prediction.  

    See Also
    --------
    RNA.md().nc_fact, RNA.md_defaults_reset(), RNA.md.reset()  

    """
MODEL_DEFAULT_PF_SMOOTH = _RNA.MODEL_DEFAULT_PF_SMOOTH
r"""


    """
MODEL_DEFAULT_SALT = _RNA.MODEL_DEFAULT_SALT
r"""


    Default model salt concentration (M)  

    """
MODEL_DEFAULT_SALT_MLLOWER = _RNA.MODEL_DEFAULT_SALT_MLLOWER
r"""


    Default model lower bound of multiloop size for salt correction fiting.  

    """
MODEL_DEFAULT_SALT_MLUPPER = _RNA.MODEL_DEFAULT_SALT_MLUPPER
r"""


    Default model upper bound of multiloop size for salt correction fiting.  

    """
MODEL_DEFAULT_SALT_DPXINIT = _RNA.MODEL_DEFAULT_SALT_DPXINIT
r"""


    Default model value to turn off user-provided salt correction for duplex initializtion.  

    """
MODEL_DEFAULT_SALT_DPXINIT_FACT = _RNA.MODEL_DEFAULT_SALT_DPXINIT_FACT
r"""


    """
MODEL_DEFAULT_HELICAL_RISE = _RNA.MODEL_DEFAULT_HELICAL_RISE
r"""


    Default helical rise.  

    """
MODEL_DEFAULT_BACKBONE_LENGTH = _RNA.MODEL_DEFAULT_BACKBONE_LENGTH
r"""


    Default backbone length.  

    """
MODEL_SALT_DPXINIT_FACT_RNA = _RNA.MODEL_SALT_DPXINIT_FACT_RNA
r"""


    """
MODEL_SALT_DPXINIT_FACT_DNA = _RNA.MODEL_SALT_DPXINIT_FACT_DNA
r"""


    """
MODEL_HELICAL_RISE_RNA = _RNA.MODEL_HELICAL_RISE_RNA
r"""


    """
MODEL_HELICAL_RISE_DNA = _RNA.MODEL_HELICAL_RISE_DNA
r"""


    """
MODEL_BACKBONE_LENGTH_RNA = _RNA.MODEL_BACKBONE_LENGTH_RNA
r"""


    """
MODEL_BACKBONE_LENGTH_DNA = _RNA.MODEL_BACKBONE_LENGTH_DNA
r"""


    """
NBASES = _RNA.NBASES
r"""


    """
MAXALPHA = _RNA.MAXALPHA
r"""


    Maximal length of alphabet.  

    """

def init_rand(*args):
    r"""


    Initialize the random number generator with a pre-defined seed.  

    **SWIG Wrapper Notes**
        This function is available as an overloaded function **init_rand()** where the argument `seed`
        is optional. See, e.g.  :py:func:`RNA.init_rand()` in the :doc:`/api_python`.  

    Parameters
    ----------
    seed : unsigned int
        The seed for the random number generator  

    See Also
    --------
    RNA.init_rand(), RNA.urn()  

    """
    return _RNA.init_rand(*args)

def urn():
    r"""


    get a random number from [0..1]  

    Returns
    -------
    double  
        A random number in range [0..1]  

    See Also
    --------
    RNA.int_urn(), RNA.init_rand(), RNA.init_rand_seed()  

    Note
    ----
    Usually implemented by calling *erand48()*.  

    """
    return _RNA.urn()

def int_urn(_from, to):
    r"""


    Generates a pseudo random integer in a specified range.  

    Parameters
    ----------
    from : int
        The first number in range  
    to : int
        The last number in range  

    Returns
    -------
    int  
        A pseudo random number in range [from, to]  

    See Also
    --------
    RNA.urn(), RNA.init_rand()  

    """
    return _RNA.int_urn(_from, to)

def hamming(s1, s2):
    r"""


    Calculate hamming distance between two sequences.  

    Parameters
    ----------
    s1 : const char *
        The first sequence  
    s2 : const char *
        The second sequence  

    Returns
    -------
    int  
        The hamming distance between s1 and s2  

    """
    return _RNA.hamming(s1, s2)

def hamming_bound(s1, s2, n):
    r"""


    Calculate hamming distance between two sequences up to a specified length.  

    This function is similar to RNA.hamming_distance() but instead of comparing both sequences up to
    their actual length only the first 'n' characters are taken into account  

    Parameters
    ----------
    s1 : const char *
        The first sequence  
    s2 : const char *
        The second sequence  
    n : int
        The length of the subsequences to consider (starting from the 5' end)  

    Returns
    -------
    int  
        The hamming distance between s1 and s2  

    """
    return _RNA.hamming_bound(s1, s2, n)

def encode_seq(sequence):
    return _RNA.encode_seq(sequence)

def strtrim(*args, **kwargs):
    r"""
    strtrim(char * seq_mutable, char const * delimiters=None, unsigned int keep=0, unsigned int options=) -> unsigned int


    Trim a string by removing (multiple) occurences of a particular character.  

    This function removes (multiple) consecutive occurences of a set of characters (`delimiters`) within
    an input string. It may be used to remove leading and/or trailing whitespaces or to restrict the
    maximum number of consecutive occurences of the delimiting characters `delimiters`. Setting `keep=0`
    removes all occurences, while other values reduce multiple consecutive occurences to at most `keep`
    delimiters. This might be useful if one would like to reduce multiple whitespaces to a single one,
    or to remove empty fields within a comma-separated value string.  

    The parameter `delimiters` may be a pointer to a 0-terminated char string containing a set of any
    ASCII character. If *NULL* is passed as delimiter set or an empty char string, all whitespace
    characters are trimmed. The `options` parameter is a bit vector that specifies which part of the
    string should undergo trimming. The implementation distinguishes the leading (RNA.TRIM_LEADING),
    trailing (RNA.TRIM_TRAILING), and in-between (RNA.TRIM_IN_BETWEEN) part with respect to the
    delimiter set. Combinations of these parts can be specified by using logical-or operator.  

    The following example code removes all leading and trailing whitespace characters from the input
    string:  

    **SWIG Wrapper Notes**
        Since many scripting languages treat strings as immutable objects, this function does not modify
        the input string directly. Instead, it returns the modified string as second return value,
        together with the number of removed delimiters.  

        The scripting language interface provides an overloaded version of this function, with default
        parameters `delimiters=NULL`, `keep=0`, and `options=RNA.TRIM_DEFAULT`. See, e.g.
        :py:func:`RNA.strtrim()` in the :doc:`/api_python`.  

    Parameters
    ----------
    string : char *
        The '\0'-terminated input string to trim  
    delimiters : const char *
        The delimiter characters as 0-terminated char array (or *NULL*)  
    keep : unsigned int
        The maximum number of consecutive occurences of the delimiter in the output string  
    options : unsigned int
        The option bit vector specifying the mode of operation  

    Returns
    -------
    unsigned int  
        The number of delimiters removed from the string  

    See Also
    --------
    RNA.TRIM_LEADING, RNA.TRIM_TRAILING, RNA.TRIM_IN_BETWEEN, RNA.TRIM_SUBST_BY_FIRST,
    RNA.TRIM_DEFAULT, RNA.TRIM_ALL  

    Note
    ----
    The delimiter always consists of a single character from the set of characters provided. In case of
    alternative delimiters and non-null `keep` parameter, the first `keep` delimiters are preserved
    within the string. Use RNA.TRIM_SUBST_BY_FIRST to substitute all remaining delimiting characters
    with the first from the `delimiters` list.  

    """
    return _RNA.strtrim(*args, **kwargs)
TRIM_LEADING = _RNA.TRIM_LEADING
r"""


    Trim only characters leading the string.  

    See Also
    --------
    RNA.strtrim()  

    """
TRIM_TRAILING = _RNA.TRIM_TRAILING
r"""


    Trim only characters trailing the string.  

    See Also
    --------
    RNA.strtrim()  

    """
TRIM_IN_BETWEEN = _RNA.TRIM_IN_BETWEEN
r"""


    Trim only characters within the string.  

    See Also
    --------
    RNA.strtrim()  

    """
TRIM_DEFAULT = _RNA.TRIM_DEFAULT
r"""


    Default settings for trimming, i.e. trim leading and trailing.  

    See Also
    --------
    RNA.strtrim()  

    """
TRIM_ALL = _RNA.TRIM_ALL
r"""


    Trim characters anywhere in the string.  

    See Also
    --------
    RNA.strtrim()  

    """
FILENAME_MAX_LENGTH = _RNA.FILENAME_MAX_LENGTH
r"""


    Maximum length of filenames that are generated by our programs.  

    This definition should be used throughout the complete ViennaRNA package wherever a static array
    holding filenames of output files is declared.  

    """
FILENAME_ID_LENGTH = _RNA.FILENAME_ID_LENGTH
r"""


    Maximum length of id taken from fasta header for filename generation.  

    this has to be smaller than FILENAME_MAX_LENGTH since in most cases, some suffix will be appended to
    the ID  

    """

def random_string(l, symbols):
    r"""


    Create a random string using characters from a specified symbol set.  

    Parameters
    ----------
    l : int
        The length of the sequence  
    symbols : const char
        The symbol set  

    Returns
    -------
    char *  
        A random string of length 'l' containing characters from the symbolset  

    """
    return _RNA.random_string(l, symbols)

def hamming_distance(s1, s2):
    return _RNA.hamming_distance(s1, s2)

def hamming_distance_bound(s1, s2, n):
    return _RNA.hamming_distance_bound(s1, s2, n)
class ep(object):
    r"""


    Data structure representing a single entry of an element probability list (e.g. list of pair
    probabilities)  

    See Also
    --------
    RNA.plist(), RNA.fold_compound.plist_from_probs(), RNA.db_from_plist(),  
    RNA.PLIST_TYPE_BASEPAIR, RNA.PLIST_TYPE_GQUAD, RNA.PLIST_TYPE_H_MOTIF, RNA.PLIST_TYPE_I_MOTIF,
    RNA.PLIST_TYPE_UD_MOTIF, RNA.PLIST_TYPE_STACK  

    Attributes
    ----------
    i : int  
        Start position (usually 5' nucleotide that starts the element, e.g. base pair)  

    j : int  
        End position (usually 3' nucleotide that ends the element, e.g. base pair)  

    p : float  
        Probability of the element.  

    type : int  
        Type of the element.  

    C++ includes: ViennaRNA/utils/structures.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    i = property(_RNA.ep_i_get, _RNA.ep_i_set)
    j = property(_RNA.ep_j_get, _RNA.ep_j_set)
    p = property(_RNA.ep_p_get, _RNA.ep_p_set)
    type = property(_RNA.ep_type_get, _RNA.ep_type_set)

    def __init__(self, *args, **kwargs):
        r"""


        Data structure representing a single entry of an element probability list (e.g. list of pair
        probabilities)  

        See Also
        --------
        RNA.plist(), RNA.fold_compound.plist_from_probs(), RNA.db_from_plist(),  
        RNA.PLIST_TYPE_BASEPAIR, RNA.PLIST_TYPE_GQUAD, RNA.PLIST_TYPE_H_MOTIF, RNA.PLIST_TYPE_I_MOTIF,
        RNA.PLIST_TYPE_UD_MOTIF, RNA.PLIST_TYPE_STACK  

        Attributes
        ----------
        i : int  
            Start position (usually 5' nucleotide that starts the element, e.g. base pair)  

        j : int  
            End position (usually 3' nucleotide that ends the element, e.g. base pair)  

        p : float  
            Probability of the element.  

        type : int  
            Type of the element.  

        C++ includes: ViennaRNA/utils/structures.h

        """
        _RNA.ep_swiginit(self, _RNA.new_ep(*args, **kwargs))

    def __str__(self):
        return _RNA.ep___str__(self)

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 

    __swig_destroy__ = _RNA.delete_ep

# Register ep in _RNA:
_RNA.ep_swigregister(ep)


def pack_structure(s):
    r"""pack_structure(char const * s) -> char *"""
    return _RNA.pack_structure(s)

def unpack_structure(packed):
    r"""unpack_structure(char const * packed) -> char *"""
    return _RNA.unpack_structure(packed)

def db_from_ptable(*args):
    r"""
    db_from_ptable(IntVector pt) -> char
    db_from_ptable(varArrayShort pt) -> char *


    Convert a pair table into dot-parenthesis notation.  

    This function also converts pair table formatted structures that contain pseudoknots. Non-nested
    base pairs result in additional pairs of parenthesis and brackets within the resulting dot-
    parenthesis string. The following pairs are awailable: (), []. {}. <>, as well as pairs of matching
    upper-/lower-case characters from the alphabet A-Z.  

    Parameters
    ----------
    pt : const short *
        The pair table to be copied  

    Returns
    -------
    char *  
        A char pointer to the dot-bracket string  

    Note
    ----
    In cases where the level of non-nested base pairs exceeds the maximum number of 30 different base
    pair indicators (4 parenthesis/brackets, 26 matching characters), a warning is printed and the
    remaining base pairs are left out from the conversion.  

    """
    return _RNA.db_from_ptable(*args)

def db_flatten(*args):
    r"""


    Substitute pairs of brackets in a string with parenthesis.  

    This function can be used to replace brackets of unusual types, such as angular brackets `<>` , to
    dot-bracket format. The `options` parameter is used tpo specify which types of brackets will be
    replaced by round parenthesis ``() .  

    **SWIG Wrapper Notes**
        This function flattens an input structure string in-place! The second parameter is optional and
        defaults to RNA.BRACKETS_DEFAULT.  

        An overloaded version of this function exists, where an additional second parameter can be
        passed to specify the target brackets, i.e. the type of matching pair characters all brackets
        will be flattened to. Therefore, in the scripting language interface this function is a
        replacement for RNA.db_flatten_to(). See, e.g.  :py:func:`RNA.db_flatten()` in the
        :doc:`/api_python`.  

    Parameters
    ----------
    structure : char *
        The structure string where brackets are flattened in-place  
    options : unsigned int
        A bitmask to specify which types of brackets should be flattened out  

    See Also
    --------
    RNA.db_flatten_to(), RNA.BRACKETS_RND, RNA.BRACKETS_ANG, RNA.BRACKETS_CLY, RNA.BRACKETS_SQR,
    RNA.BRACKETS_DEFAULT  

    """
    return _RNA.db_flatten(*args)

def db_from_WUSS(wuss):
    r"""


    Convert a WUSS annotation string to dot-bracket format.  

    Parameters
    ----------
    wuss : const char *
        The input string in WUSS notation  

    Returns
    -------
    char *  
        A dot-bracket notation of the input secondary structure  

    Note
    ----
    This function flattens all brackets, and treats pseudo-knots annotated by matching pairs of
    upper/lowercase letters as unpaired nucleotides  

    """
    return _RNA.db_from_WUSS(wuss)

def abstract_shapes(*args):
    r"""
    abstract_shapes(std::string structure, unsigned int level=5) -> std::string
    abstract_shapes(IntVector pt, unsigned int level=5) -> std::string
    abstract_shapes(varArrayShort pt, unsigned int level=5) -> std::string


    Convert a secondary structure in dot-bracket notation to its abstract shapes representation.  

    This function converts a secondary structure into its abstract shapes representation as presented by
    :cite:t:`giegerich:2004` .  

    **SWIG Wrapper Notes**
        This function is available as an overloaded function `abstract_shapes()` where the optional
        second parameter `level` defaults to 5. See, e.g.  :py:func:`RNA.abstract_shapes()` in the
        :doc:`/api_python`.  

    Parameters
    ----------
    structure : const char *
        A secondary structure in dot-bracket notation  
    level : unsigned int
        The abstraction level (integer in the range of 0 to 5)  

    Returns
    -------
    char *  
        The secondary structure in abstract shapes notation  

    See Also
    --------
    RNA.abstract_shapes_pt()  

    """
    return _RNA.abstract_shapes(*args)

def ptable(*args, **kwargs):
    r"""
    ptable(std::string str, unsigned int options=) -> varArrayShort


    Create a pair table for a secondary structure string.  

    This function takes an input string of a secondary structure annotation in dot-bracket-notation or
    dot-bracket-ext-notation, and converts it into a pair table representation.  

    **SWIG Wrapper Notes**
        This functions is wrapped as overloaded function `ptable()` that takes an optional argument
        `options` to specify which type of matching brackets should be considered during conversion. The
        default set is round brackets, i.e. RNA.BRACKETS_RND. See, e.g.  :py:func:`RNA.ptable()` in the
        :doc:`/api_python`.  

    Parameters
    ----------
    structure : const char *
        Secondary structure in dot-bracket-ext-notation  
    options : unsigned int
        A bitmask to specify which brackets are recognized during conversion to pair table  

    Returns
    -------
    short *  
        A pointer to a new pair table of the provided secondary structure  

    See Also
    --------
    RNA.ptable(), RNA.db_from_ptable(), RNA.db_flatten_to(), RNA.pt_pk_remove()RNA.BRACKETS_RND,
    RNA.BRACKETS_ANG, RNA.BRACKETS_CLY, RNA.BRACKETS_SQR, RNA.BRACKETS_ALPHA, RNA.BRACKETS_DEFAULT,
    RNA.BRACKETS_ANY  

    Note
    ----
    This function also extracts crossing base pairs, i.e. pseudo-knots if more than a single matching
    bracket type is allowed through the bitmask `options`.  

    """
    return _RNA.ptable(*args, **kwargs)

def ptable_pk(str):
    r"""
    ptable_pk(std::string str) -> IntVector


    Create a pair table of a secondary structure (pseudo-knot version)  

    Returns a newly allocated table, such that table[i]=j if (i.j) pair or 0 if i is unpaired, table[0]
    contains the length of the structure.  

    In contrast to RNA.ptable() this function also recognizes the base pairs denoted by '[' and ']'
    brackets. Thus, this function behaves like  

    Parameters
    ----------
    structure : const char *
        The secondary structure in (extended) dot-bracket notation  

    Returns
    -------
    short *  
        A pointer to the created pair_table  

    See Also
    --------
    RNA.ptable_from_string()  

    """
    return _RNA.ptable_pk(str)

def pt_pk_remove(*args):
    r"""
    pt_pk_remove(IntVector pt, unsigned int options=0) -> IntVector
    pt_pk_remove(varArrayShort pt, unsigned int options=0) -> varArrayShort


    Remove pseudo-knots from a pair table.  

    This function removes pseudo-knots from an input structure by determining the minimum number of base
    pairs that need to be removed to make the structure pseudo-knot free.  

    To accomplish that, we use a dynamic programming algorithm similar to the Nussinov maxmimum matching
    approach.  

    Parameters
    ----------
    ptable : const short *
        Input structure that may include pseudo-knots  
    options : unsigned int

    Returns
    -------
    short *  
        The input structure devoid of pseudo-knots  

    See Also
    --------
    RNA.db_pk_remove()  

    """
    return _RNA.pt_pk_remove(*args)

def plist(structure, pr):
    r"""
    plist(std::string structure, float pr) -> ElemProbVector


    Create a RNA.ep() from a dot-bracket string.  

    The dot-bracket string is parsed and for each base pair an entry in the plist is created. The
    probability of each pair in the list is set by a function parameter.  

    The end of the plist is marked by sequence positions i as well as j equal to 0. This condition
    should be used to stop looping over its entries  

    Parameters
    ----------
    struc : const char *
        The secondary structure in dot-bracket notation  
    pr : float
        The probability for each base pair used in the plist  

    Returns
    -------
    RNA.ep() *  
        The plist array  

    """
    return _RNA.plist(structure, pr)

def db_from_plist(elem_probs, length):
    r"""
    db_from_plist(ElemProbVector elem_probs, unsigned int length) -> std::string


    Convert a list of base pairs into dot-bracket notation.  

    Parameters
    ----------
    pairs : RNA.ep() *
        A RNA.ep() containing the pairs to be included in the dot-bracket string  
    n : unsigned int
        The length of the structure (number of nucleotides)  

    Returns
    -------
    char *  
        The dot-bracket string containing the provided base pairs  

    See Also
    --------
    RNA.plist()  

    """
    return _RNA.db_from_plist(elem_probs, length)

def db_pk_remove(*args, **kwargs):
    r"""
    db_pk_remove(std::string structure, unsigned int options=) -> std::string


    Remove pseudo-knots from an input structure.  

    This function removes pseudo-knots from an input structure by determining the minimum number of base
    pairs that need to be removed to make the structure pseudo-knot free.  

    To accomplish that, we use a dynamic programming algorithm similar to the Nussinov maxmimum matching
    approach.  

    The input structure must be in a dot-bracket string like form where crossing base pairs are denoted
    by the use of additional types of matching brackets, e.g. `<>`, `{}`, ``[], `{}`. Furthermore,
    crossing pairs may be annotated by matching uppercase/lowercase letters from the alphabet `A-Z`. For
    the latter, the uppercase letter must be the 5' and the lowercase letter the 3' nucleotide of the
    base pair. The actual type of brackets to be recognized by this function must be specifed through
    the `options` parameter.  

    **SWIG Wrapper Notes**
        This function is available as an overloaded function `db_pk_remove()` where the optional second
        parameter `options` defaults to RNA.BRACKETS_ANY. See, e.g.  :py:func:`RNA.db_pk_remove()` in
        the :doc:`/api_python`.  

    Parameters
    ----------
    structure : const char *
        Input structure in dot-bracket format that may include pseudo-knots  
    options : unsigned int
        A bitmask to specify which types of brackets should be processed  

    Returns
    -------
    char *  
        The input structure devoid of pseudo-knots in dot-bracket notation  

    See Also
    --------
    RNA.pt_pk_remove(), RNA.db_flatten(), RNA.BRACKETS_RND, RNA.BRACKETS_ANG, RNA.BRACKETS_CLY,
    RNA.BRACKETS_SQR, RNA.BRACKETS_ALPHA, RNA.BRACKETS_DEFAULT, RNA.BRACKETS_ANY  

    Note
    ----
    Brackets in the input structure string that are not covered by the `options` bitmask will be
    silently ignored!  

    """
    return _RNA.db_pk_remove(*args, **kwargs)

def db_to_tree_string(structure, type):
    r"""
    db_to_tree_string(std::string structure, unsigned int type) -> std::string


    Convert a Dot-Bracket structure string into tree string representation.  

    This function allows one to convert a secondary structure in dot-bracket notation into one of the
    various tree representations for secondary structures. The resulting tree is then represented as a
    string of parenthesis and node symbols, similar to to the Newick format.  

    Currently we support conversion into the following formats, denoted by the value of parameter
    `type:`  

    *   RNA.STRUCTURE_TREE_HIT - Homeomorphically Irreducible Tree (HIT) representation of a secondary
        structure. (See also  :cite:t:`fontana:1993b` )  
    *   RNA.STRUCTURE_TREE_SHAPIRO_SHORT - (short) Coarse Grained representation of a secondary
        structure (same as  :cite:t:`shapiro:1988` , but with root node `R` and without `S` nodes for
        the stems)  
    *   RNA.STRUCTURE_TREE_SHAPIRO - (full) Coarse Grained representation of a secondary structure (See
        also  :cite:t:`shapiro:1988` )  
    *   RNA.STRUCTURE_TREE_SHAPIRO_EXT - (extended) Coarse Grained representation of a secondary
        structure (same as  :cite:t:`shapiro:1988` , but external nodes denoted as `E` )  
    *   RNA.STRUCTURE_TREE_SHAPIRO_WEIGHT - (weighted) Coarse Grained representation of a secondary
        structure (same as RNA.STRUCTURE_TREE_SHAPIRO_EXT but with additional weights for number of
        unpaired nucleotides in loop, and number of pairs in stems)  
    *   RNA.STRUCTURE_TREE_EXPANDED - Expanded Tree representation of a secondary structure.  

    Parameters
    ----------
    structure : const char *
        The null-terminated dot-bracket structure string  
    type : unsigned int
        A switch to determine the type of tree string representation  

    Returns
    -------
    char *  
        A tree representation of the input `structure`  

    See Also
    --------
    sec_structure_representations_tree  

    """
    return _RNA.db_to_tree_string(structure, type)

def tree_string_unweight(structure):
    r"""


    Remove weights from a linear string tree representation of a secondary structure.  

    This function strips the weights of a linear string tree representation such as `HIT`, or Coarse
    Grained Tree sensu  :cite:t:`shapiro:1988`  

    Parameters
    ----------
    structure : const char *
        A linear string tree representation of a secondary structure with weights  

    Returns
    -------
    char *  
        A linear string tree representation of a secondary structure without weights  

    See Also
    --------
    RNA.db_to_tree_string()  

    """
    return _RNA.tree_string_unweight(structure)

def tree_string_to_db(structure):
    r"""


    Convert a linear tree string representation of a secondary structure back to Dot-Bracket notation.  

    Parameters
    ----------
    tree : const char *
        A linear tree string representation of a secondary structure  

    Returns
    -------
    char *  
        A dot-bracket notation of the secondary structure provided in `tree`  

    Warnings
    --------
    This function only accepts *Expanded* and *HIT* tree representations!  

    See Also
    --------
    RNA.db_to_tree_string(), RNA.STRUCTURE_TREE_EXPANDED, RNA.STRUCTURE_TREE_HIT,
    sec_structure_representations_tree  

    """
    return _RNA.tree_string_to_db(structure)

def make_loop_index(structure):
    return _RNA.make_loop_index(structure)

def loopidx_from_ptable(*args):
    r"""
    loopidx_from_ptable(IntVector pt) -> IntVector
    loopidx_from_ptable(varArrayShort pt) -> varArrayInt


    Get a loop index representation of a structure.  

    """
    return _RNA.loopidx_from_ptable(*args)
class hx(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    start = property(_RNA.hx_start_get, _RNA.hx_start_set)
    end = property(_RNA.hx_end_get, _RNA.hx_end_set)
    length = property(_RNA.hx_length_get, _RNA.hx_length_set)
    up5 = property(_RNA.hx_up5_get, _RNA.hx_up5_set)
    up3 = property(_RNA.hx_up3_get, _RNA.hx_up3_set)

    def __init__(self, start, end, length, up5=0, up3=0):
        _RNA.hx_swiginit(self, _RNA.new_hx(start, end, length, up5, up3))

    def __str__(self):
        return _RNA.hx___str__(self)

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 

    __swig_destroy__ = _RNA.delete_hx

# Register hx in _RNA:
_RNA.hx_swigregister(hx)


def hx_from_ptable(*args):
    r"""
    hx_from_ptable(IntVector pt) -> HelixVector
    hx_from_ptable(varArrayShort pt) -> HelixVector


    Convert a pair table representation of a secondary structure into a helix list.  

    Parameters
    ----------
    pt : short *
        The secondary structure in pair table representation  

    Returns
    -------
    RNA.hx() *  
        The secondary structure represented as a helix list  

    """
    return _RNA.hx_from_ptable(*args)

def bp_distance(*args):
    r"""
    bp_distance(std::string str1, std::string str2, unsigned int options=) -> int
    bp_distance(IntVector pt1, IntVector pt2) -> int
    bp_distance(varArrayShort pt1, varArrayShort pt2) -> int


    Compute the "base pair" distance between two secondary structures s1 and s2.  

    This is a wrapper around **RNA.bp_distance_pt()**. The sequences should have the same length. dist
    = number of base pairs in one structure but not in the other same as edit distance with open-pair
    close-pair as move-set  

    **SWIG Wrapper Notes**
        This function is available as an overloaded method **bp_distance()**. Note that the SWIG wrapper
        takes two structure in dot-bracket notation and converts them into pair tables using
        RNA.ptable_from_string(). The resulting pair tables are then internally passed to
        RNA.bp_distance_pt(). To control which kind of matching brackets will be used during
        conversion, the optional argument `options` can be used. See also the description of
        RNA.ptable_from_string() for available options. (default: **RNA.BRACKETS_RND**). See, e.g.
        :py:func:`RNA.bp_distance()` in the :doc:`/api_python`.  

    Parameters
    ----------
    str1 : const char *
        First structure in dot-bracket notation  
    str2 : const char *
        Second structure in dot-bracket notation  

    Returns
    -------
    int  
        The base pair distance between str1 and str2  

    See Also
    --------
    RNA.bp_distance_pt()  

    """
    return _RNA.bp_distance(*args)

def dist_mountain(str1, str2, p=1):
    r"""


    """
    return _RNA.dist_mountain(str1, str2, p)
PLIST_TYPE_BASEPAIR = _RNA.PLIST_TYPE_BASEPAIR
r"""


    A Base Pair element.  

    """
PLIST_TYPE_GQUAD = _RNA.PLIST_TYPE_GQUAD
r"""


    A G-Quadruplex element.  

    """
PLIST_TYPE_H_MOTIF = _RNA.PLIST_TYPE_H_MOTIF
r"""


    A Hairpin loop motif element.  

    """
PLIST_TYPE_I_MOTIF = _RNA.PLIST_TYPE_I_MOTIF
r"""


    An Internal loop motif element.  

    """
PLIST_TYPE_UD_MOTIF = _RNA.PLIST_TYPE_UD_MOTIF
r"""


    An Unstructured Domain motif element.  

    """
PLIST_TYPE_STACK = _RNA.PLIST_TYPE_STACK
r"""


    A Base Pair stack element.  

    """
PLIST_TYPE_UNPAIRED = _RNA.PLIST_TYPE_UNPAIRED
r"""


    An unpaired base.  

    """
STRUCTURE_TREE_HIT = _RNA.STRUCTURE_TREE_HIT
r"""


    Homeomorphically Irreducible Tree (HIT) representation of a secondary structure.  

    See Also
    --------
    RNA.db_to_tree_string()  

    """
STRUCTURE_TREE_SHAPIRO_SHORT = _RNA.STRUCTURE_TREE_SHAPIRO_SHORT
r"""


    (short) Coarse Grained representation of a secondary structure  

    See Also
    --------
    RNA.db_to_tree_string()  

    """
STRUCTURE_TREE_SHAPIRO = _RNA.STRUCTURE_TREE_SHAPIRO
r"""


    (full) Coarse Grained representation of a secondary structure  

    See Also
    --------
    RNA.db_to_tree_string()  

    """
STRUCTURE_TREE_SHAPIRO_EXT = _RNA.STRUCTURE_TREE_SHAPIRO_EXT
r"""


    (extended) Coarse Grained representation of a secondary structure  

    See Also
    --------
    RNA.db_to_tree_string()  

    """
STRUCTURE_TREE_SHAPIRO_WEIGHT = _RNA.STRUCTURE_TREE_SHAPIRO_WEIGHT
r"""


    (weighted) Coarse Grained representation of a secondary structure  

    See Also
    --------
    RNA.db_to_tree_string()  

    """
STRUCTURE_TREE_EXPANDED = _RNA.STRUCTURE_TREE_EXPANDED
r"""


    Expanded Tree representation of a secondary structure.  

    See Also
    --------
    RNA.db_to_tree_string()  

    """
BRACKETS_RND = _RNA.BRACKETS_RND
r"""


    Bitflag to indicate secondary structure notations using round brackets (parenthesis), `()`  

    See Also
    --------
    RNA.ptable_from_string(), RNA.db_flatten(), RNA.db_flatten_to()  

    """
BRACKETS_ANG = _RNA.BRACKETS_ANG
r"""


    Bitflag to indicate secondary structure notations using angular brackets, `<>`  

    See Also
    --------
    RNA.ptable_from_string(), RNA.db_flatten(), RNA.db_flatten_to()  

    """
BRACKETS_SQR = _RNA.BRACKETS_SQR
r"""


    Bitflag to indicate secondary structure notations using square brackets, `[]`  

    See Also
    --------
    RNA.ptable_from_string(), RNA.db_flatten(), RNA.db_flatten_to()  

    """
BRACKETS_CLY = _RNA.BRACKETS_CLY
r"""


    Bitflag to indicate secondary structure notations using curly brackets, `{}`  

    See Also
    --------
    RNA.ptable_from_string(), RNA.db_flatten(), RNA.db_flatten_to()  

    """
BRACKETS_ALPHA = _RNA.BRACKETS_ALPHA
r"""


    Bitflag to indicate secondary structure notations using uppercase/lowercase letters from the latin
    alphabet.  

    See Also
    --------
    RNA.ptable_from_string()  

    """
BRACKETS_DEFAULT = _RNA.BRACKETS_DEFAULT
r"""


    Default bitmask to indicate secondary structure notation using any pair of brackets.  

    This set of matching brackets/parenthesis is always nested, i.e. pseudo-knot free, in WUSS format.
    However, in general different kinds of brackets are mostly used for annotating pseudo-knots. Thus
    special care has to be taken to remove pseudo-knots if this bitmask is used in functions that return
    secondary structures without pseudo-knots!  

    See Also
    --------
    RNA.ptable_from_string(), RNA.db_flatten(), RNA.db_flatten_to(),
    RNA.db_pk_remove()RNA.pt_pk_remove()  

    """
BRACKETS_ANY = _RNA.BRACKETS_ANY
r"""


    Bitmask to indicate secondary structure notation using any pair of brackets or uppercase/lowercase
    alphabet letters.  

    See Also
    --------
    RNA.ptable_from_string(), RNA.db_pk_remove(), RNA.db_flatten(), RNA.db_flatten_to()  

    """

def db_pack(struc):
    r"""


    Pack secondary secondary structure, 5:1 compression using base 3 encoding.  

    Returns a binary string encoding of the secondary structure using a 5:1 compression scheme. The
    string is NULL terminated and can therefore be used with standard string functions such as strcmp().
    Useful for programs that need to keep many structures in memory.  

    Parameters
    ----------
    struc : const char *
        The secondary structure in dot-bracket notation  

    Returns
    -------
    char *  
        The binary encoded structure  

    See Also
    --------
    RNA.db_unpack()  

    """
    return _RNA.db_pack(struc)

def db_unpack(packed):
    r"""


    Unpack secondary structure previously packed with RNA.db_pack()  

    Translate a compressed binary string produced by RNA.db_pack() back into the familiar dot-bracket
    notation.  

    Parameters
    ----------
    packed : const char *
        The binary encoded packed secondary structure  

    Returns
    -------
    char *  
        The unpacked secondary structure in dot-bracket notation  

    See Also
    --------
    RNA.db_pack()  

    """
    return _RNA.db_unpack(packed)

def db_to_element_string(structure):
    r"""


    Convert a secondary structure in dot-bracket notation to a nucleotide annotation of loop contexts.  

    Parameters
    ----------
    structure : const char *
        The secondary structure in dot-bracket notation  

    Returns
    -------
    char *  
        A string annotating each nucleotide according to it's structural context  

    """
    return _RNA.db_to_element_string(structure)

def aln_consensus_sequence(alignment, md_p=None):
    r"""
    aln_consensus_sequence(StringVector alignment, md md_p=None) -> std::string


    Compute the consensus sequence for a given multiple sequence alignment.  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `aln_consensus_sequence()` where the last
        parameter may be omitted, indicating `md` = `NULL`. See e.g.
        :py:func:`RNA.aln_consensus_sequence()` in the :doc:`/api_python`.  

    Parameters
    ----------
    alignment : const char **
        The input sequence alignment (last entry must be *NULL* terminated)  
    md_p : const RNA.md() *
        Model details that specify known nucleotides (Maybe *NULL*)  

    Returns
    -------
    char *  
        The consensus sequence of the alignment, i.e. the most frequent nucleotide for each alignment
        column  

    """
    return _RNA.aln_consensus_sequence(alignment, md_p)

def aln_consensus_mis(alignment, md_p=None):
    r"""
    aln_consensus_mis(StringVector alignment, md md_p=None) -> std::string


    Compute the Most Informative Sequence (MIS) for a given multiple sequence alignment.  

    The most informative sequence (MIS)  :cite:p:`freyhult:2005`  displays for each alignment column the
    nucleotides with frequency greater than the background frequency, projected into IUPAC notation.
    Columns where gaps are over-represented are in lower case.  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `aln_consensus_mis()` where the last parameter
        may be omitted, indicating `md` = `NULL`. See e.g.  :py:func:`RNA.aln_consensus_mis()` in the
        :doc:`/api_python`.  

    Parameters
    ----------
    alignment : const char **
        The input sequence alignment (last entry must be *NULL* terminated)  
    md_p : const RNA.md() *
        Model details that specify known nucleotides (Maybe *NULL*)  

    Returns
    -------
    char *  
        The most informative sequence for the alignment  

    """
    return _RNA.aln_consensus_mis(alignment, md_p)

def my_aln_consensus_sequence2(alignment, md_p=None):
    return _RNA.my_aln_consensus_sequence2(alignment, md_p)

def consens_mis(alignment, md_p=None):
    return _RNA.consens_mis(alignment, md_p)

def aln_mpi(alignment):
    r"""
    aln_mpi(StringVector alignment) -> int


    Get the mean pairwise identity in steps from ?to?(ident)  

    **SWIG Wrapper Notes**
        This function is available as function `aln_mpi()`. See e.g.  :py:func:`RNA.aln_mpi()` in the
        :doc:`/api_python`.  

    Parameters
    ----------
    alignment : const char **
        Aligned sequences  

    Returns
    -------
    int  
        The mean pairwise identity  

    """
    return _RNA.aln_mpi(alignment)

def aln_pscore(alignment, md=None):
    r"""
    aln_pscore(StringVector alignment, md md=None) -> IntIntVector


    **SWIG Wrapper Notes**
        This function is available as overloaded function `aln_pscore()` where the last parameter may be
        omitted, indicating `md` = `NULL`. See e.g.  :py:func:`RNA.aln_pscore()` in the
        :doc:`/api_python`.  

    """
    return _RNA.aln_pscore(alignment, md)

def aln_conservation_struct(alignment, structure, md=None):
    r"""
    aln_conservation_struct(StringVector alignment, std::string structure, md md=None) -> DoubleVector


    Compute base pair conservation of a consensus structure.  

    This function computes the base pair conservation (fraction of canonical base pairs) of a consensus
    structure given a multiple sequence alignment. The base pair types that are considered canonical may
    be specified using the RNA.md().pair array. Passing *NULL* as parameter `md` results in default
    pairing rules, i.e. canonical Watson-Crick and GU Wobble pairs.  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `aln_conservation_struct()` where the last
        parameter `md` may be omitted, indicating `md` = `NULL`. See, e.g.
        :py:func:`RNA.aln_conservation_struct()` in the :doc:`/api_python`.  

    Parameters
    ----------
    alignment : const char **
        The input sequence alignment (last entry must be *NULL* terminated)  
    structure : const char *
        The consensus structure in dot-bracket notation  
    md : const RNA.md() *
        Model details that specify compatible base pairs (Maybe *NULL*)  

    Returns
    -------
    float *  
        A 1-based vector of base pair conservations  

    """
    return _RNA.aln_conservation_struct(alignment, structure, md)

def aln_conservation_col(*args, **kwargs):
    r"""
    aln_conservation_col(StringVector alignment, md md=None, unsigned int options=) -> DoubleVector


    Compute nucleotide conservation in an alignment.  

    This function computes the conservation of nucleotides in alignment columns. The simples measure is
    Shannon Entropy and can be selected by passing the RNA.MEASURE_SHANNON_ENTROPY flag in the
    `options` parameter.  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `aln_conservation_col()` where the last two
        parameters may be omitted, indicating `md` = `NULL`, and `options` =
        RNA.MEASURE_SHANNON_ENTROPY, respectively. See e.g. :py:func:`RNA.aln_conservation_col()` in
        the :doc:`/api_python`.  

    Parameters
    ----------
    alignment : const char **
        The input sequence alignment (last entry must be *NULL* terminated)  
    md :
        Model details that specify known nucleotides (Maybe *NULL*)  
    options : unsigned int
        A flag indicating which measure of conservation should be applied  

    Returns
    -------
    float *  
        A 1-based vector of column conservations  

    See Also
    --------
    RNA.MEASURE_SHANNON_ENTROPY  

    Note
    ----
    Currently, only RNA.MEASURE_SHANNON_ENTROPY is supported as conservation measure.  

    """
    return _RNA.aln_conservation_col(*args, **kwargs)
ALN_DEFAULT = _RNA.ALN_DEFAULT
r"""


    Use default alignment settings.  

    """
ALN_RNA = _RNA.ALN_RNA
r"""


    Convert to RNA alphabet.  

    """
ALN_DNA = _RNA.ALN_DNA
r"""


    Convert to DNA alphabet.  

    """
ALN_UPPERCASE = _RNA.ALN_UPPERCASE
r"""


    Convert to uppercase nucleotide letters.  

    """
ALN_LOWERCASE = _RNA.ALN_LOWERCASE
r"""


    Convert to lowercase nucleotide letters.  

    """
MEASURE_SHANNON_ENTROPY = _RNA.MEASURE_SHANNON_ENTROPY
r"""


    Flag indicating Shannon Entropy measure.  

    Shannon Entropy is defined as :math:`H = - \sum_{c} p_{c} \cdot \log_{2} p_{c}`  

    """

def move_standard(seq, struc, type, verbosity_level, shifts, noLP):
    r"""move_standard(char * seq, char * struc, enum MOVE_TYPE type, int verbosity_level, int shifts, int noLP) -> char *"""
    return _RNA.move_standard(seq, struc, type, verbosity_level, shifts, noLP)
class struct_en(object):
    r"""


    Data structure for energy_of_move()  

    Attributes
    ----------
    energy : int  

    structure : short *  

    C++ includes: ViennaRNA/move_set.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    energy = property(_RNA.struct_en_energy_get, _RNA.struct_en_energy_set)
    structure = property(_RNA.struct_en_structure_get, _RNA.struct_en_structure_set)

    def __init__(self):
        r"""


        Data structure for energy_of_move()  

        Attributes
        ----------
        energy : int  

        structure : short *  

        C++ includes: ViennaRNA/move_set.h

        """
        _RNA.struct_en_swiginit(self, _RNA.new_struct_en())
    __swig_destroy__ = _RNA.delete_struct_en

# Register struct_en in _RNA:
_RNA.struct_en_swigregister(struct_en)

GRADIENT = _RNA.GRADIENT
FIRST = _RNA.FIRST
ADAPTIVE = _RNA.ADAPTIVE

def filename_sanitize(*args):
    r"""


    Sanitize a file name.  

    Returns a new file name where all invalid characters are substituted by a replacement character. If
    no replacement character is supplied, invalid characters are simply removed from the filename. File
    names may also never exceed a length of 255 characters. Longer file names will undergo a 'smart'
    truncation process, where the filenames suffix, i.e. everything after the last dot .', is attempted
    to be kept intact. Hence, only the filename part before the suffix is reduced in such a way that the
    total filename complies to the length restriction of 255 characters. If no suffix is present or the
    suffix itself already exceeds the maximum length, the filename is simply truncated from the back of
    the string.  

    For now we consider the following characters invalid:  

    *   backslash '\'  
    *   slash '/'  
    *   question mark '?'  
    *   percent sign ''  
    *   asterisk '*'  
    *   colon ':'  
    *   pipe symbol '|'  
    *   double quote '"'  
    *   triangular brackets '<' and '>'  

    Furthermore, the (resulting) file name must not be a reserved file name, such as:  

    *   '.'  
    *   '..'  

    Parameters
    ----------
    name : const char *
        The input file name  
    replacement : const char *
        The replacement character, or NULL  

    Returns
    -------
    char *  
        The sanitized file name, or NULL  

    Note
    ----
    This function allocates a new block of memory for the sanitized string. It also may return (a) NULL
    if the input is pointing to NULL, or (b) an empty string if the input only consists of invalid
    characters which are simply removed!  

    """
    return _RNA.filename_sanitize(*args)

def get_xy_coordinates(structure):
    r"""
    get_xy_coordinates(char const * structure) -> COORDINATE


    Compute nucleotide coordinates for secondary structure plot.  

    This function takes a secondary structure and computes X-Y coordinates for each nucleotide that then
    can be used to create a structure plot. The parameter `plot_type` is used to select the underlying
    layout algorithm. Currently, the following selections are provided:  

    *   RNA.PLOT_TYPE_SIMPLE  
    *   RNA.PLOT_TYPE_NAVIEW  
    *   RNA.PLOT_TYPE_CIRCULAR  
    *   RNA.PLOT_TYPE_TURTLE  
    *   RNA.PLOT_TYPE_PUZZLER  

    Passing an unsupported selection leads to the default algorithm RNA.PLOT_TYPE_NAVIEW  

    Here is a simple example how to use this function, assuming variable `structure` contains a valid
    dot-bracket string:  

    Parameters
    ----------
    structure : const char *
        The secondary structure in dot-bracket notation  
    x : float **
        The address of a pointer of X coordinates (pointer will point to memory, or NULL on failure)  
    y : float **
        The address of a pointer of Y coordinates (pointer will point to memory, or NULL on failure)  
    plot_type : int
        The layout algorithm to be used  

    Returns
    -------
    int  
        The length of the structure on success, 0 otherwise  

    See Also
    --------
    RNA.plot_coords_pt(), RNA.plot_coords_simple(), RNA.plot_coords_naview()
    RNA.plot_coords_circular(), RNA.plot_coords_turtle(), RNA.plot_coords_puzzler()  

    Note
    ----
    On success, this function allocates memory for X and Y coordinates and assigns the pointers at
    addressess `x` and `y` to the corresponding memory locations. It's the users responsibility to
    cleanup this memory after usage!  

    """
    return _RNA.get_xy_coordinates(structure)

def simple_circplot_coordinates(arg1):
    r"""simple_circplot_coordinates(std::string arg1) -> CoordinateVector"""
    return _RNA.simple_circplot_coordinates(arg1)

def naview_xy_coordinates(arg1):
    r"""naview_xy_coordinates(std::string arg1) -> CoordinateVector"""
    return _RNA.naview_xy_coordinates(arg1)
class COORDINATE(object):
    r"""


    this is a workarround for the SWIG Perl Wrapper RNA plot function that returns an array of type
    COORDINATE  

    Attributes
    ----------
    X : float  

    Y : float  

    C++ includes: ViennaRNA/plotting/layouts.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def get(self, i):
        return _RNA.COORDINATE_get(self, i)
    X = property(_RNA.COORDINATE_X_get, _RNA.COORDINATE_X_set)
    Y = property(_RNA.COORDINATE_Y_get, _RNA.COORDINATE_Y_set)

    def __init__(self):
        r"""


        this is a workarround for the SWIG Perl Wrapper RNA plot function that returns an array of type
        COORDINATE  

        Attributes
        ----------
        X : float  

        Y : float  

        C++ includes: ViennaRNA/plotting/layouts.h

        """
        _RNA.COORDINATE_swiginit(self, _RNA.new_COORDINATE())
    __swig_destroy__ = _RNA.delete_COORDINATE

# Register COORDINATE in _RNA:
_RNA.COORDINATE_swigregister(COORDINATE)


def simple_xy_coordinates(*args):
    r"""


    Calculate nucleotide coordinates for secondary structure plot the *Simple way*  

    .. deprecated:: 2.6.4
        Consider switching to RNA.plot_coords_simple_pt() instead!  

    See Also
    --------
    make_pair_table(), rna_plot_type, simple_circplot_coordinates(), naview_xy_coordinates(),
    RNA.file_PS_rnaplot_a(), RNA.file_PS_rnaplot, svg_rna_plot()  

    Parameters
    ----------
    pair_table : short *
        The pair table of the secondary structure  
    X : float *
        a pointer to an array with enough allocated space to hold the x coordinates  
    Y : float *
        a pointer to an array with enough allocated space to hold the y coordinates  

    Returns
    -------
    int  
        length of sequence on success, 0 otherwise  

    """
    return _RNA.simple_xy_coordinates(*args)

def my_PS_rna_plot_snoop_a(sequence, structure, filename, relative_access, seqs):
    r"""my_PS_rna_plot_snoop_a(std::string sequence, std::string structure, std::string filename, IntVector relative_access, StringVector seqs) -> int"""
    return _RNA.my_PS_rna_plot_snoop_a(sequence, structure, filename, relative_access, seqs)

def file_PS_rnaplot(*args):
    return _RNA.file_PS_rnaplot(*args)

def file_PS_rnaplot_a(*args):
    return _RNA.file_PS_rnaplot_a(*args)

def gmlRNA(string, structure, ssfile, option):
    r"""


    Produce a secondary structure graph in Graph Meta Language (gml) and write it to a file.  

    If 'option' is an uppercase letter the RNA sequence is used to label nodes, if 'option' equals *'X'*
    or *'x'* the resulting file will coordinates for an initial layout of the graph.  

    Parameters
    ----------
    string : char *
        The RNA sequence  
    structure : char *
        The secondary structure in dot-bracket notation  
    ssfile : char *
        The filename of the gml output  
    option : char
        The option flag  

    Returns
    -------
    int  
        1 on success, 0 otherwise  

    """
    return _RNA.gmlRNA(string, structure, ssfile, option)

def ssv_rna_plot(string, structure, ssfile):
    r"""


    Produce a secondary structure graph in SStructView format.  

    Write coord file for SStructView  

    Parameters
    ----------
    string : char *
        The RNA sequence  
    structure : char *
        The secondary structure in dot-bracket notation  
    ssfile : char *
        The filename of the ssv output  

    Returns
    -------
    int  
        1 on success, 0 otherwise  

    """
    return _RNA.ssv_rna_plot(string, structure, ssfile)

def svg_rna_plot(string, structure, ssfile):
    r"""


    Produce a secondary structure plot in SVG format and write it to a file.  

    Parameters
    ----------
    string : char *
        The RNA sequence  
    structure : char *
        The secondary structure in dot-bracket notation  
    ssfile : char *
        The filename of the svg output  

    Returns
    -------
    int  
        1 on success, 0 otherwise  

    """
    return _RNA.svg_rna_plot(string, structure, ssfile)

def xrna_plot(string, structure, ssfile):
    r"""


    Produce a secondary structure plot for further editing in XRNA.  

    Parameters
    ----------
    string : char *
        The RNA sequence  
    structure : char *
        The secondary structure in dot-bracket notation  
    ssfile : char *
        The filename of the xrna output  

    Returns
    -------
    int  
        1 on success, 0 otherwise  

    """
    return _RNA.xrna_plot(string, structure, ssfile)

def PS_rna_plot(string, structure, file):
    r"""


    Produce a secondary structure graph in PostScript and write it to 'filename'.  

    .. deprecated:: 2.6.4
        Use RNA.file_PS_rnaplot() instead!  

    """
    return _RNA.PS_rna_plot(string, structure, file)

def PS_rna_plot_a(string, structure, file, pre, post):
    r"""


    Produce a secondary structure graph in PostScript including additional annotation macros and write
    it to 'filename'.  

    .. deprecated:: 2.6.4
        Use RNA.file_PS_rnaplot_a() instead!  

    """
    return _RNA.PS_rna_plot_a(string, structure, file, pre, post)

def PS_rna_plot_a_gquad(string, structure, ssfile, pre, post):
    r"""


    Produce a secondary structure graph in PostScript including additional annotation macros and write
    it to 'filename' (detect and draw g-quadruplexes)  

    .. deprecated:: 2.6.4
        Use RNA.file_PS_rnaplot_a() instead!  

    """
    return _RNA.PS_rna_plot_a_gquad(string, structure, ssfile, pre, post)

def file_PS_aln(filename, alignment, identifiers, structure, start=0, end=0, offset=0, columns=60):
    r"""
    file_PS_aln(std::string filename, StringVector alignment, StringVector identifiers, std::string structure, unsigned int start=0, unsigned int end=0, int offset=0, unsigned int columns=60) -> int


    Create an annotated PostScript alignment plot.  

    Similar to RNA.file_PS_aln() but allows the user to print a particular slice of the alignment by
    specifying a `start` and `end` position. The additional `offset` parameter allows for adjusting the
    alignment position ruler value.  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `file_PS_aln()` where the last four parameter
        may be omitted, indicating `start` = *0*, `end` = *0*, `offset` = *0*, and `columns` = *60*.
        See, e.g.  :py:func:`RNA.file_PS_aln()` in the :doc:`/api_python`.  

    Parameters
    ----------
    filename : const char *
        The output file name  
    seqs : const char **
        The aligned sequences  
    names : const char **
        The names of the sequences  
    structure : const char *
        The consensus structure in dot-bracket notation  
    start : unsigned int
        The start of the alignment slice (a value of 0 indicates the first position of the alignment,
        i.e. no slicing at 5' side)  
    end : unsigned int
        The end of the alignment slice (a value of 0 indicates the last position of the alignment, i.e.
        no slicing at 3' side)  
    offset : int
        The alignment coordinate offset for the position ruler.  
    columns : unsigned int
        The number of columns before the alignment is wrapped as a new block (a value of 0 indicates no
        wrapping)  

    See Also
    --------
    RNA.file_PS_aln_slice()  

    """
    return _RNA.file_PS_aln(filename, alignment, identifiers, structure, start, end, offset, columns)

def plot_dp_EPS(*args, **kwargs):
    r"""


    Produce an encapsulate PostScript (EPS) dot-plot from one or two lists of base pair probabilities.  

    This function reads two RNA.ep() lists `upper` and `lower` (e.g. base pair probabilities and a
    secondary structure) and produces an EPS "dot plot" with filename `'filename'` where data from
    `upper` is placed in the upper-triangular and data from `lower` is placed in the lower triangular
    part of the matrix.  
     For default output, provide the flag RNA.PLOT_PROBABILITIES_DEFAULT as `options` parameter.  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `plot_dp_EPS()` where the last three
        parameters may be omitted. The default values for these parameters are `lower` = NULL, `auxdata`
        = NULL, `options` = RNA.PLOT_PROBABILITIES_DEFAULT. See, e.g.  :py:func:`RNA.plot_dp_EPS()` in
        the :doc:`/api_python`.  

    Parameters
    ----------
    filename : const char *
        A filename for the EPS output  
    sequence : const char *
        The RNA sequence  
    upper : RNA.ep() *
        The base pair probabilities for the upper triangular part  
    lower : RNA.ep() *
        The base pair probabilities for the lower triangular part  
    options : unsigned int
        Options indicating which of the input data should be included in the dot-plot  

    Returns
    -------
    int  
        1 if EPS file was successfully written, 0 otherwise  

    See Also
    --------
    RNA.plist(), RNA.fold_compound.plist_from_probs(), RNA.PLOT_PROBABILITIES_DEFAULT  

    """
    return _RNA.plot_dp_EPS(*args, **kwargs)

def PS_color_dot_plot(string, pi, filename):
    r"""


    """
    return _RNA.PS_color_dot_plot(string, pi, filename)

def PS_color_dot_plot_turn(seq, pi, filename, winSize):
    r"""


    """
    return _RNA.PS_color_dot_plot_turn(seq, pi, filename, winSize)

def PS_dot_plot_turn(seq, pl, filename, winSize):
    r"""


    """
    return _RNA.PS_dot_plot_turn(seq, pl, filename, winSize)

def PS_dot_plot_list(seq, filename, pl, mf, comment):
    r"""


    Produce a postscript dot-plot from two pair lists.  

    This function reads two plist structures (e.g. base pair probabilities and a secondary structure) as
    produced by assign_plist_from_pr() and assign_plist_from_db() and produces a postscript "dot plot"
    that is written to 'filename'.  
    Using base pair probabilities in the first and mfe structure in the second plist, the resulting
    "dot plot" represents each base pairing probability by a square of corresponding area in a upper
    triangle matrix. The lower part of the matrix contains the minimum free energy structure.  

    Parameters
    ----------
    seq : char *
        The RNA sequence  
    filename : char *
        A filename for the postscript output  
    pl : RNA.ep() *
        The base pair probability pairlist  
    mf : RNA.ep() *
        The mfe secondary structure pairlist  
    comment : char *
        A comment  

    Returns
    -------
    int  
        1 if postscript was successfully written, 0 otherwise  

    See Also
    --------
    assign_plist_from_pr(), assign_plist_from_db()  

    """
    return _RNA.PS_dot_plot_list(seq, filename, pl, mf, comment)

def PS_dot_plot(string, file):
    r"""


    Produce postscript dot-plot.  

    Wrapper to PS_dot_plot_list  

    Reads base pair probabilities produced by pf_fold() from the global array pr and the pair list
    base_pair produced by fold() and produces a postscript "dot plot" that is written to 'filename'.
    The "dot plot" represents each base pairing probability by a square of corresponding area in a
    upper triangle matrix. The lower part of the matrix contains the minimum free energy  

    .. deprecated:: 2.6.4
        This function is deprecated and will be removed soon! Use PS_dot_plot_list() instead!  

    Note
    ----
    DO NOT USE THIS FUNCTION ANYMORE SINCE IT IS NOT THREADSAFE  

    """
    return _RNA.PS_dot_plot(string, file)
DECOMP_PAIR_HP = _RNA.DECOMP_PAIR_HP
r"""


    Flag passed to generic softt constraints callback to indicate hairpin loop decomposition step.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates a hairpin loop enclosed by the base pair :math:`(i,j)`.  

    decomp_hp.svg  

    """
DECOMP_PAIR_IL = _RNA.DECOMP_PAIR_IL
r"""


    Indicator for interior loop decomposition step.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates an interior loop enclosed by the base pair :math:`(i,j)`, and enclosing the base pair
    :math:`(k,l)`.  

    decomp_il.svg  

    """
DECOMP_PAIR_ML = _RNA.DECOMP_PAIR_ML
r"""


    Indicator for multibranch loop decomposition step.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates a multibranch loop enclosed by the base pair :math:`(i,j)`, and consisting of some
    enclosed multi loop content from k to l.  

    decomp_ml.svg  

    """
DECOMP_ML_ML_ML = _RNA.DECOMP_ML_ML_ML
r"""


    Indicator for decomposition of multibranch loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates a multibranch loop part in the interval :math:`[i:j]`, which will be decomposed into two
    multibranch loop parts :math:`[i:k]`, and :math:`[l:j]`.  

    decomp_ml_ml_ml.svg  

    """
DECOMP_ML_STEM = _RNA.DECOMP_ML_STEM
r"""


    Indicator for decomposition of multibranch loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates a multibranch loop part in the interval :math:`[i:j]`, which will be considered a single
    stem branching off with base pair :math:`(k,l)`.  

    decomp_ml_stem.svg  

    """
DECOMP_ML_ML = _RNA.DECOMP_ML_ML
r"""


    Indicator for decomposition of multibranch loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates a multibranch loop part in the interval :math:`[i:j]`, which will be decomposed into a
    (usually) smaller multibranch loop part :math:`[k:l]`.  

    decomp_ml_ml.svg  

    """
DECOMP_ML_UP = _RNA.DECOMP_ML_UP
r"""


    Indicator for decomposition of multibranch loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates a multibranch loop part in the interval :math:`[i:j]`, which will be considered a
    multibranch loop part that only consists of unpaired nucleotides.  

    decomp_ml_up.svg  

    """
DECOMP_ML_ML_STEM = _RNA.DECOMP_ML_ML_STEM
r"""


    Indicator for decomposition of multibranch loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates a multibranch loop part in the interval :math:`[i:j]`, which will decomposed into a
    multibranch loop part :math:`[i:k]`, and a stem with enclosing base pair :math:`(l,j)`.  

    decomp_ml_ml_stem.svg  

    """
DECOMP_ML_COAXIAL = _RNA.DECOMP_ML_COAXIAL
r"""


    Indicator for decomposition of multibranch loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates a multibranch loop part in the interval :math:`[i:j]`, where two stems with enclosing
    pairs :math:`(i,k)` and :math:`(l,j)` are coaxially stacking onto each other.  

    decomp_ml_coaxial.svg  

    """
DECOMP_EXT_EXT = _RNA.DECOMP_EXT_EXT
r"""


    Indicator for decomposition of exterior loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates an exterior loop part in the interval :math:`[i:j]`, which will be decomposed into a
    (usually) smaller exterior loop part :math:`[k:l]`.  

    decomp_ext_ext.svg  

    """
DECOMP_EXT_UP = _RNA.DECOMP_EXT_UP
r"""


    Indicator for decomposition of exterior loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates an exterior loop part in the interval :math:`[i:j]`, which will be considered as an
    exterior loop component consisting of only unpaired nucleotides.  

    decomp_ext_up.svg  

    """
DECOMP_EXT_STEM = _RNA.DECOMP_EXT_STEM
r"""


    Indicator for decomposition of exterior loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates an exterior loop part in the interval :math:`[i:j]`, which will be considered a stem with
    enclosing pair :math:`(k,l)`.  

    decomp_ext_stem.svg  

    """
DECOMP_EXT_EXT_EXT = _RNA.DECOMP_EXT_EXT_EXT
r"""


    Indicator for decomposition of exterior loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates an exterior loop part in the interval :math:`[i:j]`, which will be decomposed into two
    exterior loop parts :math:`[i:k]` and :math:`[l:j]`.  

    decomp_ext_ext_ext.svg  

    """
DECOMP_EXT_STEM_EXT = _RNA.DECOMP_EXT_STEM_EXT
r"""


    Indicator for decomposition of exterior loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates an exterior loop part in the interval :math:`[i:j]`, which will be decomposed into a stem
    branching off with base pair :math:`(i,k)`, and an exterior loop part :math:`[l:j]`.  

    decomp_ext_stem_ext.svg  

    """
DECOMP_EXT_STEM_OUTSIDE = _RNA.DECOMP_EXT_STEM_OUTSIDE
r"""


    Indicator for decomposition of exterior loop part.  

    """
DECOMP_EXT_EXT_STEM = _RNA.DECOMP_EXT_EXT_STEM
r"""


    Indicator for decomposition of exterior loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates an exterior loop part in the interval :math:`[i:j]`, which will be decomposed into an
    exterior loop part :math:`[i:k]`, and a stem branching off with base pair :math:`(l,j)`.  

    decomp_ext_ext_stem.svg  

    """
DECOMP_EXT_EXT_STEM1 = _RNA.DECOMP_EXT_EXT_STEM1
r"""


    Indicator for decomposition of exterior loop part.  

    This flag notifies the soft or hard constraint callback function that the current decomposition step
    evaluates an exterior loop part in the interval :math:`[i:j]`, which will be decomposed into an
    exterior loop part :math:`[i:k]`, and a stem branching off with base pair :math:`(l,j-1)`.  

    decomp_ext_ext_stem1.svg  

    """
class hc(object):
    r"""


    The hard constraints data structure.  

    The content of this data structure determines the decomposition pattern used in the folding
    recursions. Attribute 'matrix' is used as source for the branching pattern of the decompositions
    during all folding recursions. Any entry in matrix[i,j] consists of the 6 LSB that allows one to
    distinguish the following types of base pairs:  

    *   in the exterior loop (RNA.CONSTRAINT_CONTEXT_EXT_LOOP)  
    *   enclosing a hairpin (RNA.CONSTRAINT_CONTEXT_HP_LOOP)  
    *   enclosing an interior loop (RNA.CONSTRAINT_CONTEXT_INT_LOOP)  
    *   enclosed by an exterior loop (RNA.CONSTRAINT_CONTEXT_INT_LOOP_ENC)  
    *   enclosing a multi branch loop (RNA.CONSTRAINT_CONTEXT_MB_LOOP)  
    *   enclosed by a multi branch loop (RNA.CONSTRAINT_CONTEXT_MB_LOOP_ENC)  

    The four linear arrays 'up_xxx' provide the number of available unpaired nucleotides (including
    position i) 3' of each position in the sequence.  

    See Also
    --------
    RNA.fold_compound.hc_init(), RNA.hc_free(), RNA.CONSTRAINT_CONTEXT_EXT_LOOP,
    RNA.CONSTRAINT_CONTEXT_HP_LOOP,
    RNA.CONSTRAINT_CONTEXT_INT_LOOP, RNA.CONSTRAINT_CONTEXT_MB_LOOP,
    RNA.CONSTRAINT_CONTEXT_MB_LOOP_ENC  

    Attributes
    ----------
    type : vrna_hc_type_e  

    n : unsigned int  

    state : unsigned char  

    mx : unsigned char *  

    matrix_local : unsigned char **  

    @23 : union vrna_hc_s::@22  

    up_ext : int *  
        A linear array that holds the number of allowed unpaired nucleotides in an exterior loop.  

    up_hp : int *  
        A linear array that holds the number of allowed unpaired nucleotides in a hairpin loop.  

    up_int : int *  
        A linear array that holds the number of allowed unpaired nucleotides in an interior loop.  

    up_ml : int *  
        A linear array that holds the number of allowed unpaired nucleotides in a multi branched loop.  

    f : vrna_hc_eval_f  
        A function pointer that returns whether or not a certain decomposition may be evaluated.  

    data : void *  
        A pointer to some structure where the user may store necessary data to evaluate its generic hard
        constraint function.  

    free_data : vrna_auxdata_free_f  
        A pointer to a function to free memory occupied by auxiliary data.  

        The function this pointer is pointing to will be called upon destruction of the RNA.hc(), and
        provided with the RNA.hc().data pointer that may hold auxiliary data. Hence, to avoid leaking
        memory, the user may use this pointer to free memory occupied by auxiliary data.  

    depot : vrna_hc_depot_t *  

    C++ includes: ViennaRNA/constraints/hard.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_RNA.hc_type_get)
    n = property(_RNA.hc_n_get)
    mx = property(_RNA.hc_mx_get)
    up_ext = property(_RNA.hc_up_ext_get)
    up_hp = property(_RNA.hc_up_hp_get)
    up_int = property(_RNA.hc_up_int_get)
    up_ml = property(_RNA.hc_up_ml_get)

    def __init__(self):
        r"""


        The hard constraints data structure.  

        The content of this data structure determines the decomposition pattern used in the folding
        recursions. Attribute 'matrix' is used as source for the branching pattern of the decompositions
        during all folding recursions. Any entry in matrix[i,j] consists of the 6 LSB that allows one to
        distinguish the following types of base pairs:  

        *   in the exterior loop (RNA.CONSTRAINT_CONTEXT_EXT_LOOP)  
        *   enclosing a hairpin (RNA.CONSTRAINT_CONTEXT_HP_LOOP)  
        *   enclosing an interior loop (RNA.CONSTRAINT_CONTEXT_INT_LOOP)  
        *   enclosed by an exterior loop (RNA.CONSTRAINT_CONTEXT_INT_LOOP_ENC)  
        *   enclosing a multi branch loop (RNA.CONSTRAINT_CONTEXT_MB_LOOP)  
        *   enclosed by a multi branch loop (RNA.CONSTRAINT_CONTEXT_MB_LOOP_ENC)  

        The four linear arrays 'up_xxx' provide the number of available unpaired nucleotides (including
        position i) 3' of each position in the sequence.  

        See Also
        --------
        RNA.fold_compound.hc_init(), RNA.hc_free(), RNA.CONSTRAINT_CONTEXT_EXT_LOOP,
        RNA.CONSTRAINT_CONTEXT_HP_LOOP,
        RNA.CONSTRAINT_CONTEXT_INT_LOOP, RNA.CONSTRAINT_CONTEXT_MB_LOOP,
        RNA.CONSTRAINT_CONTEXT_MB_LOOP_ENC  

        Attributes
        ----------
        type : vrna_hc_type_e  

        n : unsigned int  

        state : unsigned char  

        mx : unsigned char *  

        matrix_local : unsigned char **  

        @23 : union vrna_hc_s::@22  

        up_ext : int *  
            A linear array that holds the number of allowed unpaired nucleotides in an exterior loop.  

        up_hp : int *  
            A linear array that holds the number of allowed unpaired nucleotides in a hairpin loop.  

        up_int : int *  
            A linear array that holds the number of allowed unpaired nucleotides in an interior loop.  

        up_ml : int *  
            A linear array that holds the number of allowed unpaired nucleotides in a multi branched loop.  

        f : vrna_hc_eval_f  
            A function pointer that returns whether or not a certain decomposition may be evaluated.  

        data : void *  
            A pointer to some structure where the user may store necessary data to evaluate its generic hard
            constraint function.  

        free_data : vrna_auxdata_free_f  
            A pointer to a function to free memory occupied by auxiliary data.  

            The function this pointer is pointing to will be called upon destruction of the RNA.hc(), and
            provided with the RNA.hc().data pointer that may hold auxiliary data. Hence, to avoid leaking
            memory, the user may use this pointer to free memory occupied by auxiliary data.  

        depot : vrna_hc_depot_t *  

        C++ includes: ViennaRNA/constraints/hard.h

        """
        _RNA.hc_swiginit(self, _RNA.new_hc())
    __swig_destroy__ = _RNA.delete_hc

# Register hc in _RNA:
_RNA.hc_swigregister(hc)

CONSTRAINT_DB = _RNA.CONSTRAINT_DB
r"""


    Flag for RNA.fold_compound.constraints_add() to indicate that constraint is passed in pseudo dot-bracket
    notation.  

    See Also
    --------
    RNA.fold_compound.constraints_add(), RNA.message_constraint_options(),
    RNA.message_constraint_options_all()  

    """
CONSTRAINT_DB_ENFORCE_BP = _RNA.CONSTRAINT_DB_ENFORCE_BP
r"""


    Switch for dot-bracket structure constraint to enforce base pairs.  

    This flag should be used to really enforce base pairs given in dot-bracket constraint rather than
    just weakly-enforcing them.  

    See Also
    --------
    RNA.fold_compound.hc_add_from_db(), RNA.fold_compound.constraints_add(),
    RNA.message_constraint_options(),
    RNA.message_constraint_options_all()  

    """
CONSTRAINT_DB_PIPE = _RNA.CONSTRAINT_DB_PIPE
r"""


    Flag that is used to indicate the pipe '|' sign in pseudo dot-bracket notation of hard constraints.  

    Use this definition to indicate the pipe sign '|' (paired with another base)  

    See Also
    --------
    RNA.fold_compound.hc_add_from_db(), RNA.fold_compound.constraints_add(),
    RNA.message_constraint_options(),
    RNA.message_constraint_options_all()  

    """
CONSTRAINT_DB_DOT = _RNA.CONSTRAINT_DB_DOT
r"""


    dot '.' switch for structure constraints (no constraint at all)  

    See Also
    --------
    RNA.fold_compound.hc_add_from_db(), RNA.fold_compound.constraints_add(),
    RNA.message_constraint_options(),
    RNA.message_constraint_options_all()  

    """
CONSTRAINT_DB_X = _RNA.CONSTRAINT_DB_X
r"""


    'x' switch for structure constraint (base must not pair)  

    See Also
    --------
    RNA.fold_compound.hc_add_from_db(), RNA.fold_compound.constraints_add(),
    RNA.message_constraint_options(),
    RNA.message_constraint_options_all()  

    """
CONSTRAINT_DB_ANG_BRACK = _RNA.CONSTRAINT_DB_ANG_BRACK
r"""


    angle brackets '<', '>' switch for structure constraint (paired downstream/upstream)  

    See Also
    --------
    RNA.fold_compound.hc_add_from_db(), RNA.fold_compound.constraints_add(),
    RNA.message_constraint_options(),
    RNA.message_constraint_options_all()  

    """
CONSTRAINT_DB_RND_BRACK = _RNA.CONSTRAINT_DB_RND_BRACK
r"""


    round brackets '(',')' switch for structure constraint (base i pairs base j)  

    See Also
    --------
    RNA.fold_compound.hc_add_from_db(), RNA.fold_compound.constraints_add(),
    RNA.message_constraint_options(),
    RNA.message_constraint_options_all()  

    """
CONSTRAINT_DB_INTRAMOL = _RNA.CONSTRAINT_DB_INTRAMOL
r"""


    Flag that is used to indicate the character 'l' in pseudo dot-bracket notation of hard constraints.  

    Use this definition to indicate the usage of 'l' character (intramolecular pairs only)  

    See Also
    --------
    RNA.fold_compound.hc_add_from_db(), RNA.fold_compound.constraints_add(),
    RNA.message_constraint_options(),
    RNA.message_constraint_options_all()  

    """
CONSTRAINT_DB_INTERMOL = _RNA.CONSTRAINT_DB_INTERMOL
r"""


    Flag that is used to indicate the character 'e' in pseudo dot-bracket notation of hard constraints.  

    Use this definition to indicate the usage of 'e' character (intermolecular pairs only)  

    See Also
    --------
    RNA.fold_compound.hc_add_from_db(), RNA.fold_compound.constraints_add(),
    RNA.message_constraint_options(),
    RNA.message_constraint_options_all()  

    """
CONSTRAINT_DB_GQUAD = _RNA.CONSTRAINT_DB_GQUAD
r"""


    '+' switch for structure constraint (base is involved in a gquad)  

    See Also
    --------
    RNA.fold_compound.hc_add_from_db(), RNA.fold_compound.constraints_add(),
    RNA.message_constraint_options(),
    RNA.message_constraint_options_all()  

    Warnings
    --------
    This flag is for future purposes only! No implementation recognizes it yet.  

    """
CONSTRAINT_DB_DEFAULT = _RNA.CONSTRAINT_DB_DEFAULT
r"""


    Switch for dot-bracket structure constraint with default symbols.  

    This flag conveniently combines all possible symbols in dot-bracket notation for hard constraints
    and RNA.CONSTRAINT_DB  

    See Also
    --------
    RNA.fold_compound.hc_add_from_db(), RNA.fold_compound.constraints_add(),
    RNA.message_constraint_options(),
    RNA.message_constraint_options_all()  

    """
CONSTRAINT_CONTEXT_EXT_LOOP = _RNA.CONSTRAINT_CONTEXT_EXT_LOOP
r"""


    Hard constraints flag, base pair in the exterior loop.  

    """
CONSTRAINT_CONTEXT_HP_LOOP = _RNA.CONSTRAINT_CONTEXT_HP_LOOP
r"""


    Hard constraints flag, base pair encloses hairpin loop.  

    """
CONSTRAINT_CONTEXT_INT_LOOP = _RNA.CONSTRAINT_CONTEXT_INT_LOOP
r"""


    Hard constraints flag, base pair encloses an interior loop.  

    """
CONSTRAINT_CONTEXT_INT_LOOP_ENC = _RNA.CONSTRAINT_CONTEXT_INT_LOOP_ENC
r"""


    Hard constraints flag, base pair encloses a multi branch loop.  

    """
CONSTRAINT_CONTEXT_MB_LOOP = _RNA.CONSTRAINT_CONTEXT_MB_LOOP
r"""


    Hard constraints flag, base pair is enclosed in an interior loop.  

    """
CONSTRAINT_CONTEXT_MB_LOOP_ENC = _RNA.CONSTRAINT_CONTEXT_MB_LOOP_ENC
r"""


    Hard constraints flag, base pair is enclosed in a multi branch loop.  

    """
CONSTRAINT_CONTEXT_ENFORCE = _RNA.CONSTRAINT_CONTEXT_ENFORCE
r"""


    Hard constraint flag to indicate enforcement of constraints.  

    """
CONSTRAINT_CONTEXT_NO_REMOVE = _RNA.CONSTRAINT_CONTEXT_NO_REMOVE
r"""


    Hard constraint flag to indicate not to remove base pairs that conflict with a given constraint.  

    """
CONSTRAINT_CONTEXT_ALL_LOOPS = _RNA.CONSTRAINT_CONTEXT_ALL_LOOPS
r"""


    Constraint context flag indicating any loop context.  

    """
CONSTRAINT_CONTEXT_NONE = _RNA.CONSTRAINT_CONTEXT_NONE
r"""


    Constraint context flag that forbids a nucleotide or base pair to appear in any loop.  

    """
CONSTRAINT_CONTEXT_CLOSING_LOOPS = _RNA.CONSTRAINT_CONTEXT_CLOSING_LOOPS
r"""


    Constraint context flag indicating base pairs that close any loop.  

    """
CONSTRAINT_CONTEXT_ENCLOSED_LOOPS = _RNA.CONSTRAINT_CONTEXT_ENCLOSED_LOOPS
r"""


    Constraint context flag indicating base pairs enclosed by any loop.  

    """
class sc_mod_param(object):
    r"""


    Attributes
    ----------
    available : unsigned int  

    name : char *  

    one_letter_code : char  

    unmodified : char  

    fallback : char  

    pairing_partners : char  

    pairing_partners_encoding : unsigned int  

    unmodified_encoding : unsigned int  

    fallback_encoding : unsigned int  

    num_ptypes : size_t  

    ptypes : size_t  

    stack_dG : int  

    stack_dH : int  

    dangle5_dG : int  

    dangle5_dH : int  

    dangle3_dG : int  

    dangle3_dH : int  

    mismatch_dG : int  

    mismatch_dH : int  

    terminal_dG : int  

    terminal_dH : int  

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, json, md=None):
        r"""


        Attributes
        ----------
        available : unsigned int  

        name : char *  

        one_letter_code : char  

        unmodified : char  

        fallback : char  

        pairing_partners : char  

        pairing_partners_encoding : unsigned int  

        unmodified_encoding : unsigned int  

        fallback_encoding : unsigned int  

        num_ptypes : size_t  

        ptypes : size_t  

        stack_dG : int  

        stack_dH : int  

        dangle5_dG : int  

        dangle5_dH : int  

        dangle3_dG : int  

        dangle3_dH : int  

        mismatch_dG : int  

        mismatch_dH : int  

        terminal_dG : int  

        terminal_dH : int  

        """
        _RNA.sc_mod_param_swiginit(self, _RNA.new_sc_mod_param(json, md))
    __swig_destroy__ = _RNA.delete_sc_mod_param

# Register sc_mod_param in _RNA:
_RNA.sc_mod_param_swigregister(sc_mod_param)


def sc_mod_read_from_jsonfile(filename, md=None):
    r"""


    Parse and extract energy parameters for a modified base from a JSON file.  

    **SWIG Wrapper Notes**
        This function is available as an overloaded function `sc_mod_read_from_jsonfile()` where the
        `md` parameter may be omitted and defaults to `NULL`. See, e.g.
        :py:func:`RNA.sc_mod_read_from_jsonfile()` in the :doc:`/api_python` .  

    Parameters
    ----------
    filename : const char *
        The JSON file containing the specifications of the modified base  
    md : RNA.md() *
        A model-details data structure (for look-up of canonical base pairs)  

    Returns
    -------
    RNA.sc_mod_param()  
        Parameters of the modified base  

    See Also
    --------
    RNA.sc_mod_read_from_json(), RNA.sc_mod_parameters_free(), RNA.fold_compound.sc_mod(), modified-
    bases-params  

    """
    return _RNA.sc_mod_read_from_jsonfile(filename, md)

def sc_mod_read_from_json(json, md=None):
    r"""


    Parse and extract energy parameters for a modified base from a JSON string.  

    **SWIG Wrapper Notes**
        This function is available as an overloaded function `sc_mod_read_from_json()` where the `md`
        parameter may be omitted and defaults to `NULL`. See, e.g.
        :py:func:`RNA.sc_mod_read_from_json()` in the :doc:`/api_python` .  

    Parameters
    ----------
    filename :
        The JSON file containing the specifications of the modified base  
    md : RNA.md() *
        A model-details data structure (for look-up of canonical base pairs)  

    Returns
    -------
    RNA.sc_mod_param()  
        Parameters of the modified base  

    See Also
    --------
    RNA.sc_mod_read_from_jsonfile(), RNA.sc_mod_parameters_free(), RNA.fold_compound.sc_mod(), modified-
    bases-
    params  

    """
    return _RNA.sc_mod_read_from_json(json, md)
SC_MOD_CHECK_FALLBACK = _RNA.SC_MOD_CHECK_FALLBACK
r"""


    Check for sequence positions whether they resemble the fallback base.  

    This flag can be used to enable a sanity check within the RNA.sc_mod*() functions to see whether a
    supposedly modified position actually resembles the fallback base as specified in the modification
    parameters  

    See Also
    --------
    RNA.fold_compound.sc_mod_json(), RNA.fold_compound.sc_mod_jsonfile(), RNA.fold_compound.sc_mod(),
    RNA.fold_compound.sc_mod_m6A(),
    RNA.fold_compound.sc_mod_pseudouridine(), RNA.fold_compound.sc_mod_inosine(),
    RNA.fold_compound.sc_mod_7DA(), RNA.fold_compound.sc_mod_purine(),
    RNA.fold_compound.sc_mod_dihydrouridine(), RNA.SC_MOD_CHECK_UNMOD, RNA.SC_MOD_DEFAULT  

    """
SC_MOD_CHECK_UNMOD = _RNA.SC_MOD_CHECK_UNMOD
r"""


    Check for sequence positions whether they resemble the unmodified base.  

    This flag can be used to enable a sanity check within the RNA.sc_mod*() functions to see whether a
    supposedly modified position actually resembles the unmodified base as specified in the modification
    parameters  

    See Also
    --------
    RNA.fold_compound.sc_mod_json(), RNA.fold_compound.sc_mod_jsonfile(), RNA.fold_compound.sc_mod(),
    RNA.fold_compound.sc_mod_m6A(),
    RNA.fold_compound.sc_mod_pseudouridine(), RNA.fold_compound.sc_mod_inosine(),
    RNA.fold_compound.sc_mod_7DA(), RNA.fold_compound.sc_mod_purine(),
    RNA.fold_compound.sc_mod_dihydrouridine(), RNA.SC_MOD_CHECK_FALLBACK, RNA.SC_MOD_DEFAULT  

    """
SC_MOD_SILENT = _RNA.SC_MOD_SILENT
r"""


    Do not produce any warnings within the RNA.sc_mod*() functions.  

    See Also
    --------
    RNA.fold_compound.sc_mod_json(), RNA.fold_compound.sc_mod_jsonfile(), RNA.fold_compound.sc_mod(),
    RNA.fold_compound.sc_mod_m6A(),
    RNA.fold_compound.sc_mod_pseudouridine(), RNA.fold_compound.sc_mod_inosine(),
    RNA.fold_compound.sc_mod_7DA(), RNA.fold_compound.sc_mod_purine(),
    RNA.fold_compound.sc_mod_dihydrouridine()  

    """
SC_MOD_DEFAULT = _RNA.SC_MOD_DEFAULT
r"""


    Default settings for the RNA.sc_mod*() functions.  

    See Also
    --------
    RNA.fold_compound.sc_mod_json(), RNA.fold_compound.sc_mod_jsonfile(), RNA.fold_compound.sc_mod(),
    RNA.fold_compound.sc_mod_m6A(),
    RNA.fold_compound.sc_mod_pseudouridine(), RNA.fold_compound.sc_mod_inosine(),
    RNA.fold_compound.sc_mod_7DA(), RNA.fold_compound.sc_mod_purine(),
    RNA.fold_compound.sc_mod_dihydrouridine(), RNA.SC_MOD_CHECK_FALLBACK, RNA.SC_MOD_CHECK_UNMOD,
    RNA.SC_MOD_SILENT  

    """

def sc_mod_parameters_free(params):
    r"""


    Release memory occupied by a modified base parameter data structure.  

    Properly free a RNA.sc_mod_param() data structure  

    Parameters
    ----------
    params : RNA.sc_mod_param()
        The data structure to free  

    """
    return _RNA.sc_mod_parameters_free(params)

def eval_structure_simple(*args):
    r"""


    Calculate the free energy of an already folded RNA and print contributions per loop.  

    This function allows for detailed energy evaluation of a given sequence/structure pair. In contrast
    to RNA.fold_compound.eval_structure() this function prints detailed energy contributions based on individual
    loops to a file handle. If NULL is passed as file handle, this function defaults to print to stdout.
    Any positive `verbosity_level` activates potential warning message of the energy evaluting
    functions, while values :math:`\ge 1` allow for detailed control of what data is printed. A
    negative parameter `verbosity_level` turns off printing all together.  

    In contrast to RNA.fold_compound.eval_structure_verbose() this function assumes default model details and default
    energy parameters in order to evaluate the free energy of the secondary structure. Threefore, it
    serves as a simple interface function for energy evaluation for situations where no changes on the
    energy model are required.  

    **SWIG Wrapper Notes**
        This function is available through an overloaded version of RNA.eval_structure_simple(). The
        last two arguments for this function are optional and default to RNA.VERBOSITY_QUIET and
        `NULL`, respectively. See, e.g.   :py:func:`RNA.eval_structure_simple()` in the
        :doc:`/api_python` .  

    Parameters
    ----------
    string : const char *
        RNA sequence in uppercase letters  
    structure : const char *
        Secondary structure in dot-bracket notation  
    verbosity_level : int
        The level of verbosity of this function  
    file : FILE *
        A file handle where this function should print to (may be NULL).  

    Returns
    -------
    float  
        The free energy of the input structure given the input sequence in kcal/mol  

    See Also
    --------
    RNA.fold_compound.eval_structure_verbose(), RNA.fold_compound.eval_structure_pt(),
    RNA.fold_compound.eval_structure_pt_verbose(),  

    """
    return _RNA.eval_structure_simple(*args)

def eval_circ_structure(*args):
    r"""


    Evaluate free energy of a sequence/structure pair, assume sequence to be circular and print
    contributions per loop.  

    This function is the same as RNA.eval_structure_simple_v() but assumes the input sequence to be
    circularized.  

    **SWIG Wrapper Notes**
        This function is available through an overloaded version of RNA.eval_circ_structure(). The last
        two arguments for this function are optional and default to RNA.VERBOSITY_QUIET and `NULL`,
        respectively. See, e.g.   :py:func:`RNA.eval_circ_structure()` in the :doc:`/api_python` .  

    Parameters
    ----------
    string : const char *
        RNA sequence in uppercase letters  
    structure : const char *
        Secondary structure in dot-bracket notation  
    verbosity_level : int
        The level of verbosity of this function  
    file : FILE *
        A file handle where this function should print to (may be NULL).  

    Returns
    -------
    float  
        The free energy of the input structure given the input sequence in kcal/mol  

    See Also
    --------
    RNA.eval_structure_simple_v(), RNA.eval_circ_structure(), RNA.fold_compound.eval_structure_verbose()  

    """
    return _RNA.eval_circ_structure(*args)

def eval_gquad_structure(*args):
    r"""


    Evaluate free energy of a sequence/structure pair, allow for G-Quadruplexes in the structure and
    print contributions per loop.  

    This function is the same as RNA.eval_structure_simple_v() but allows for annotated G-Quadruplexes
    in the dot-bracket structure input.  

    G-Quadruplexes are annotated as plus signs ('+') for each G involved in the motif. Linker sequences
    must be denoted by dots ('.') as they are considered unpaired. Below is an example of a 2-layer
    G-quadruplex:  

    **SWIG Wrapper Notes**
        This function is available through an overloaded version of RNA.eval_gquad_structure(). The
        last two arguments for this function are optional and default to RNA.VERBOSITY_QUIET and
        `NULL`, respectively. See, e.g.   :py:func:`RNA.eval_gquad_structure()` in the
        :doc:`/api_python` .  

    Parameters
    ----------
    string : const char *
        RNA sequence in uppercase letters  
    structure : const char *
        Secondary structure in dot-bracket notation  
    verbosity_level : int
        The level of verbosity of this function  
    file : FILE *
        A file handle where this function should print to (may be NULL).  

    Returns
    -------
    float  
        The free energy of the input structure given the input sequence in kcal/mol  

    See Also
    --------
    RNA.eval_structure_simple_v(), RNA.eval_gquad_structure(),
    RNA.fold_compound.eval_structure_verbose()  

    """
    return _RNA.eval_gquad_structure(*args)

def eval_circ_gquad_structure(*args):
    r"""


    Evaluate free energy of a sequence/structure pair, assume sequence to be circular, allow for
    G-Quadruplexes in the structure, and print contributions per loop.  

    This function is the same as RNA.eval_structure_simple_v() but assumes the input sequence to be
    circular and allows for annotated G-Quadruplexes in the dot-bracket structure input.  

    G-Quadruplexes are annotated as plus signs ('+') for each G involved in the motif. Linker sequences
    must be denoted by dots ('.') as they are considered unpaired. Below is an example of a 2-layer
    G-quadruplex:  

    **SWIG Wrapper Notes**
        This function is available through an overloaded version of RNA.eval_circ_gquad_structure().
        The last two arguments for this function are optional and default to RNA.VERBOSITY_QUIET and
        `NULL`, respectively. See, e.g.   :py:func:`RNA.eval_circ_gquad_structure()` in the
        :doc:`/api_python` .  

    Parameters
    ----------
    string : const char *
        RNA sequence in uppercase letters  
    structure : const char *
        Secondary structure in dot-bracket notation  
    verbosity_level : int
        The level of verbosity of this function  
    file : FILE *
        A file handle where this function should print to (may be NULL).  

    Returns
    -------
    float  
        The free energy of the input structure given the input sequence in kcal/mol  

    """
    return _RNA.eval_circ_gquad_structure(*args)

def eval_structure_pt_simple(*args):
    r"""


    Calculate the free energy of an already folded RNA.  

    This function allows for energy evaluation of a given sequence/structure pair where the structure is
    provided in pair_table format as obtained from RNA.ptable(). Model details, energy parameters, and
    possibly soft constraints are used as provided via the parameter 'fc'. The fold_compound does not
    need to contain any DP matrices, but all the most basic init values as one would get from a call
    like this:  In contrast to RNA.fold_compound.eval_structure_pt_verbose() this function assumes default model
    details and default energy parameters in order to evaluate the free energy of the secondary
    structure. Threefore, it serves as a simple interface function for energy evaluation for situations
    where no changes on the energy model are required.  

    Parameters
    ----------
    string : const char *
        RNA sequence in uppercase letters  
    pt : const short *
        Secondary structure as pair_table  
    verbosity_level : int
        The level of verbosity of this function  
    file : FILE *
        A file handle where this function should print to (may be NULL).  

    Returns
    -------
    int  
        The free energy of the input structure given the input sequence in 10cal/mol  

    See Also
    --------
    RNA.ptable(), RNA.eval_structure_pt_v(), RNA.eval_structure_simple()  

    """
    return _RNA.eval_structure_pt_simple(*args)

def energy_of_structure(string, structure, verbosity_level):
    r"""


    Calculate the free energy of an already folded RNA using global model detail settings.  

    If verbosity level is set to a value >0, energies of structure elements are printed to stdout  

    .. deprecated:: 2.6.4
        Use RNA.fold_compound.eval_structure() or RNA.fold_compound.eval_structure_verbose() instead!  

    Note
    ----
    OpenMP: This function relies on several global model settings variables and thus is not to be
    considered threadsafe. See energy_of_struct_par() for a completely threadsafe implementation.  

    Parameters
    ----------
    string : const char *
        RNA sequence  
    structure : const char *
        secondary structure in dot-bracket notation  
    verbosity_level : int
        a flag to turn verbose output on/off  

    Returns
    -------
    float  
        the free energy of the input structure given the input sequence in kcal/mol  

    See Also
    --------
    RNA.fold_compound.eval_structure()  

    """
    return _RNA.energy_of_structure(string, structure, verbosity_level)

def energy_of_circ_structure(string, structure, verbosity_level):
    r"""


    Calculate the free energy of an already folded circular RNA.  


    If verbosity level is set to a value >0, energies of structure elements are printed to stdout  

    Note
    ----
    OpenMP: This function relies on several global model settings variables and thus is not to be
    considered threadsafe. See energy_of_circ_struct_par() for a completely threadsafe implementation.  

    .. deprecated:: 2.6.4
        Use RNA.fold_compound.eval_structure() or RNA.fold_compound.eval_structure_verbose() instead!  

    Parameters
    ----------
    string : const char *
        RNA sequence  
    structure : const char *
        Secondary structure in dot-bracket notation  
    verbosity_level : int
        A flag to turn verbose output on/off  

    Returns
    -------
    float  
        The free energy of the input structure given the input sequence in kcal/mol  

    See Also
    --------
    RNA.fold_compound.eval_structure()  

    """
    return _RNA.energy_of_circ_structure(string, structure, verbosity_level)

def energy_of_gquad_structure(string, structure, verbosity_level):
    r"""


    """
    return _RNA.energy_of_gquad_structure(string, structure, verbosity_level)

def energy_of_structure_pt(string, ptable, s, s1, verbosity_level):
    r"""


    Calculate the free energy of an already folded RNA.  

    If verbosity level is set to a value >0, energies of structure elements are printed to stdout  

    .. deprecated:: 2.6.4
        Use RNA.fold_compound.eval_structure_pt() or RNA.fold_compound.eval_structure_pt_verbose()
    instead!  

    Note
    ----
    OpenMP: This function relies on several global model settings variables and thus is not to be
    considered threadsafe. See energy_of_struct_pt_par() for a completely threadsafe implementation.  

    Parameters
    ----------
    string : const char *
        RNA sequence  
    ptable : short *
        the pair table of the secondary structure  
    s : short *
        encoded RNA sequence  
    s1 : short *
        encoded RNA sequence  
    verbosity_level : int
        a flag to turn verbose output on/off  

    Returns
    -------
    int  
        the free energy of the input structure given the input sequence in 10kcal/mol  

    See Also
    --------
    RNA.fold_compound.eval_structure_pt()  

    """
    return _RNA.energy_of_structure_pt(string, ptable, s, s1, verbosity_level)

def energy_of_move(string, structure, m1, m2):
    r"""


    Calculate energy of a move (closing or opening of a base pair)  

    If the parameters m1 and m2 are negative, it is deletion (opening) of a base pair, otherwise it is
    insertion (opening).  

    .. deprecated:: 2.6.4
        Use RNA.fold_compound.eval_move() instead!  

    Parameters
    ----------
    string : const char *
        RNA sequence  
    structure : const char *
        secondary structure in dot-bracket notation  
    m1 : int
        first coordinate of base pair  
    m2 : int
        second coordinate of base pair  

    Returns
    -------
    float  
        energy change of the move in kcal/mol  

    See Also
    --------
    RNA.fold_compound.eval_move()  

    """
    return _RNA.energy_of_move(string, structure, m1, m2)

def energy_of_move_pt(pt, s, s1, m1, m2):
    r"""


    Calculate energy of a move (closing or opening of a base pair)  

    If the parameters m1 and m2 are negative, it is deletion (opening) of a base pair, otherwise it is
    insertion (opening).  

    .. deprecated:: 2.6.4
        Use RNA.fold_compound.eval_move_pt() instead!  

    Parameters
    ----------
    pt : short *
        the pair table of the secondary structure  
    s : short *
        encoded RNA sequence  
    s1 : short *
        encoded RNA sequence  
    m1 : int
        first coordinate of base pair  
    m2 : int
        second coordinate of base pair  

    Returns
    -------
    int  
        energy change of the move in 10cal/mol  

    See Also
    --------
    RNA.fold_compound.eval_move_pt()  

    """
    return _RNA.energy_of_move_pt(pt, s, s1, m1, m2)

def loop_energy(ptable, s, s1, i):
    r"""


    Calculate energy of a loop.  

    .. deprecated:: 2.6.4
        Use RNA.fold_compound.eval_loop_pt() instead!  

    Parameters
    ----------
    ptable : short *
        the pair table of the secondary structure  
    s : short *
        encoded RNA sequence  
    s1 : short *
        encoded RNA sequence  
    i : int
        position of covering base pair  

    Returns
    -------
    int  
        free energy of the loop in 10cal/mol  

    See Also
    --------
    RNA.fold_compound.eval_loop_pt()  

    """
    return _RNA.loop_energy(ptable, s, s1, i)

def energy_of_struct(string, structure):
    r"""


    Calculate the free energy of an already folded RNA  

    .. deprecated:: 2.6.4
        This function is deprecated and should not be used in future programs! Use energy_of_structure()
        instead!  

    Note
    ----
    This function is not entirely threadsafe! Depending on the state of the global variable eos_debug it
    prints energy information to stdout or not...  

    Parameters
    ----------
    string : const char *
        RNA sequence  
    structure : const char *
        secondary structure in dot-bracket notation  

    Returns
    -------
    float  
        the free energy of the input structure given the input sequence in kcal/mol  

    See Also
    --------
    energy_of_structure, energy_of_circ_struct(), energy_of_struct_pt()  

    """
    return _RNA.energy_of_struct(string, structure)

def energy_of_struct_pt(string, ptable, s, s1):
    r"""


    Calculate the free energy of an already folded RNA  

    .. deprecated:: 2.6.4
        This function is deprecated and should not be used in future programs! Use
        energy_of_structure_pt() instead!  

    Note
    ----
    This function is not entirely threadsafe! Depending on the state of the global variable eos_debug it
    prints energy information to stdout or not...  

    Parameters
    ----------
    string : const char *
        RNA sequence  
    ptable : short *
        the pair table of the secondary structure  
    s : short *
        encoded RNA sequence  
    s1 : short *
        encoded RNA sequence  

    Returns
    -------
    int  
        the free energy of the input structure given the input sequence in 10kcal/mol  

    See Also
    --------
    make_pair_table(), energy_of_structure()  

    """
    return _RNA.energy_of_struct_pt(string, ptable, s, s1)

def energy_of_circ_struct(string, structure):
    r"""


    Calculate the free energy of an already folded circular RNA  

    .. deprecated:: 2.6.4
        This function is deprecated and should not be used in future programs Use
        energy_of_circ_structure() instead!  

    Note
    ----
    This function is not entirely threadsafe! Depending on the state of the global variable eos_debug it
    prints energy information to stdout or not...  

    Parameters
    ----------
    string : const char *
        RNA sequence  
    structure : const char *
        secondary structure in dot-bracket notation  

    Returns
    -------
    float  
        the free energy of the input structure given the input sequence in kcal/mol  

    See Also
    --------
    energy_of_circ_structure(), energy_of_struct(), energy_of_struct_pt()  

    """
    return _RNA.energy_of_circ_struct(string, structure)

def E_ext_stem(type, n5d, n3d, p):
    r"""


    Evaluate a stem branching off the exterior loop.  

    Given a base pair :math:`(i,j)` encoded by *type*, compute the energy contribution including
    dangling-end/terminal-mismatch contributions. Instead of returning the energy contribution per-se,
    this function returns the corresponding Boltzmann factor. If either of the adjacent nucleotides
    :math:`(i - 1)` and :math:`(j+1)` must not contribute stacking energy, the corresponding encoding
    must be :math:`-1`.  

    Parameters
    ----------
    type : unsigned int
        The base pair encoding  
    n5d : int
        The encoded nucleotide directly adjacent at the 5' side of the base pair (may be -1)  
    n3d : int
        The encoded nucleotide directly adjacent at the 3' side of the base pair (may be -1)  
    p : RNA.param() *
        The pre-computed energy parameters  

    Returns
    -------
    int  
        The energy contribution of the introduced exterior-loop stem  

    See Also
    --------
    RNA.E_exp_stem()  

    """
    return _RNA.E_ext_stem(type, n5d, n3d, p)

def exp_E_ext_stem(type, n5d, n3d, p):
    return _RNA.exp_E_ext_stem(type, n5d, n3d, p)

def E_Stem(type, si1, sj1, extLoop, P):
    r"""


    Compute the energy contribution of a stem branching off a loop-region.  

    This function computes the energy contribution of a stem that branches off a loop region. This can
    be the case in multiloops, when a stem branching off increases the degree of the loop but also
    *immediately interior base pairs* of an exterior loop contribute free energy. To switch the behavior
    of the function according to the evaluation of a multiloop- or exterior-loop-stem, you pass the flag
    'extLoop'. The returned energy contribution consists of a TerminalAU penalty if the pair type is
    greater than 2, dangling end contributions of mismatching nucleotides adjacent to the stem if only
    one of the si1, sj1 parameters is greater than 0 and mismatch energies if both mismatching
    nucleotides are positive values. Thus, to avoid incorporating dangling end or mismatch energies just
    pass a negative number, e.g. -1 to the mismatch argument.  

    This is an illustration of how the energy contribution is assembled:
          3'  5'
          |   |
          X - Y
    5'-si1     sj1-3'  

    Here, (X,Y) is the base pair that closes the stem that branches off a loop region. The nucleotides
    si1 and sj1 are the 5'- and 3'- mismatches, respectively. If the base pair type of (X,Y) is greater
    than 2 (i.e. an A-U or G-U pair, the TerminalAU penalty will be included in the energy contribution
    returned. If si1 and sj1 are both nonnegative numbers, mismatch energies will also be included. If
    one of si1 or sj1 is a negative value, only 5' or 3' dangling end contributions are taken into
    account. To prohibit any of these mismatch contributions to be incorporated, just pass a negative
    number to both, si1 and sj1. In case the argument extLoop is 0, the returned energy contribution
    also includes the *internal-loop-penalty* of a multiloop stem with closing pair type.  

    .. deprecated:: 2.6.4
        Please use one of the functions RNA.E_ext_stem() and E_MLstem() instead! Use the former for
        cases where `extLoop` != 0 and the latter otherwise.  

    See Also
    --------
    E_MLstem(), _ExtLoop()  

    Note
    ----
    This function is threadsafe  

    Parameters
    ----------
    type : int
        The pair type of the first base pair un the stem  
    si1 : int
        The 5'-mismatching nucleotide  
    sj1 : int
        The 3'-mismatching nucleotide  
    extLoop : int
        A flag that indicates whether the contribution reflects the one of an exterior loop or not  
    P : RNA.param() *
        The data structure containing scaled energy parameters  

    Returns
    -------
    int  
        The Free energy of the branch off the loop in dcal/mol  

    """
    return _RNA.E_Stem(type, si1, sj1, extLoop, P)

def E_ExtLoop(type, si1, sj1, P):
    r"""


    """
    return _RNA.E_ExtLoop(type, si1, sj1, P)

def exp_E_ExtLoop(type, si1, sj1, P):
    r"""


    This is the partition function variant of E_ExtLoop()  

    .. deprecated:: 2.6.4
        Use RNA.fold_compound.exp_E_ext_stem() instead!  

    Returns
    -------
    FLT_OR_DBL  
        The Boltzmann weighted energy contribution of the introduced exterior-loop stem  

    See Also
    --------
    E_ExtLoop()  

    """
    return _RNA.exp_E_ExtLoop(type, si1, sj1, P)

def exp_E_Stem(type, si1, sj1, extLoop, P):
    r"""


    Compute the Boltzmann weighted energy contribution of a stem branching off a loop-region
    ----------------------------------------------------------------------------------------  
    This is the partition function variant of E_Stem()  

    Returns
    -------
    FLT_OR_DBL  
        The Boltzmann weighted energy contribution of the branch off the loop  

    See Also
    --------
    E_Stem()  

    Note
    ----
    This function is threadsafe  

    """
    return _RNA.exp_E_Stem(type, si1, sj1, extLoop, P)

def E_Hairpin(size, type, si1, sj1, string, P):
    r"""


    Compute the Energy of a hairpin-loop.  

    To evaluate the free energy of a hairpin-loop, several parameters have to be known. A general
    hairpin-loop has this structure:  
          a3 a4
        a2     a5
        a1     a6
          X - Y
          |   |
          5'  3'
     where X-Y marks the closing pair [e.g. a **(G,C)** pair]. The length of this loop is 6 as there are
    six unpaired nucleotides (a1-a6) enclosed by (X,Y). The 5' mismatching nucleotide is a1 while the 3'
    mismatch is a6. The nucleotide sequence of this loop is "a1.a2.a3.a4.a5.a6"  

    Parameters
    ----------
    size : int
        The size of the loop (number of unpaired nucleotides)  
    type : int
        The pair type of the base pair closing the hairpin  
    si1 : int
        The 5'-mismatching nucleotide  
    sj1 : int
        The 3'-mismatching nucleotide  
    string : const char *
        The sequence of the loop (May be `NULL`, otherwise mst be at least :math:`size + 2` long)  
    P : RNA.param() *
        The datastructure containing scaled energy parameters  

    Returns
    -------
    int  
        The Free energy of the Hairpin-loop in dcal/mol  

    Warnings
    --------
    Not (really) thread safe! A threadsafe implementation will replace this function in a future
    release!  
     Energy evaluation may change due to updates in global variable "tetra_loop"  

    See Also
    --------
    scale_parameters(), RNA.param()  

    Note
    ----
    The parameter sequence should contain the sequence of the loop in capital letters of the nucleic
    acid alphabet if the loop size is below 7. This is useful for unusually stable tri-, tetra- and
    hexa-loops which are treated differently (based on experimental data) if they are tabulated.  

    """
    return _RNA.E_Hairpin(size, type, si1, sj1, string, P)

def exp_E_Hairpin(u, type, si1, sj1, string, P):
    r"""


    Compute Boltzmann weight :math:`e^{-\Delta G/kT}` of a hairpin loop.  

    Parameters
    ----------
    u : int
        The size of the loop (number of unpaired nucleotides)  
    type : int
        The pair type of the base pair closing the hairpin  
    si1 : short
        The 5'-mismatching nucleotide  
    sj1 : short
        The 3'-mismatching nucleotide  
    string : const char *
        The sequence of the loop (May be `NULL`, otherwise mst be at least :math:`size + 2` long)  
    P : RNA.exp_param() *
        The datastructure containing scaled Boltzmann weights of the energy parameters  

    Returns
    -------
    FLT_OR_DBL  
        The Boltzmann weight of the Hairpin-loop  

    Warnings
    --------
    Not (really) thread safe! A threadsafe implementation will replace this function in a future
    release!  
     Energy evaluation may change due to updates in global variable "tetra_loop"  

    See Also
    --------
    get_scaled_pf_parameters(), RNA.exp_param(), E_Hairpin()  

    Note
    ----
    multiply by scale[u+2]  

    """
    return _RNA.exp_E_Hairpin(u, type, si1, sj1, string, P)

def E_IntLoop(n1, n2, type, type_2, si1, sj1, sp1, sq1, P):
    r"""


    Compute the Energy of an interior-loop
    --------------------------------------  
    This function computes the free energy :math:`\Delta G` of an interior-loop with the following
    structure:  
          3'  5'
          |   |
          U - V
      a_n       b_1
       .        .
       .        .
       .        .
      a_1       b_m
          X - Y
          |   |
          5'  3'
     This general structure depicts an interior-loop that is closed by the base pair (X,Y). The enclosed
    base pair is (V,U) which leaves the unpaired bases a_1-a_n and b_1-b_n that constitute the loop. In
    this example, the length of the interior-loop is :math:`(n+m)` where n or m may be 0 resulting in a
    bulge-loop or base pair stack. The mismatching nucleotides for the closing pair (X,Y) are:  
     5'-mismatch: a_1  
     3'-mismatch: b_m  
     and for the enclosed base pair (V,U):  
     5'-mismatch: b_1  
     3'-mismatch: a_n  

    Parameters
    ----------
    n1 : int
        The size of the 'left'-loop (number of unpaired nucleotides)  
    n2 : int
        The size of the 'right'-loop (number of unpaired nucleotides)  
    type : int
        The pair type of the base pair closing the interior loop  
    type_2 : int
        The pair type of the enclosed base pair  
    si1 : int
        The 5'-mismatching nucleotide of the closing pair  
    sj1 : int
        The 3'-mismatching nucleotide of the closing pair  
    sp1 : int
        The 3'-mismatching nucleotide of the enclosed pair  
    sq1 : int
        The 5'-mismatching nucleotide of the enclosed pair  
    P : RNA.param() *
        The datastructure containing scaled energy parameters  

    Returns
    -------
    int  
        The Free energy of the Interior-loop in dcal/mol  

    See Also
    --------
    scale_parameters(), RNA.param()  

    Note
    ----
    Base pairs are always denoted in 5'->3' direction. Thus the enclosed base pair must be 'turned
    arround' when evaluating the free energy of the interior-loop  
     This function is threadsafe  

    """
    return _RNA.E_IntLoop(n1, n2, type, type_2, si1, sj1, sp1, sq1, P)

def exp_E_IntLoop(u1, u2, type, type2, si1, sj1, sp1, sq1, P):
    r"""


    Compute Boltzmann weight :math:`e^{-\Delta G/kT}` of interior loop
    -------------------------------------------------------------------  
    multiply by scale[u1+u2+2] for scaling  

    Parameters
    ----------
    u1 : int
        The size of the 'left'-loop (number of unpaired nucleotides)  
    u2 : int
        The size of the 'right'-loop (number of unpaired nucleotides)  
    type : int
        The pair type of the base pair closing the interior loop  
    type2 : int
        The pair type of the enclosed base pair  
    si1 : short
        The 5'-mismatching nucleotide of the closing pair  
    sj1 : short
        The 3'-mismatching nucleotide of the closing pair  
    sp1 : short
        The 3'-mismatching nucleotide of the enclosed pair  
    sq1 : short
        The 5'-mismatching nucleotide of the enclosed pair  
    P : RNA.exp_param() *
        The datastructure containing scaled Boltzmann weights of the energy parameters  

    Returns
    -------
    FLT_OR_DBL  
        The Boltzmann weight of the Interior-loop  

    See Also
    --------
    get_scaled_pf_parameters(), RNA.exp_param(), E_IntLoop()  

    Note
    ----
    This function is threadsafe  

    """
    return _RNA.exp_E_IntLoop(u1, u2, type, type2, si1, sj1, sp1, sq1, P)

def E_IntLoop_Co(type, type_2, i, j, p, q, cutpoint, si1, sj1, sp1, sq1, dangles, P):
    r"""


    """
    return _RNA.E_IntLoop_Co(type, type_2, i, j, p, q, cutpoint, si1, sj1, sp1, sq1, dangles, P)

def ubf_eval_int_loop(i, j, p, q, i1, j1, p1, q1, si, sj, sp, sq, type, type_2, rtype, ij, cp, P, sc):
    r"""


    """
    return _RNA.ubf_eval_int_loop(i, j, p, q, i1, j1, p1, q1, si, sj, sp, sq, type, type_2, rtype, ij, cp, P, sc)

def ubf_eval_int_loop2(i, j, p, q, i1, j1, p1, q1, si, sj, sp, sq, type, type_2, rtype, ij, sn, ss, P, sc):
    r"""


    """
    return _RNA.ubf_eval_int_loop2(i, j, p, q, i1, j1, p1, q1, si, sj, sp, sq, type, type_2, rtype, ij, sn, ss, P, sc)

def ubf_eval_ext_int_loop(i, j, p, q, i1, j1, p1, q1, si, sj, sp, sq, type, type_2, length, P, sc):
    r"""


    """
    return _RNA.ubf_eval_ext_int_loop(i, j, p, q, i1, j1, p1, q1, si, sj, sp, sq, type, type_2, length, P, sc)

def E_ml_rightmost_stem(i, j, fc):
    r"""


    """
    return _RNA.E_ml_rightmost_stem(i, j, fc)

def E_MLstem(type, si1, sj1, P):
    r"""


    """
    return _RNA.E_MLstem(type, si1, sj1, P)

def exp_E_MLstem(type, si1, sj1, P):
    r"""


    """
    return _RNA.exp_E_MLstem(type, si1, sj1, P)

def maximum_matching(sequence):
    r"""


    **SWIG Wrapper Notes**
        This function is available as global function `maximum_matching()`. See e.g.
        :py:func:`RNA.maximum_matching()` in the :doc:`/api_python`.  

    """
    return _RNA.maximum_matching(sequence)

def fold(*args):
    r"""
    fold(string) -> (structure, mfe)fold(string) -> (structure, mfe)


    Compute Minimum Free Energy (MFE), and a corresponding secondary structure for an RNA sequence.  

    This simplified interface to RNA.fold_compound.mfe() computes the MFE and, if required, a secondary structure for
    an RNA sequence using default options. Memory required for dynamic programming (DP) matrices will be
    allocated and free'd on-the-fly. Hence, after return of this function, the recursively filled
    matrices are not available any more for any post-processing, e.g. suboptimal backtracking, etc.  

    **SWIG Wrapper Notes**
        This function is available as function `fold()` in the global namespace. The parameter
        `structure` is returned along with the MFE und must not be provided. See e.g.
        :py:func:`RNA.fold()` in the :doc:`/api_python`.  

    Parameters
    ----------
    sequence : const char *
        RNA sequence  
    structure : char *
        A pointer to the character array where the secondary structure in dot-bracket notation will be
        written to  

    Returns
    -------
    float  
        the minimum free energy (MFE) in kcal/mol  

    See Also
    --------
    RNA.circfold(), RNA.fold_compound.mfe()  

    Note
    ----
    In case you want to use the filled DP matrices for any subsequent post-processing step, or you
    require other conditions than specified by the default model details, use RNA.fold_compound.mfe(),
    and the data
    structure RNA.fold_compound() instead.  

    """
    return _RNA.fold(*args)

def alifold(*args):
    r"""


    Compute Minimum Free Energy (MFE), and a corresponding consensus secondary structure for an RNA
    sequence alignment using a comparative method.  

    This simplified interface to RNA.fold_compound.mfe() computes the MFE and, if required, a consensus secondary
    structure for an RNA sequence alignment using default options. Memory required for dynamic
    programming (DP) matrices will be allocated and free'd on-the-fly. Hence, after return of this
    function, the recursively filled matrices are not available any more for any post-processing, e.g.
    suboptimal backtracking, etc.  

    **SWIG Wrapper Notes**
        This function is available as function `alifold()` in the global namespace. The parameter
        `structure` is returned along with the MFE und must not be provided. See e.g.
        :py:func:`RNA.alifold()` in the :doc:`/api_python`.  

    Parameters
    ----------
    sequences : const char **
        RNA sequence alignment  
    structure : char *
        A pointer to the character array where the secondary structure in dot-bracket notation will be
        written to  

    Returns
    -------
    float  
        the minimum free energy (MFE) in kcal/mol  

    See Also
    --------
    RNA.circalifold(), RNA.fold_compound.mfe()  

    Note
    ----
    In case you want to use the filled DP matrices for any subsequent post-processing step, or you
    require other conditions than specified by the default model details, use RNA.fold_compound.mfe(),
    and the data
    structure RNA.fold_compound() instead.  

    """
    return _RNA.alifold(*args)

def cofold(*args):
    r"""


    Compute Minimum Free Energy (MFE), and a corresponding secondary structure for two dimerized RNA
    sequences.  

    This simplified interface to RNA.fold_compound.mfe() computes the MFE and, if required, a secondary structure for
    two RNA sequences upon dimerization using default options. Memory required for dynamic programming
    (DP) matrices will be allocated and free'd on-the-fly. Hence, after return of this function, the
    recursively filled matrices are not available any more for any post-processing, e.g. suboptimal
    backtracking, etc.  

    .. deprecated:: 2.6.4
        This function is obsolete since RNA.mfe()/RNA.fold() can handle complexes multiple sequences
        since v2.5.0. Use RNA.mfe()/RNA.fold() for connected component MFE instead and compute MFEs of
        unconnected states separately.  

    Note
    ----
    In case you want to use the filled DP matrices for any subsequent post-processing step, or you
    require other conditions than specified by the default model details, use RNA.fold_compound.mfe(),
    and the data
    structure RNA.fold_compound() instead.  

    **SWIG Wrapper Notes**
        This function is available as function `cofold()` in the global namespace. The parameter
        `structure` is returned along with the MFE und must not be provided. See e.g.
        :py:func:`RNA.cofold()` in the :doc:`/api_python`.  

    Parameters
    ----------
    sequence : const char *
        two RNA sequences separated by the '&' character  
    structure : char *
        A pointer to the character array where the secondary structure in dot-bracket notation will be
        written to  

    Returns
    -------
    float  
        the minimum free energy (MFE) in kcal/mol  

    See Also
    --------
    RNA.fold(), RNA.fold_compound.mfe(), RNA.fold_compound(), RNA.fold_compound(),
    RNA.cut_point_insert()  

    """
    return _RNA.cofold(*args)

def circfold(*args):
    r"""


    Compute Minimum Free Energy (MFE), and a corresponding secondary structure for a circular RNA
    sequence.  

    This simplified interface to RNA.fold_compound.mfe() computes the MFE and, if required, a secondary structure for
    a circular RNA sequence using default options. Memory required for dynamic programming (DP) matrices
    will be allocated and free'd on-the-fly. Hence, after return of this function, the recursively
    filled matrices are not available any more for any post-processing, e.g. suboptimal backtracking,
    etc.  

    Folding of circular RNA sequences is handled as a post-processing step of the forward recursions.
    See  :cite:t:`hofacker:2006`  for further details.  

    **SWIG Wrapper Notes**
        This function is available as function `circfold()` in the global namespace. The parameter
        `structure` is returned along with the MFE und must not be provided. See e.g.
        :py:func:`RNA.circfold()` in the :doc:`/api_python`.  

    Parameters
    ----------
    sequence : const char *
        RNA sequence  
    structure : char *
        A pointer to the character array where the secondary structure in dot-bracket notation will be
        written to  

    Returns
    -------
    float  
        the minimum free energy (MFE) in kcal/mol  

    See Also
    --------
    RNA.fold(), RNA.fold_compound.mfe()  

    Note
    ----
    In case you want to use the filled DP matrices for any subsequent post-processing step, or you
    require other conditions than specified by the default model details, use RNA.fold_compound.mfe(),
    and the data
    structure RNA.fold_compound() instead.  

    """
    return _RNA.circfold(*args)

def free_arrays():
    r"""


    Free arrays for mfe folding.  

    .. deprecated:: 2.6.4
        See RNA.fold(), RNA.circfold(), or RNA.fold_compound.mfe() and RNA.fold_compound() for the usage
    of the
        new API!  

    """
    return _RNA.free_arrays()

def update_fold_params():
    r"""


    Recalculate energy parameters.  

    .. deprecated:: 2.6.4
        For non-default model settings use the new API with RNA.fold_compound.params_subst() and
    RNA.fold_compound.mfe() instead!  

    """
    return _RNA.update_fold_params()

def circalifold(*args):
    r"""


    Compute MFE and according structure of an alignment of sequences assuming the sequences are circular
    instead of linear.  

    .. deprecated:: 2.6.4
        Usage of this function is discouraged! Use RNA.alicircfold(), and RNA.fold_compound.mfe()
    instead!  

    Parameters
    ----------
    strings : const char **
        A pointer to a NULL terminated array of character arrays  
    structure : char *
        A pointer to a character array that may contain a constraining consensus structure (will be
        overwritten by a consensus structure that exhibits the MFE)  

    Returns
    -------
    float  
        The free energy score in kcal/mol  

    See Also
    --------
    RNA.alicircfold(), RNA.alifold(), RNA.fold_compound.mfe()  

    """
    return _RNA.circalifold(*args)

def free_alifold_arrays():
    r"""


    Free the memory occupied by MFE alifold functions.  

    .. deprecated:: 2.6.4
        Usage of this function is discouraged! It only affects memory being free'd that was allocated by
        an old API function before. Release of memory occupied by the newly introduced
        RNA.fold_compound() is handled by RNA.fold_compound_free()  

    See Also
    --------
    RNA.fold_compound_free()  

    """
    return _RNA.free_alifold_arrays()

def free_co_arrays():
    r"""


    Free memory occupied by cofold()  

    .. deprecated:: 2.6.4
        This function will only free memory allocated by a prior call of cofold() or cofold_par(). See
        RNA.fold_compound.mfe_dimer() for how to use the new API  

    See Also
    --------
    RNA.fc_destroy(), RNA.fold_compound.mfe_dimer()  

    Note
    ----
    folding matrices now reside in the fold compound, and should be free'd there  

    """
    return _RNA.free_co_arrays()

def update_cofold_params():
    r"""


    Recalculate parameters.  

    .. deprecated:: 2.6.4
        See RNA.fold_compound.params_subst() for an alternative using the new API  

    """
    return _RNA.update_cofold_params()

def initialize_cofold(length):
    r"""


    allocate arrays for folding  

    .. deprecated:: 2.6.4
        {This function is obsolete and will be removed soon!}  

    """
    return _RNA.initialize_cofold(length)

def Lfoldz(sequence, window_size, min_z, nullfile=None):
    r"""


    Local MFE prediction using a sliding window approach with z-score cut-off (simplified interface)  

    This simplified interface to RNA.fold_compound.mfe_window_zscore() computes the MFE and locally optimal secondary
    structure using default options. Structures are predicted using a sliding window approach, where
    base pairs may not span outside the window. Memory required for dynamic programming (DP) matrices
    will be allocated and free'd on-the-fly. Hence, after return of this function, the recursively
    filled matrices are not available any more for any post-processing. This function is the z-score
    version of RNA.Lfold(), i.e. only predictions above a certain z-score cut-off value are printed.  

    Parameters
    ----------
    string : const char *
        The nucleic acid sequence  
    window_size : int
        The window size for locally optimal structures  
    min_z : double
        The minimal z-score for a predicted structure to appear in the output  
    file : FILE *
        The output file handle where predictions are written to (if NULL, output is written to stdout)  

    See Also
    --------
    RNA.fold_compound.mfe_window_zscore(), RNA.Lfold(), RNA.fold_compound.mfe_window()  

    Note
    ----
    In case you want to use the filled DP matrices for any subsequent post-processing step, or you
    require other conditions than specified by the default model details, use
    RNA.fold_compound.mfe_window(), and the
    data structure RNA.fold_compound() instead.  

    """
    return _RNA.Lfoldz(sequence, window_size, min_z, nullfile)

def Lfold(sequence, window_size, nullfile=None):
    r"""


    Local MFE prediction using a sliding window approach (simplified interface)  

    This simplified interface to RNA.fold_compound.mfe_window() computes the MFE and locally optimal secondary
    structure using default options. Structures are predicted using a sliding window approach, where
    base pairs may not span outside the window. Memory required for dynamic programming (DP) matrices
    will be allocated and free'd on-the-fly. Hence, after return of this function, the recursively
    filled matrices are not available any more for any post-processing.  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `Lfold()` in the global namespace. The
        parameter `file` defaults to `NULL` and may be omitted. See e.g. :py:func:`RNA.Lfold()` in the
        :doc:`/api_python`.  

    Parameters
    ----------
    string : const char *
        The nucleic acid sequence  
    window_size : int
        The window size for locally optimal structures  
    file : FILE *
        The output file handle where predictions are written to (if NULL, output is written to stdout)  

    See Also
    --------
    RNA.fold_compound.mfe_window(), RNA.Lfoldz(), RNA.fold_compound.mfe_window_zscore()  

    Note
    ----
    In case you want to use the filled DP matrices for any subsequent post-processing step, or you
    require other conditions than specified by the default model details, use
    RNA.fold_compound.mfe_window(), and the
    data structure RNA.fold_compound() instead.  

    """
    return _RNA.Lfold(sequence, window_size, nullfile)

def aliLfold(alignment, window_size, nullfile=None):
    r"""


    **SWIG Wrapper Notes**
        This function is available as overloaded function `aliLfold()` in the global namespace. The
        parameter `fp` defaults to `NULL` and may be omitted. See e.g. :py:func:`RNA.aliLfold()` in the
        :doc:`/api_python`.  

    """
    return _RNA.aliLfold(alignment, window_size, nullfile)
ZSCORE_OPTIONS_NONE = _RNA.ZSCORE_OPTIONS_NONE
r"""


    """
ZSCORE_FILTER_ON = _RNA.ZSCORE_FILTER_ON
r"""


    """
ZSCORE_PRE_FILTER = _RNA.ZSCORE_PRE_FILTER
r"""


    """
ZSCORE_REPORT_SUBSUMED = _RNA.ZSCORE_REPORT_SUBSUMED
r"""


    """
ZSCORE_MODEL_DEFAULT = _RNA.ZSCORE_MODEL_DEFAULT
r"""


    """
ZSCORE_SETTINGS_DEFAULT = _RNA.ZSCORE_SETTINGS_DEFAULT
r"""


    """

def pf_fold(*args):
    return _RNA.pf_fold(*args)

def pf_circ_fold(*args):
    return _RNA.pf_circ_fold(*args)

def pf_add(dG1, dG2, kT=0):
    r"""


    """
    return _RNA.pf_add(dG1, dG2, kT)

def pf_float_precision():
    r"""


    Find out whether partition function computations are using single precision floating points.  

    Returns
    -------
    int  
        1 if single precision is used, 0 otherwise  

    See Also
    --------
    FLT_OR_DBL  

    """
    return _RNA.pf_float_precision()

def pbacktrack(sequence):
    r"""


    Sample a secondary structure from the Boltzmann ensemble according its probability.  

    **Precondition**
        st_back has to be set to 1 before calling pf_fold() or pf_fold_par()  pf_fold_par() or pf_fold()
        have to be called first to fill the partition function matrices  

    Parameters
    ----------
    sequence : char *
        The RNA sequence  

    Returns
    -------
    char *  
        A sampled secondary structure in dot-bracket notation  

    """
    return _RNA.pbacktrack(sequence)

def pbacktrack5(sequence, length):
    r"""


    Sample a sub-structure from the Boltzmann ensemble according its probability.  

    """
    return _RNA.pbacktrack5(sequence, length)

def pbacktrack_circ(sequence):
    r"""


    Sample a secondary structure of a circular RNA from the Boltzmann ensemble according its
    probability.  

    This function does the same as pbacktrack() but assumes the RNA molecule to be circular  

    **Precondition**
        st_back has to be set to 1 before calling pf_fold() or pf_fold_par()  pf_fold_par() or
        pf_circ_fold() have to be called first to fill the partition function matrices  

    .. deprecated:: 2.6.4
        Use RNA.fold_compound.pbacktrack() instead.  

    Parameters
    ----------
    sequence : char *
        The RNA sequence  

    Returns
    -------
    char *  
        A sampled secondary structure in dot-bracket notation  

    """
    return _RNA.pbacktrack_circ(sequence)

def free_pf_arrays():
    r"""


    Free arrays for the partition function recursions.  

    Call this function if you want to free all allocated memory associated with the partition function
    forward recursion.  

    .. deprecated:: 2.6.4
        See RNA.fold_compound() and its related functions for how to free memory occupied by the
        dynamic programming matrices  

    Note
    ----
    Successive calls of pf_fold(), pf_circ_fold() already check if they should free any memory from a
    previous run.  **OpenMP notice:**  
     This function should be called before leaving a thread in order to avoid leaking memory  

    **Postcondition**
        All memory allocated by pf_fold_par(), pf_fold() or pf_circ_fold() will be free'd  

    See Also
    --------
    pf_fold_par(), pf_fold(), pf_circ_fold()  

    """
    return _RNA.free_pf_arrays()

def update_pf_params(length):
    r"""


    Recalculate energy parameters.  

    Call this function to recalculate the pair matrix and energy parameters after a change in folding
    parameters like temperature  

    .. deprecated:: 2.6.4
        Use RNA.fold_compound.exp_params_subst() instead  

    """
    return _RNA.update_pf_params(length)

def mean_bp_distance(length):
    r"""


    Get the mean base pair distance of the last partition function computation.  

    .. deprecated:: 2.6.4
        Use RNA.fold_compound.mean_bp_distance() or RNA.mean_bp_distance_pr() instead!  

    Parameters
    ----------
    length : int

    Returns
    -------
    double  
        mean base pair distance in thermodynamic ensemble  

    See Also
    --------
    RNA.fold_compound.mean_bp_distance(), RNA.mean_bp_distance_pr()  

    """
    return _RNA.mean_bp_distance(length)

def init_pf_fold(length):
    r"""


    Allocate space for pf_fold()  

    .. deprecated:: 2.6.4
        This function is obsolete and will be removed soon!  

    """
    return _RNA.init_pf_fold(length)

def centroid(length, dist):
    r"""


    .. deprecated:: 2.6.4
        This function is deprecated and should not be used anymore as it is not threadsafe!  

    See Also
    --------
    get_centroid_struct_pl(), get_centroid_struct_pr()  

    """
    return _RNA.centroid(length, dist)

def co_pf_fold(*args):
    return _RNA.co_pf_fold(*args)

def get_concentrations(FcAB, FcAA, FcBB, FEA, FEB, A0, BO):
    return _RNA.get_concentrations(FcAB, FcAA, FcBB, FEA, FEB, A0, BO)

def free_co_pf_arrays():
    r"""


    Free the memory occupied by co_pf_fold()  

    .. deprecated:: 2.6.4
        This function will be removed for the new API soon! See RNA.fold_compound.pf_dimer(),
    RNA.fold_compound(),
        and RNA.fold_compound_free() for an alternative  

    """
    return _RNA.free_co_pf_arrays()

def update_co_pf_params(length):
    r"""


    Recalculate energy parameters.  

    This function recalculates all energy parameters given the current model settings.  

    .. deprecated:: 2.6.4
        Use RNA.fold_compound.exp_params_subst() instead!  

    Parameters
    ----------
    length : int
        Length of the current RNA sequence  

    """
    return _RNA.update_co_pf_params(length)

def get_pr(i, j):
    return _RNA.get_pr(i, j)

def get_centroid_struct_pl(length, dist, pl):
    r"""


    Get the centroid structure of the ensemble.  

    .. deprecated:: 2.6.4
        This function was renamed to RNA.centroid_from_plist()  

    """
    return _RNA.get_centroid_struct_pl(length, dist, pl)

def get_centroid_struct_pr(length, dist, pr):
    r"""


    Get the centroid structure of the ensemble.  

    .. deprecated:: 2.6.4
        This function was renamed to RNA.centroid_from_probs()  

    """
    return _RNA.get_centroid_struct_pr(length, dist, pr)

def MEA_from_plist(*args):
    r"""


    Compute a MEA (maximum expected accuracy) structure from a list of probabilities.  

    The algorithm maximizes the expected accuracy  

    .. math::

      A(S) = \sum_{(i,j) \in S} 2 \gamma p_{ij} + \sum_{i \notin S} p^u_{i}  

    Higher values of :math:`\gamma` result in more base pairs of lower probability and thus higher
    sensitivity. Low values of :math:`\gamma` result in structures containing only highly likely pairs
    (high specificity). The code of the MEA function also demonstrates the use of sparse dynamic
    programming scheme to reduce the time and memory complexity of folding.  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `MEA_from_plist`(gamma = 1., md = NULL). Note,
        that it returns the MEA structure and MEA value as a tuple (MEA_structure, MEA). See, e.g.
        :py:func:`RNA.MEA_from_plist()` in the :doc:`/api_python`.  

    Parameters
    ----------
    plist : RNA.ep() *
        A list of base pair probabilities the MEA structure is computed from  
    sequence : const char *
        The RNA sequence that corresponds to the list of probability values  
    gamma : double
        The weighting factor for base pairs vs. unpaired nucleotides  
    md : RNA.md() *
        A model details data structure (maybe NULL)  
    mea : float *
        A pointer to a variable where the MEA value will be written to  

    Returns
    -------
    char *  
        An MEA structure (or NULL on any error)  

    Note
    ----
    The unpaired probabilities :math:`p^u_{i} = 1 - \sum_{j \neq i} p_{ij}` are usually computed from
    the supplied pairing probabilities :math:`p_{ij}` as stored in `plist` entries of type
    RNA.PLIST_TYPE_BASEPAIR. To overwrite individual :math:`p^u_{o}` values simply add entries with
    type RNA.PLIST_TYPE_UNPAIRED  
     To include G-Quadruplex support, the corresponding field in `md` must be set.  

    """
    return _RNA.MEA_from_plist(*args)
class pbacktrack_mem(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _RNA.pbacktrack_mem_swiginit(self, _RNA.new_pbacktrack_mem())
    __swig_destroy__ = _RNA.delete_pbacktrack_mem

# Register pbacktrack_mem in _RNA:
_RNA.pbacktrack_mem_swigregister(pbacktrack_mem)

PBACKTRACK_DEFAULT = _RNA.PBACKTRACK_DEFAULT
r"""


    Boltzmann sampling flag indicating default backtracing mode.  

    See Also
    --------
    RNA.pbacktrack5_num(), RNA.pbacktrack5_cb(), RNA.pbacktrack5_resume(),
    RNA.pbacktrack5_resume_cb(), RNA.pbacktrack_num(), RNA.pbacktrack_cb(), RNA.pbacktrack_resume(),
    RNA.pbacktrack_resume_cb()  

    """
PBACKTRACK_NON_REDUNDANT = _RNA.PBACKTRACK_NON_REDUNDANT
r"""


    Boltzmann sampling flag indicating non-redundant backtracing mode.  

    This flag will turn the Boltzmann sampling into non-redundant backtracing mode along the lines of
    :cite:t:`michalik:2017`  

    See Also
    --------
    RNA.pbacktrack5_num(), RNA.pbacktrack5_cb(), RNA.pbacktrack5_resume(),
    RNA.pbacktrack5_resume_cb(), RNA.pbacktrack_num(), RNA.pbacktrack_cb(), RNA.pbacktrack_resume(),
    RNA.pbacktrack_resume_cb()  

    """

def pfl_fold(sequence, w, L, cutoff):
    r"""
    pfl_fold(std::string sequence, int w, int L, double cutoff) -> ElemProbVector


    Compute base pair probabilities using a sliding-window approach.  

    This is a simplified wrapper to RNA.fold_compound.probs_window() that given a nucleid acid sequence, a window
    size, a maximum base pair span, and a cutoff value computes the pair probabilities for any base pair
    in any window. The pair probabilities are returned as a list and the user has to take care to free()
    the memory occupied by the list.  

    Parameters
    ----------
    sequence : const char *
        The nucleic acid input sequence  
    window_size : int
        The size of the sliding window  
    max_bp_span : int
        The maximum distance along the backbone between two nucleotides that form a base pairs  
    cutoff : float
        A cutoff value that omits all pairs with lower probability  

    Returns
    -------
    RNA.ep() *  
        A list of base pair probabilities, terminated by an entry with RNA.ep().i and RNA.ep().j set
        to 0  

    See Also
    --------
    RNA.fold_compound.probs_window(), RNA.pfl_fold_cb(), RNA.pfl_fold_up()  

    Note
    ----
    This function uses default model settings! For custom model settings, we refer to the function
    RNA.fold_compound.probs_window().  
     In case of any computation errors, this function returns `NULL`  

    """
    return _RNA.pfl_fold(sequence, w, L, cutoff)

def pfl_fold_up(sequence, ulength, window_size, max_bp_span):
    r"""
    pfl_fold_up(std::string sequence, int ulength, int window_size, int max_bp_span) -> DoubleDoubleVector


    Compute probability of contiguous unpaired segments.  

    This is a simplified wrapper to RNA.fold_compound.probs_window() that given a nucleic acid sequence, a maximum
    length of unpaired segments (`ulength`), a window size, and a maximum base pair span computes the
    equilibrium probability of any segment not exceeding `ulength`. The probabilities to be unpaired are
    returned as a 1-based, 2-dimensional matrix with dimensions :math:`N \times M`, where :math:`N` is
    the length of the sequence and :math:`M` is the maximum segment length. As an example, the
    probability of a segment of size 5 starting at position 100 is stored in the matrix entry
    :math:`X[100][5]`.  

    It is the users responsibility to free the memory occupied by this matrix.  

    Parameters
    ----------
    sequence : const char *
        The nucleic acid input sequence  
    ulength : int
        The maximal length of an unpaired segment  
    window_size : int
        The size of the sliding window  
    max_bp_span : int
        The maximum distance along the backbone between two nucleotides that form a base pairs  

    Returns
    -------
    double **  
        The probabilities to be unpaired for any segment not exceeding `ulength`  

    Note
    ----
    This function uses default model settings! For custom model settings, we refer to the function
    RNA.fold_compound.probs_window().  

    """
    return _RNA.pfl_fold_up(sequence, ulength, window_size, max_bp_span)
EXT_LOOP = _RNA.EXT_LOOP
r"""


    Exterior loop.  

    """
HP_LOOP = _RNA.HP_LOOP
r"""


    Hairpin loop.  

    """
INT_LOOP = _RNA.INT_LOOP
r"""


    Internal loop.  

    """
MB_LOOP = _RNA.MB_LOOP
r"""


    Multibranch loop.  

    """
ANY_LOOP = _RNA.ANY_LOOP
r"""


    Any loop.  

    """
PROBS_WINDOW_BPP = _RNA.PROBS_WINDOW_BPP
r"""


    Trigger base pairing probabilities.  

    Passing this flag to RNA.fold_compound.probs_window() activates callback execution for base pairing
    probabilities. In turn, the corresponding callback receives this flag through the `type` argument
    whenever base pairing probabilities are provided.  

    Detailed information for the algorithm to compute unpaired probabilities can be taken from
    :cite:t:`bernhart:2005` .  

    See Also
    --------
    RNA.fold_compound.probs_window()  

    """
PROBS_WINDOW_UP = _RNA.PROBS_WINDOW_UP
r"""


    Trigger unpaired probabilities.  

    Passing this flag to RNA.fold_compound.probs_window() activates callback execution for unpaired probabilities. In
    turn, the corresponding callback receives this flag through the `type` argument whenever unpaired
    probabilities are provided.  

    Detailed information for the algorithm to compute unpaired probabilities can be taken from
    :cite:t:`bernhart:2011` .  

    See Also
    --------
    RNA.fold_compound.probs_window()  

    """
PROBS_WINDOW_STACKP = _RNA.PROBS_WINDOW_STACKP
r"""


    Trigger base pair stack probabilities.  

    Passing this flag to RNA.fold_compound.probs_window() activates callback execution for stacking probabilities. In
    turn, the corresponding callback receives this flag through the `type` argument whenever stack
    probabilities are provided.  

    **Bug**
        Currently, this flag is a placeholder doing nothing as the corresponding implementation for
        stack probability computation is missing.  

    See Also
    --------
    RNA.fold_compound.probs_window()  

    """
PROBS_WINDOW_UP_SPLIT = _RNA.PROBS_WINDOW_UP_SPLIT
r"""


    Trigger detailed unpaired probabilities split up into different loop type contexts.  

    Passing this flag to RNA.fold_compound.probs_window() activates callback execution for unpaired probabilities. In
    contrast to RNA.PROBS_WINDOW_UP this flag requests unpaired probabilities to be split up into
    different loop type contexts. In turn, the corresponding callback receives the RNA.PROBS_WINDOW_UP
    flag OR-ed together with the corresponding loop type, i.e.:  

    *   RNA.EXT_LOOP - Exterior loop.  
    *   RNA.HP_LOOP - Hairpin loop.  
    *   RNA.INT_LOOP - Internal loop.  
    *   RNA.MB_LOOP - Multibranch loop.  
    *   RNA.ANY_LOOP - Any loop.  

    See Also
    --------
    RNA.fold_compound.probs_window(), RNA.PROBS_WINDOW_UP  

    """
PROBS_WINDOW_PF = _RNA.PROBS_WINDOW_PF
r"""


    Trigger partition function.  

    Passing this flag to RNA.fold_compound.probs_window() activates callback execution for partition function. In
    turn, the corresponding callback receives this flag through it's `type` argument whenever partition
    function data is provided.  

    Note
    ----
    Instead of actually providing the partition function :math:`Z`, the callback is always provided with
    the corresponding enemble free energy :math:`\Delta G = - RT \ln Z`.  

    See Also
    --------
    RNA.fold_compound.probs_window()  

    """
class SOLUTION(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    energy = property(_RNA.SOLUTION_energy_get, _RNA.SOLUTION_energy_set)
    structure = property(_RNA.SOLUTION_structure_get, _RNA.SOLUTION_structure_set)

    def get(self, i):
        return _RNA.SOLUTION_get(self, i)

    def size(self):
        return _RNA.SOLUTION_size(self)
    __swig_destroy__ = _RNA.delete_SOLUTION

    def __init__(self):
        _RNA.SOLUTION_swiginit(self, _RNA.new_SOLUTION())

# Register SOLUTION in _RNA:
_RNA.SOLUTION_swigregister(SOLUTION)

class subopt_solution(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    energy = property(_RNA.subopt_solution_energy_get, _RNA.subopt_solution_energy_set)
    structure = property(_RNA.subopt_solution_structure_get, _RNA.subopt_solution_structure_set)

    def __str__(self):
        return _RNA.subopt_solution___str__(self)

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 


    def __init__(self):
        _RNA.subopt_solution_swiginit(self, _RNA.new_subopt_solution())
    __swig_destroy__ = _RNA.delete_subopt_solution

# Register subopt_solution in _RNA:
_RNA.subopt_solution_swigregister(subopt_solution)

class SuboptVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.SuboptVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.SuboptVector___nonzero__(self)

    def __bool__(self):
        return _RNA.SuboptVector___bool__(self)

    def __len__(self):
        return _RNA.SuboptVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.SuboptVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.SuboptVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.SuboptVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.SuboptVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.SuboptVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.SuboptVector___setitem__(self, *args)

    def pop(self):
        return _RNA.SuboptVector_pop(self)

    def append(self, x):
        return _RNA.SuboptVector_append(self, x)

    def empty(self):
        return _RNA.SuboptVector_empty(self)

    def size(self):
        return _RNA.SuboptVector_size(self)

    def swap(self, v):
        return _RNA.SuboptVector_swap(self, v)

    def begin(self):
        return _RNA.SuboptVector_begin(self)

    def end(self):
        return _RNA.SuboptVector_end(self)

    def rbegin(self):
        return _RNA.SuboptVector_rbegin(self)

    def rend(self):
        return _RNA.SuboptVector_rend(self)

    def clear(self):
        return _RNA.SuboptVector_clear(self)

    def get_allocator(self):
        return _RNA.SuboptVector_get_allocator(self)

    def pop_back(self):
        return _RNA.SuboptVector_pop_back(self)

    def erase(self, *args):
        return _RNA.SuboptVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.SuboptVector_swiginit(self, _RNA.new_SuboptVector(*args))

    def push_back(self, x):
        return _RNA.SuboptVector_push_back(self, x)

    def front(self):
        return _RNA.SuboptVector_front(self)

    def back(self):
        return _RNA.SuboptVector_back(self)

    def assign(self, n, x):
        return _RNA.SuboptVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.SuboptVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.SuboptVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.SuboptVector_reserve(self, n)

    def capacity(self):
        return _RNA.SuboptVector_capacity(self)
    __swig_destroy__ = _RNA.delete_SuboptVector

# Register SuboptVector in _RNA:
_RNA.SuboptVector_swigregister(SuboptVector)


def subopt(*args):
    return _RNA.subopt(*args)
MAXDOS = _RNA.MAXDOS
r"""


    Maximum density of states discretization for subopt.  

    """

def zukersubopt(string):
    r"""


    Compute Zuker type suboptimal structures.  

    Compute Suboptimal structures according to M. Zuker, i.e. for every possible base pair the minimum
    energy structure containing the resp. base pair. Returns a list of these structures and their
    energies.  

    .. deprecated:: 2.6.4
        use RNA.zukersubopt() instead  

    Parameters
    ----------
    string : const char *
        RNA sequence  

    Returns
    -------
    SOLUTION *  
        List of zuker suboptimal structures  

    """
    return _RNA.zukersubopt(string)

def inverse_fold(start, target):
    r"""
    inverse_fold(char * start, char const * target) -> char *


    Find sequences with predefined structure.  

    This function searches for a sequence with minimum free energy structure provided in the parameter
    'target', starting with sequence 'start'. It returns 0 if the search was successful, otherwise a
    structure distance in terms of the energy difference between the search result and the actual target
    'target' is returned. The found sequence is returned in 'start'. If give_up is set to 1, the
    function will return as soon as it is clear that the search will be unsuccessful, this speeds up the
    algorithm if you are only interested in exact solutions.  

    Parameters
    ----------
    start : char *
        The start sequence  
    target : const char *
        The target secondary structure in dot-bracket notation  

    Returns
    -------
    float  
        The distance to the target in case a search was unsuccessful, 0 otherwise  

    """
    return _RNA.inverse_fold(start, target)

def inverse_pf_fold(start, target):
    r"""
    inverse_pf_fold(char * start, char const * target) -> char *


    Find sequence that maximizes probability of a predefined structure.  

    This function searches for a sequence with maximum probability to fold into the provided structure
    'target' using the partition function algorithm. It returns :math:`-kT \cdot \log(p)` where
    :math:`p` is the frequency of 'target' in the ensemble of possible structures. This is usually much
    slower than inverse_fold().  

    Parameters
    ----------
    start : char *
        The start sequence  
    target : const char *
        The target secondary structure in dot-bracket notation  

    Returns
    -------
    float  
        The distance to the target in case a search was unsuccessful, 0 otherwise  

    """
    return _RNA.inverse_pf_fold(start, target)

def b2HIT(structure):
    r"""


    Converts the full structure from bracket notation to the HIT notation including root.  

    .. deprecated:: 2.6.4
        See RNA.db_to_tree_string() and RNA.STRUCTURE_TREE_HIT for a replacement  

    Parameters
    ----------
    structure : const char *

    Returns
    -------
    char *  

    """
    return _RNA.b2HIT(structure)

def b2C(structure):
    r"""


    Converts the full structure from bracket notation to the a coarse grained notation using the 'H' 'B'
    'I' 'M' and 'R' identifiers.  

    .. deprecated:: 2.6.4
        See RNA.db_to_tree_string() and RNA.STRUCTURE_TREE_SHAPIRO_SHORT for a replacement  

    Parameters
    ----------
    structure : const char *

    Returns
    -------
    char *  

    """
    return _RNA.b2C(structure)

def b2Shapiro(structure):
    r"""


    Converts the full structure from bracket notation to the *weighted* coarse grained notation using
    the 'H' 'B' 'I' 'M' 'S' 'E' and 'R' identifiers.  

    .. deprecated:: 2.6.4
        See RNA.db_to_tree_string() and RNA.STRUCTURE_TREE_SHAPIRO_WEIGHT for a replacement  

    Parameters
    ----------
    structure : const char *

    Returns
    -------
    char *  

    """
    return _RNA.b2Shapiro(structure)

def add_root(arg1):
    r"""


    Adds a root to an un-rooted tree in any except bracket notation.  

    Parameters
    ----------
    structure : const char *

    Returns
    -------
    char *  

    """
    return _RNA.add_root(arg1)

def expand_Shapiro(coarse):
    r"""


    Inserts missing 'S' identifiers in unweighted coarse grained structures as obtained from b2C().  

    Parameters
    ----------
    coarse : const char *

    Returns
    -------
    char *  

    """
    return _RNA.expand_Shapiro(coarse)

def expand_Full(structure):
    r"""


    Convert the full structure from bracket notation to the expanded notation including root.  

    Parameters
    ----------
    structure : const char *

    Returns
    -------
    char *  

    """
    return _RNA.expand_Full(structure)

def unexpand_Full(ffull):
    r"""


    Restores the bracket notation from an expanded full or HIT tree, that is any tree using only
    identifiers 'U' 'P' and 'R'.  

    Parameters
    ----------
    ffull : const char *

    Returns
    -------
    char *  

    """
    return _RNA.unexpand_Full(ffull)

def unweight(wcoarse):
    r"""


    Strip weights from any weighted tree.  

    Parameters
    ----------
    wcoarse : const char *

    Returns
    -------
    char *  

    """
    return _RNA.unweight(wcoarse)

def unexpand_aligned_F(align):
    r"""


    Converts two aligned structures in expanded notation.  

    Takes two aligned structures as produced by tree_edit_distance() function back to bracket notation
    with '_' as the gap character. The result overwrites the input.  

    Parameters
    ----------
    align : char *  

    """
    return _RNA.unexpand_aligned_F(align)

def parse_structure(structure):
    r"""


    Collects a statistic of structure elements of the full structure in bracket notation.  

    The function writes to the following global variables: loop_size, loop_degree, helix_size, loops,
    pairs, unpaired  

    Parameters
    ----------
    structure : const char *  

    """
    return _RNA.parse_structure(structure)

def make_tree(struc):
    r"""


    Constructs a Tree ( essentially the postorder list ) of the structure 'struc', for use in
    tree_edit_distance().  

    Parameters
    ----------
    struc : char *
        may be any rooted structure representation.  

    Returns
    -------
    Tree *  

    """
    return _RNA.make_tree(struc)

def tree_edit_distance(T1, T2):
    r"""


    Calculates the edit distance of the two trees.  

    Parameters
    ----------
    T1 : Tree *
    T2 : Tree *

    Returns
    -------
    float  

    """
    return _RNA.tree_edit_distance(T1, T2)

def print_tree(t):
    r"""


    Print a tree (mainly for debugging)  

    """
    return _RNA.print_tree(t)

def free_tree(t):
    r"""


    Free the memory allocated for Tree t.  

    Parameters
    ----------
    t : Tree *  

    """
    return _RNA.free_tree(t)

def Make_swString(string):
    r"""


    Convert a structure into a format suitable for string_edit_distance().  

    Parameters
    ----------
    string : char *

    Returns
    -------
    swString *  

    """
    return _RNA.Make_swString(string)

def string_edit_distance(T1, T2):
    r"""


    Calculate the string edit distance of T1 and T2.  

    Parameters
    ----------
    T1 : swString *
    T2 : swString *

    Returns
    -------
    float  

    """
    return _RNA.string_edit_distance(T1, T2)

def profile_edit_distance(T1, T2):
    r"""


    Align the 2 probability profiles T1, T2  
    .  

    This is like a Needleman-Wunsch alignment, we should really use affine gap-costs ala Gotoh  

    """
    return _RNA.profile_edit_distance(T1, T2)

def Make_bp_profile_bppm(bppm, length):
    r"""


    condense pair probability matrix into a vector containing probabilities for unpaired, upstream
    paired and downstream paired.  

    This resulting probability profile is used as input for profile_edit_distance  

    Parameters
    ----------
    bppm : FLT_OR_DBL *
        A pointer to the base pair probability matrix  
    length : int
        The length of the sequence  

    Returns
    -------
    float *  
        The bp profile  

    """
    return _RNA.Make_bp_profile_bppm(bppm, length)

def print_bppm(T):
    r"""


    print string representation of probability profile  

    """
    return _RNA.print_bppm(T)

def free_profile(T):
    r"""


    free space allocated in Make_bp_profile  

    Backward compatibility only. You can just use plain free()  

    """
    return _RNA.free_profile(T)

def Make_bp_profile(length):
    r"""


    .. deprecated:: 2.6.4
        This function is deprecated and will be removed soon! See Make_bp_profile_bppm() for a
        replacement  

    See Also
    --------
    Make_bp_profile_bppm()  

    Note
    ----
    This function is NOT threadsafe  

    """
    return _RNA.Make_bp_profile(length)

def deref_any(ptr, index):
    return _RNA.deref_any(ptr, index)

def get_aligned_line(arg1):
    return _RNA.get_aligned_line(arg1)

def file_SHAPE_read(file_name, length, default_value):
    r"""


    Read data from a given SHAPE reactivity input file.  

    This function parses the informations from a given file and stores the result in the preallocated
    string sequence and the double array values.  

    Parameters
    ----------
    file_name : const char *
        Path to the constraints file  
    length : int
        Length of the sequence (file entries exceeding this limit will cause an error)  
    default_value : double
        Value for missing indices  
    sequence : char *
        Pointer to an array used for storing the sequence obtained from the SHAPE reactivity file  
    values : double *
        Pointer to an array used for storing the values obtained from the SHAPE reactivity file  

    """
    return _RNA.file_SHAPE_read(file_name, length, default_value)

def file_fasta_read(file, options=0):
    r"""
    file_fasta_read(FILE * file, unsigned int options=0) -> int


    Get a (fasta) data set from a file or stdin.  

    This function may be used to obtain complete datasets from a filehandle or stdin. A dataset is
    always defined to contain at least a sequence. If data starts with a fasta header, i.e. a line like  

        >some header info  then RNA.file_fasta_read_record() will assume that the sequence that follows
    the header may span over several lines. To disable this behavior and to assign a single line to the
    argument 'sequence' one can pass RNA.INPUT_NO_SPAN in the 'options' argument. If no fasta header is
    read in the beginning of a data block, a sequence must not span over multiple lines!  

    Unless the options RNA.INPUT_NOSKIP_COMMENTS or RNA.INPUT_NOSKIP_BLANK_LINES are passed, a
    sequence may be interrupted by lines starting with a comment character or empty lines.  
     A sequence is regarded as completely read if it was either assumed to not span over multiple lines,
    a secondary structure or structure constraint follows the sequence on the next line, or a new header
    marks the beginning of a new sequence...  

    All lines following the sequence (this includes comments) that do not initiate a new dataset
    according to the above definition are available through the line-array 'rest'. Here one can usually
    find the structure constraint or other information belonging to the current dataset. Filling of
    'rest' may be prevented by passing RNA.INPUT_NO_REST to the options argument.  

    The main purpose of this function is to be able to easily parse blocks of data in the header of a
    loop where all calculations for the appropriate data is done inside the loop. The loop may be then
    left on certain return values, e.g.:  


    In the example above, the while loop will be terminated when RNA.file_fasta_read_record() returns
    either an error, EOF, or a user initiated quit request.  

    As long as data is read from stdin (we are passing NULL as the file pointer), the id is printed if
    it is available for the current block of data. The sequence will be printed in any case and if some
    more lines belong to the current block of data each line will be printed as well.  

    Parameters
    ----------
    header : char **
        A pointer which will be set such that it points to the header of the record  
    sequence : char **
        A pointer which will be set such that it points to the sequence of the record  
    rest : char ***
        A pointer which will be set such that it points to an array of lines which also belong to the
        record  
    file : FILE *
        A file handle to read from (if NULL, this function reads from stdin)  
    options : unsigned int
        Some options which may be passed to alter the behavior of the function, use 0 for no options  

    Returns
    -------
    unsigned int  
        A flag with information about what the function actually did read  

    Note
    ----
    This function will exit any program with an error message if no sequence could be read!  
     This function is NOT threadsafe! It uses a global variable to store information about the next data
    block. Do not forget to free the memory occupied by header, sequence and rest!  

    """
    return _RNA.file_fasta_read(file, options)

def file_RNAstrand_db_read_record(fp, options=0):
    r"""


    """
    return _RNA.file_RNAstrand_db_read_record(fp, options)

def file_connect_read_record(fp, remainder, options=0):
    r"""


    """
    return _RNA.file_connect_read_record(fp, remainder, options)

def extract_record_rest_structure(lines, length, option):
    r"""


    """
    return _RNA.extract_record_rest_structure(lines, length, option)

def read_record(header, sequence, rest, options):
    r"""


    Get a data record from stdin.  

    .. deprecated:: 2.6.4
        This function is deprecated! Use RNA.file_fasta_read_record() as a replacment.  

    """
    return _RNA.read_record(header, sequence, rest, options)

def get_multi_input_line(string, options):
    r"""


    """
    return _RNA.get_multi_input_line(string, options)

def file_msa_detect_format(*args, **kwargs):
    r"""
    file_msa_detect_format(std::string filename, unsigned int options=) -> unsigned int


    Detect the format of a multiple sequence alignment file.  

    This function attempts to determine the format of a file that supposedly contains a multiple
    sequence alignment (MSA). This is useful in cases where a MSA file contains more than a single
    record and therefore RNA.file_msa_read() can not be applied, since it only retrieves the first.
    Here, one can try to guess the correct file format using this function and then loop over the file,
    record by record using one of the low-level record retrieval functions for the corresponding MSA
    file format.  

    **SWIG Wrapper Notes**
        This function exists as an overloaded version where the `options` parameter may be omitted! In
        that case, the `options` parameter defaults to RNA.FILE_FORMAT_MSA_DEFAULT. See, e.g.
        :py:func:`RNA.file_msa_detect_format()` in the :doc:`/api_python` .  

    Parameters
    ----------
    filename : const char *
        The name of input file that contains the alignment  
    options : unsigned int
        Options to manipulate the behavior of this function  

    Returns
    -------
    unsigned int  
        The MSA file format, or RNA.FILE_FORMAT_MSA_UNKNOWN  

    See Also
    --------
    RNA.file_msa_read(), RNA.file_stockholm_read_record(), RNA.file_clustal_read_record(),
    RNA.file_fasta_read_record()  

    Note
    ----
    This function parses the entire first record within the specified file. As a result, it returns
    RNA.FILE_FORMAT_MSA_UNKNOWN not only if it can't detect the file's format, but also in cases where
    the file doesn't contain sequences!  

    """
    return _RNA.file_msa_detect_format(*args, **kwargs)

def file_msa_write(*args, **kwargs):
    r"""
    file_msa_write(std::string filename, StringVector names, StringVector alignment, std::string id="", std::string structure="", std::string source="", unsigned int options=VRNA_FILE_FORMAT_MSA_STOCKHOLM|VRNA_FILE_FORMAT_MSA_APPEND) -> int


    Write multiple sequence alignment file.  

    **SWIG Wrapper Notes**
        In the target scripting language, this function exists as a set of overloaded versions, where
        the last four parameters may be omitted. If the `options` parameter is missing the options
        default to (RNA.FILE_FORMAT_MSA_STOCKHOLM | RNA.FILE_FORMAT_MSA_APPEND). See, e.g.
        :py:func:`RNA.file_msa_write()` in the :doc:`/api_python` .  

    Parameters
    ----------
    filename : const char *
        The output filename  
    names : const char **
        The array of sequence names / identifies  
    aln : const char **
        The array of aligned sequences  
    id : const char *
        An optional ID for the alignment  
    structure : const char *
        An optional consensus structure  
    source : const char *
        A string describing the source of the alignment  
    options : unsigned int
        Options to manipulate the behavior of this function  

    Returns
    -------
    int  
        Non-null upon successfully writing the alignment to file  

    See Also
    --------
    RNA.FILE_FORMAT_MSA_STOCKHOLM, RNA.FILE_FORMAT_MSA_APPEND, RNA.FILE_FORMAT_MSA_MIS  

    Note
    ----
    Currently, we only support msa-formats-stockholm output  

    """
    return _RNA.file_msa_write(*args, **kwargs)

def file_msa_read(*args, **kwargs):
    r"""
    file_msa_read(std::string filename, unsigned int options=) -> int


    Read a multiple sequence alignment from file.  

    This function reads the (first) multiple sequence alignment from an input file. The read alignment
    is split into the sequence id/name part and the actual sequence information and stored in memory as
    arrays of ids/names and sequences. If the alignment file format allows for additional information,
    such as an ID of the entire alignment or consensus structure information, this data is retrieved as
    well and made available. The `options` parameter allows to specify the set of alignment file formats
    that should be used to retrieve the data. If 0 is passed as option, the list of alignment file
    formats defaults to RNA.FILE_FORMAT_MSA_DEFAULT.  

    Currently, the list of parsable multiple sequence alignment file formats consists of:  

    *   msa-formats-clustal  
    *   msa-formats-stockholm  
    *   msa-formats-fasta  
    *   msa-formats-maf  

    **SWIG Wrapper Notes**
        In the target scripting language, only the first and last argument, `filename` and `options`,
        are passed to the corresponding function. The other arguments, which serve as output in the
        C-library, are available as additional return values. This function exists as an overloaded
        version where the `options` parameter may be omitted! In that case, the `options` parameter
        defaults to RNA.FILE_FORMAT_MSA_STOCKHOLM. See, e.g.   :py:func:`RNA.file_msa_read()` in the
        :doc:`/api_python`  and   :ref:`examples/python:parsing alignments`  in the Python examples.  

    Parameters
    ----------
    filename : const char *
        The name of input file that contains the alignment  
    names : char ***
        An address to the pointer where sequence identifiers should be written to  
    aln : char ***
        An address to the pointer where aligned sequences should be written to  
    id : char **
        An address to the pointer where the alignment ID should be written to (Maybe NULL)  
    structure : char **
        An address to the pointer where consensus structure information should be written to (Maybe
        NULL)  
    options : unsigned int
        Options to manipulate the behavior of this function  

    Returns
    -------
    int  
        The number of sequences in the alignment, or -1 if no alignment record could be found  

    See Also
    --------
    RNA.file_msa_read_record(), RNA.FILE_FORMAT_MSA_CLUSTAL, RNA.FILE_FORMAT_MSA_STOCKHOLM,
    RNA.FILE_FORMAT_MSA_FASTA, RNA.FILE_FORMAT_MSA_MAF, RNA.FILE_FORMAT_MSA_DEFAULT,
    RNA.FILE_FORMAT_MSA_NOCHECK  

    Note
    ----
    After successfully reading an alignment, this function performs a validation of the data that
    includes uniqueness of the sequence identifiers, and equal sequence lengths. This check can be
    deactivated by passing RNA.FILE_FORMAT_MSA_NOCHECK in the `options` parameter.  
     It is the users responsibility to free any memory occupied by the output arguments `names`, `aln`,
    `id`, and `structure` after calling this function. The function automatically sets the latter two
    arguments to `NULL` in case no corresponding data could be retrieved from the input alignment.  

    """
    return _RNA.file_msa_read(*args, **kwargs)

def file_msa_read_record(*args, **kwargs):
    r"""
    file_msa_read_record(FILE * filehandle, unsigned int options=) -> int


    Read a multiple sequence alignment from file handle.  

    Similar to RNA.file_msa_read(), this function reads a multiple sequence alignment from an input
    file handle. Since using a file handle, this function is not limited to the first alignment record,
    but allows for looping over all alignments within the input.  

    The read alignment is split into the sequence id/name part and the actual sequence information and
    stored in memory as arrays of ids/names and sequences. If the alignment file format allows for
    additional information, such as an ID of the entire alignment or consensus structure information,
    this data is retrieved as well and made available. The `options` parameter allows to specify the
    alignment file format used to retrieve the data. A single format must be specified here, see
    RNA.file_msa_detect_format() for helping to determine the correct MSA file format.  

    Currently, the list of parsable multiple sequence alignment file formats consists of:  

    *   msa-formats-clustal  
    *   msa-formats-stockholm  
    *   msa-formats-fasta  
    *   msa-formats-maf  

    **SWIG Wrapper Notes**
        In the target scripting language, only the first and last argument, `fp` and `options`, are
        passed to the corresponding function. The other arguments, which serve as output in the
        C-library, are available as additional return values. This function exists as an overloaded
        version where the `options` parameter may be omitted! In that case, the `options` parameter
        defaults to RNA.FILE_FORMAT_MSA_STOCKHOLM. See, e.g.   :py:func:`RNA.file_msa_read_record()` in
        the :doc:`/api_python`  and   :ref:`examples/python:parsing alignments`  in the Python examples.  

    Parameters
    ----------
    fp : FILE *
        The file pointer the data will be retrieved from  
    names : char ***
        An address to the pointer where sequence identifiers should be written to  
    aln : char ***
        An address to the pointer where aligned sequences should be written to  
    id : char **
        An address to the pointer where the alignment ID should be written to (Maybe NULL)  
    structure : char **
        An address to the pointer where consensus structure information should be written to (Maybe
        NULL)  
    options : unsigned int
        Options to manipulate the behavior of this function  

    Returns
    -------
    int  
        The number of sequences in the alignment, or -1 if no alignment record could be found  

    See Also
    --------
    RNA.file_msa_read(), RNA.file_msa_detect_format(), RNA.FILE_FORMAT_MSA_CLUSTAL,
    RNA.FILE_FORMAT_MSA_STOCKHOLM, RNA.FILE_FORMAT_MSA_FASTA, RNA.FILE_FORMAT_MSA_MAF,
    RNA.FILE_FORMAT_MSA_DEFAULT, RNA.FILE_FORMAT_MSA_NOCHECK  

    Note
    ----
    After successfully reading an alignment, this function performs a validation of the data that
    includes uniqueness of the sequence identifiers, and equal sequence lengths. This check can be
    deactivated by passing RNA.FILE_FORMAT_MSA_NOCHECK in the `options` parameter.  
     It is the users responsibility to free any memory occupied by the output arguments `names`, `aln`,
    `id`, and `structure` after calling this function. The function automatically sets the latter two
    arguments to `NULL` in case no corresponding data could be retrieved from the input alignment.  

    """
    return _RNA.file_msa_read_record(*args, **kwargs)
FILE_FORMAT_MSA_CLUSTAL = _RNA.FILE_FORMAT_MSA_CLUSTAL
r"""


    Option flag indicating ClustalW formatted files.  

    See Also
    --------
    RNA.file_msa_read(), RNA.file_msa_read_record(), RNA.file_msa_detect_format()  

    """
FILE_FORMAT_MSA_DEFAULT = _RNA.FILE_FORMAT_MSA_DEFAULT
r"""


    Option flag indicating the set of default file formats.  

    See Also
    --------
    RNA.file_msa_read(), RNA.file_msa_read_record(), RNA.file_msa_detect_format()  

    """
FILE_FORMAT_MSA_FASTA = _RNA.FILE_FORMAT_MSA_FASTA
r"""


    Option flag indicating FASTA (Pearson) formatted files.  

    See Also
    --------
    RNA.file_msa_read(), RNA.file_msa_read_record(), RNA.file_msa_detect_format()  

    """
FILE_FORMAT_MSA_MAF = _RNA.FILE_FORMAT_MSA_MAF
r"""


    Option flag indicating MAF formatted files.  

    See Also
    --------
    RNA.file_msa_read(), RNA.file_msa_read_record(), RNA.file_msa_detect_format()  

    """
FILE_FORMAT_MSA_NOCHECK = _RNA.FILE_FORMAT_MSA_NOCHECK
r"""


    Option flag to disable validation of the alignment.  

    See Also
    --------
    RNA.file_msa_read(), RNA.file_msa_read_record()  

    """
FILE_FORMAT_MSA_STOCKHOLM = _RNA.FILE_FORMAT_MSA_STOCKHOLM
r"""


    Option flag indicating Stockholm 1.0 formatted files.  

    See Also
    --------
    RNA.file_msa_read(), RNA.file_msa_read_record(), RNA.file_msa_detect_format()  

    """
FILE_FORMAT_MSA_MIS = _RNA.FILE_FORMAT_MSA_MIS
r"""


    Option flag indicating most informative sequence (MIS) output.  

    The default reference sequence output for an alignment is simply a consensus sequence. This flag
    allows to write the most informative equence (MIS) instead.  

    See Also
    --------
    RNA.file_msa_write()  

    """
FILE_FORMAT_MSA_UNKNOWN = _RNA.FILE_FORMAT_MSA_UNKNOWN
r"""


    Return flag of RNA.file_msa_detect_format() to indicate unknown or malformatted alignment.  

    See Also
    --------
    RNA.file_msa_detect_format()  

    """
FILE_FORMAT_MSA_QUIET = _RNA.FILE_FORMAT_MSA_QUIET
r"""


    Option flag to suppress unnecessary spam messages on `stderr`  

    See Also
    --------
    RNA.file_msa_read(), RNA.file_msa_read_record()  

    """
FILE_FORMAT_MSA_SILENT = _RNA.FILE_FORMAT_MSA_SILENT
r"""


    Option flag to completely silence any warnings on `stderr`  

    See Also
    --------
    RNA.file_msa_read(), RNA.file_msa_read_record()  

    """
FILE_FORMAT_MSA_APPEND = _RNA.FILE_FORMAT_MSA_APPEND
r"""


    Option flag indicating to append data to a multiple sequence alignment file rather than overwriting
    it.  

    See Also
    --------
    RNA.file_msa_write()  

    """

def seq_encode(sequence, md_p=None):
    r"""
    seq_encode(std::string sequence, md md_p=None) -> IntVector


    Get a numerical representation of the nucleotide sequence.  

    **SWIG Wrapper Notes**
        In the target scripting language, this function is wrapped as overloaded function `seq_encode()`
        where the last parameter, the `model_details` data structure, is optional. If it is omitted,
        default model settings are applied, i.e. default nucleotide letter conversion. The wrapped
        function returns a list/tuple of integer representations of the input sequence. See, e.g.
        :py:func:`RNA.seq_encode()` in the :doc:`/api_python`.  

    Parameters
    ----------
    sequence : const char *
        The input sequence in upper-case letters  
    md : RNA.md() *
        A pointer to a RNA.md() data structure that specifies the conversion type  

    Returns
    -------
    short *  
        A list of integer encodings for each sequence letter (1-based). Position 0 denotes the length of
        the list  

    """
    return _RNA.seq_encode(sequence, md_p)
SEQUENCE_RNA = _RNA.SEQUENCE_RNA
r"""


    """
SEQUENCE_DNA = _RNA.SEQUENCE_DNA
r"""


    """
UNSTRUCTURED_DOMAIN_EXT_LOOP = _RNA.UNSTRUCTURED_DOMAIN_EXT_LOOP
r"""


    Flag to indicate ligand bound to unpiared stretch in the exterior loop.  

    """
UNSTRUCTURED_DOMAIN_HP_LOOP = _RNA.UNSTRUCTURED_DOMAIN_HP_LOOP
r"""


    Flag to indicate ligand bound to unpaired stretch in a hairpin loop.  

    """
UNSTRUCTURED_DOMAIN_INT_LOOP = _RNA.UNSTRUCTURED_DOMAIN_INT_LOOP
r"""


    Flag to indicate ligand bound to unpiared stretch in an interior loop.  

    """
UNSTRUCTURED_DOMAIN_MB_LOOP = _RNA.UNSTRUCTURED_DOMAIN_MB_LOOP
r"""


    Flag to indicate ligand bound to unpiared stretch in a multibranch loop.  

    """
UNSTRUCTURED_DOMAIN_ALL_LOOPS = _RNA.UNSTRUCTURED_DOMAIN_ALL_LOOPS
r"""


    Flag to indicate ligand bound to unpiared stretch in any loop (convenience macro)  

    """
UNSTRUCTURED_DOMAIN_MOTIF = _RNA.UNSTRUCTURED_DOMAIN_MOTIF
r"""


    Flag to indicate ligand binding without additional unbound nucleotides (motif-only)  

    """
class cmd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _RNA.cmd_swiginit(self, _RNA.new_cmd())
    __swig_destroy__ = _RNA.delete_cmd

# Register cmd in _RNA:
_RNA.cmd_swigregister(cmd)


def file_commands_read(*args, **kwargs):
    r"""
    file_commands_read(std::string filename, unsigned int options=) -> cmd


    Extract a list of commands from a command file.  

    Read a list of commands specified in the input file and return them as list of abstract commands  

    **SWIG Wrapper Notes**
        This function is available as global function `file_commands_read()`. See, e.g.
        :py:func:`RNA.file_commands_read()` in the :doc:`/api_python` .  

    Parameters
    ----------
    filename : const char *
        The filename  
    options : unsigned int
        Options to limit the type of commands read from the file  

    Returns
    -------
    RNA.cmd()  
        A list of abstract commands  

    See Also
    --------
    RNA.fold_compound.commands_apply(), RNA.file_commands_apply(), RNA.commands_free()  

    """
    return _RNA.file_commands_read(*args, **kwargs)
CMD_PARSE_DEFAULTS = _RNA.CMD_PARSE_DEFAULTS
r"""


    Command parse/apply flag indicating default set of commands.  

    See Also
    --------
    RNA.cmd(), RNA.file_commands_read(), RNA.file_commands_apply(), RNA.fold_compound.commands_apply()  

    """
CMD_PARSE_HC = _RNA.CMD_PARSE_HC
r"""


    Command parse/apply flag indicating hard constraints.  

    See Also
    --------
    RNA.cmd(), RNA.file_commands_read(), RNA.file_commands_apply(), RNA.fold_compound.commands_apply()  

    """
CMD_PARSE_SC = _RNA.CMD_PARSE_SC
r"""


    Command parse/apply flag indicating soft constraints.  

    See Also
    --------
    RNA.cmd(), RNA.file_commands_read(), RNA.file_commands_apply(), RNA.fold_compound.commands_apply()  

    """
CMD_PARSE_SD = _RNA.CMD_PARSE_SD
r"""


    Command parse/apply flag indicating structured domains.  

    See Also
    --------
    RNA.cmd(), RNA.file_commands_read(), RNA.file_commands_apply(), RNA.fold_compound.commands_apply()  

    """
CMD_PARSE_UD = _RNA.CMD_PARSE_UD
r"""


    Command parse/apply flag indicating unstructured domains.  

    See Also
    --------
    RNA.cmd(), RNA.file_commands_read(), RNA.file_commands_apply(), RNA.fold_compound.commands_apply()  

    """

def enumerate_necklaces(entity_counts):
    r"""


    Enumerate all necklaces with fixed content.  

    This function implements *A fast algorithm to generate necklaces with fixed content* as published by
    :cite:t:`sawada:2003` .  

    The function receives a list of counts (the elements on the necklace) for each type of object within
    a necklace. The list starts at index 0 and ends with an entry that has a count of 0. The algorithm
    then enumerates all non-cyclic permutations of the content, returned as a list of necklaces. This
    list, again, is zero-terminated, i.e. the last entry of the list is a `NULL` pointer.  

    **SWIG Wrapper Notes**
        This function is available as global function `enumerate_necklaces()` which accepts lists input,
        an produces list of lists output. See, e.g.   :py:func:`RNA.enumerate_necklaces()` in the
        :doc:`/api_python` .  

    Parameters
    ----------
    type_counts : const unsigned int *
        A 0-terminated list of entity counts  

    Returns
    -------
    unsigned int **  
        A list of all non-cyclic permutations of the entities  

    """
    return _RNA.enumerate_necklaces(entity_counts)

def rotational_symmetry(*args):
    r"""


    Determine the order of rotational symmetry for a NULL-terminated string of ASCII characters.  

    The algorithm applies a fast search of the provided string within itself, assuming the end of the
    string wraps around to connect with it's start. For example, a string of the form `AABAAB` has
    rotational symmetry of order `2`  

    If the argument `positions` is not `NULL`, the function stores an array of string start positions
    for rotational shifts that map the string back onto itself. This array has length of order of
    rotational symmetry, i.e. the number returned by this function. The first element `positions`[0]
    always contains a shift value of `0` representing the trivial rotation.  

    **SWIG Wrapper Notes**
        This function is available as overloaded global function `rotational_symmetry()`. It merges the
        functionalities of RNA.rotational_symmetry(), RNA.rotational_symmetry_pos(),
        RNA.rotational_symmetry_num(), and RNA.rotational_symmetry_pos_num(). In contrast to our
        C-implementation, this function doesn't return the order of rotational symmetry as a single
        value, but returns a list of cyclic permutation shifts that result in a rotationally symmetric
        string. The length of the list then determines the order of rotational symmetry. See, e.g.
        :py:func:`RNA.rotational_symmetry()` in the :doc:`/api_python` .  

    Parameters
    ----------
    string : const char *
        A NULL-terminated string of characters  
    positions : unsigned int **
        A pointer to an (undefined) list of alternative string start positions that lead to an identity
        mapping (may be NULL)  

    Returns
    -------
    unsigned int  
        The order of rotational symmetry  

    See Also
    --------
    RNA.rotational_symmetry(), RNA.rotational_symmetry_num(), RNA.rotational_symmetry_num_pos()  

    Note
    ----
    Do not forget to release the memory occupied by `positions` after a successful execution of this
    function.  

    """
    return _RNA.rotational_symmetry(*args)

def boustrophedon(*args):
    r"""


    Generate a sequence of Boustrophedon distributed numbers.  

    This function generates a sequence of positive natural numbers within the interval :math:`[start,
    end]` in a Boustrophedon fashion. That is, the numbers :math:`start, \ldots, end` in the resulting
    list are alternating between left and right ends of the interval while progressing to the inside,
    i.e. the list consists of a sequence of natural numbers of the form:  

    .. math::

      start, end, start + 1, end - 1, start + 2, end - 2, \ldots  

    The resulting list is 1-based and contains the length of the sequence of numbers at it's 0-th
    position.  

    Upon failure, the function returns **NULL**  

    **SWIG Wrapper Notes**
        This function is available as overloaded global function `boustrophedon()`. See, e.g.
        :py:func:`RNA.boustrophedon()` in the :doc:`/api_python` .  

    Parameters
    ----------
    start : size()
        The first number of the list (left side of the interval)  
    end : size()
        The last number of the list (right side of the interval)  

    Returns
    -------
    unsigned int *  
        A list of alternating numbers from the interval :math:`[start, end]` (or **NULL** on error)  

    See Also
    --------
    RNA.boustrophedon_pos()  

    """
    return _RNA.boustrophedon(*args)
class duplex_list_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    i = property(_RNA.duplex_list_t_i_get, _RNA.duplex_list_t_i_set)
    j = property(_RNA.duplex_list_t_j_get, _RNA.duplex_list_t_j_set)
    energy = property(_RNA.duplex_list_t_energy_get, _RNA.duplex_list_t_energy_set)
    structure = property(_RNA.duplex_list_t_structure_get, _RNA.duplex_list_t_structure_set)

    def __init__(self):
        _RNA.duplex_list_t_swiginit(self, _RNA.new_duplex_list_t())
    __swig_destroy__ = _RNA.delete_duplex_list_t

# Register duplex_list_t in _RNA:
_RNA.duplex_list_t_swigregister(duplex_list_t)

class DuplexVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.DuplexVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.DuplexVector___nonzero__(self)

    def __bool__(self):
        return _RNA.DuplexVector___bool__(self)

    def __len__(self):
        return _RNA.DuplexVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.DuplexVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.DuplexVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.DuplexVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.DuplexVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.DuplexVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.DuplexVector___setitem__(self, *args)

    def pop(self):
        return _RNA.DuplexVector_pop(self)

    def append(self, x):
        return _RNA.DuplexVector_append(self, x)

    def empty(self):
        return _RNA.DuplexVector_empty(self)

    def size(self):
        return _RNA.DuplexVector_size(self)

    def swap(self, v):
        return _RNA.DuplexVector_swap(self, v)

    def begin(self):
        return _RNA.DuplexVector_begin(self)

    def end(self):
        return _RNA.DuplexVector_end(self)

    def rbegin(self):
        return _RNA.DuplexVector_rbegin(self)

    def rend(self):
        return _RNA.DuplexVector_rend(self)

    def clear(self):
        return _RNA.DuplexVector_clear(self)

    def get_allocator(self):
        return _RNA.DuplexVector_get_allocator(self)

    def pop_back(self):
        return _RNA.DuplexVector_pop_back(self)

    def erase(self, *args):
        return _RNA.DuplexVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.DuplexVector_swiginit(self, _RNA.new_DuplexVector(*args))

    def push_back(self, x):
        return _RNA.DuplexVector_push_back(self, x)

    def front(self):
        return _RNA.DuplexVector_front(self)

    def back(self):
        return _RNA.DuplexVector_back(self)

    def assign(self, n, x):
        return _RNA.DuplexVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.DuplexVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.DuplexVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.DuplexVector_reserve(self, n)

    def capacity(self):
        return _RNA.DuplexVector_capacity(self)
    __swig_destroy__ = _RNA.delete_DuplexVector

# Register DuplexVector in _RNA:
_RNA.DuplexVector_swigregister(DuplexVector)


def duplexfold(s1, s2):
    r"""
    duplexfold(std::string s1, std::string s2) -> duplex_list_t


    """
    return _RNA.duplexfold(s1, s2)

def duplex_subopt(s1, s2, delta, w):
    r"""
    duplex_subopt(std::string s1, std::string s2, int delta, int w) -> DuplexVector


    """
    return _RNA.duplex_subopt(s1, s2, delta, w)

def aliduplexfold(alignment1, alignment2):
    r"""
    aliduplexfold(StringVector alignment1, StringVector alignment2) -> duplex_list_t


    """
    return _RNA.aliduplexfold(alignment1, alignment2)

def aliduplex_subopt(alignment1, alignment2, delta, w):
    r"""
    aliduplex_subopt(StringVector alignment1, StringVector alignment2, int delta, int w) -> DuplexVector


    """
    return _RNA.aliduplex_subopt(alignment1, alignment2, delta, w)
class move(object):
    r"""


    An atomic representation of the transition / move from one structure to its neighbor.  

    An atomic transition / move may be one of the following:  

    *   a **base pair insertion**,  
    *   a **base pair removal**, or  
    *   a **base pair shift** where an existing base pair changes one of its pairing partner.  

    These moves are encoded by two integer values that represent the affected 5' and 3' nucleotide
    positions. Furthermore, we use the following convention on the signedness of these encodings:  

    *   both values are positive for *insertion moves*  
    *   both values are negative for *base pair removals*  
    *   both values have different signedness for *shift moves*, where the positive value indicates the
        nucleotide that stays constant, and the others absolute value is the new pairing partner  

    Note
    ----
    A value of 0 in either field is used as list-end indicator and doesn't represent any valid move.  

    Attributes
    ----------
    pos_5 : int  
        The (absolute value of the) 5' position of a base pair, or any position of a shifted pair.  

    pos_3 : int  
        The (absolute value of the) 3' position of a base pair, or any position of a shifted pair.  

    next : vrna_move_t *  
        The next base pair (if an elementary move changes more than one base pair), or `NULL` Has to be
        terminated with move 0,0.  

    C++ includes: ViennaRNA/landscape/move.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pos_5 = property(_RNA.move_pos_5_get, _RNA.move_pos_5_set)
    pos_3 = property(_RNA.move_pos_3_get, _RNA.move_pos_3_set)

    def __init__(self, pos_5=0, pos_3=0):
        r"""


        An atomic representation of the transition / move from one structure to its neighbor.  

        An atomic transition / move may be one of the following:  

        *   a **base pair insertion**,  
        *   a **base pair removal**, or  
        *   a **base pair shift** where an existing base pair changes one of its pairing partner.  

        These moves are encoded by two integer values that represent the affected 5' and 3' nucleotide
        positions. Furthermore, we use the following convention on the signedness of these encodings:  

        *   both values are positive for *insertion moves*  
        *   both values are negative for *base pair removals*  
        *   both values have different signedness for *shift moves*, where the positive value indicates the
            nucleotide that stays constant, and the others absolute value is the new pairing partner  

        Note
        ----
        A value of 0 in either field is used as list-end indicator and doesn't represent any valid move.  

        Attributes
        ----------
        pos_5 : int  
            The (absolute value of the) 5' position of a base pair, or any position of a shifted pair.  

        pos_3 : int  
            The (absolute value of the) 3' position of a base pair, or any position of a shifted pair.  

        next : vrna_move_t *  
            The next base pair (if an elementary move changes more than one base pair), or `NULL` Has to be
            terminated with move 0,0.  

        C++ includes: ViennaRNA/landscape/move.h

        """
        _RNA.move_swiginit(self, _RNA.new_move(pos_5, pos_3))
    __swig_destroy__ = _RNA.delete_move

    def is_removal(self):
        r"""


        Test whether a move is a base pair removal.  

        Parameters
        ----------

        Returns
        -------
        int  
            Non-zero if the move is a base pair removal, 0 otherwise  

        """
        return _RNA.move_is_removal(self)

    def is_insertion(self):
        r"""


        Test whether a move is a base pair insertion.  

        Parameters
        ----------

        Returns
        -------
        int  
            Non-zero if the move is a base pair insertion, 0 otherwise  

        """
        return _RNA.move_is_insertion(self)

    def is_shift(self):
        r"""


        Test whether a move is a base pair shift.  

        Parameters
        ----------

        Returns
        -------
        int  
            Non-zero if the move is a base pair shift, 0 otherwise  

        """
        return _RNA.move_is_shift(self)

    def compare(self, *args, **kwargs):
        r"""


        Compare two moves.  

        The function compares two moves `m` and `b` and returns whether move `m` is lexicographically
        smaller (-1), larger (1) or equal to move `b`.  

        If any of the moves `m` or `b` is a shift move, this comparison only makes sense in a structure
        context. Thus, the third argument with the current structure must be provided.  

        Parameters
        ----------
        b : const RNA.move() *
            The second move of the comparison  
        pt : const short *
            The pair table of the current structure that is compatible with both moves (maybe NULL if moves
            are guaranteed to be no shifts)  

        Returns
        -------
        int  
            -1 if `m` < `b`, 1 if `m` > `b`, 0 otherwise  

        Warnings
        --------
        Currently, shift moves are not supported!  

        Note
        ----
        This function returns 0 (equality) upon any error, e.g. missing input  

        """
        return _RNA.move_compare(self, *args, **kwargs)

    def __str__(self):
        return _RNA.move___str__(self)

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 

    def __hash__(self):
        p5, p3 = (self.pos_5, self.pos_3) if self.pos_5 < self.pos_3 else (self.pos_3, self.pos_5)
        return hash((p5, p3))

    def __eq__(self, other):
        return (self.pos_5 == other.pos_5 and self.pos_3 == other.pos_3) or ((self.pos_5 == other.pos_3 and self.pos_3 == other.pos_5))



# Register move in _RNA:
_RNA.move_swigregister(move)

MOVESET_INSERTION = _RNA.MOVESET_INSERTION
r"""


    Option flag indicating insertion move.  

    See Also
    --------
    RNA.fold_compound.neighbors(), RNA.neighbors_successive, RNA.fold_compound.path()  

    """
MOVESET_DELETION = _RNA.MOVESET_DELETION
r"""


    Option flag indicating deletion move.  

    See Also
    --------
    RNA.fold_compound.neighbors(), RNA.neighbors_successive, RNA.fold_compound.path()  

    """
MOVESET_SHIFT = _RNA.MOVESET_SHIFT
r"""


    Option flag indicating shift move.  

    See Also
    --------
    RNA.fold_compound.neighbors(), RNA.neighbors_successive, RNA.fold_compound.path()  

    """
MOVESET_NO_LP = _RNA.MOVESET_NO_LP
r"""


    Option flag indicating moves without lonely base pairs.  

    See Also
    --------
    RNA.fold_compound.neighbors(), RNA.neighbors_successive, RNA.fold_compound.path()  

    """
MOVESET_DEFAULT = _RNA.MOVESET_DEFAULT
r"""


    Option flag indicating default move set, i.e. insertions/deletion of a base pair.  

    See Also
    --------
    RNA.fold_compound.neighbors(), RNA.neighbors_successive, RNA.fold_compound.path()  

    """
NEIGHBOR_CHANGE = _RNA.NEIGHBOR_CHANGE
r"""


    State indicator for a neighbor that has been changed.  

    See Also
    --------
    RNA.move_neighbor_diff_cb()  

    """
NEIGHBOR_INVALID = _RNA.NEIGHBOR_INVALID
r"""


    State indicator for a neighbor that has been invalidated.  

    See Also
    --------
    RNA.move_neighbor_diff_cb()  

    """
NEIGHBOR_NEW = _RNA.NEIGHBOR_NEW
r"""


    State indicator for a neighbor that has become newly available.  

    See Also
    --------
    RNA.move_neighbor_diff_cb()  

    """
PATH_STEEPEST_DESCENT = _RNA.PATH_STEEPEST_DESCENT
r"""


    Option flag to request a steepest descent / gradient path.  

    See Also
    --------
    RNA.fold_compound.path()  

    """
PATH_RANDOM = _RNA.PATH_RANDOM
r"""


    Option flag to request a random walk path.  

    See Also
    --------
    RNA.fold_compound.path()  

    """
PATH_NO_TRANSITION_OUTPUT = _RNA.PATH_NO_TRANSITION_OUTPUT
r"""


    Option flag to omit returning the transition path.  

    See Also
    --------
    RNA.fold_compound.path(), RNA.fold_compound.path_gradient(), RNA.fold_compound.path_random()  

    """
PATH_DEFAULT = _RNA.PATH_DEFAULT
r"""


    Option flag to request defaults (steepest descent / default move set)  

    See Also
    --------
    RNA.fold_compound.path(), RNA.PATH_STEEPEST_DESCENT, RNA.MOVESET_DEFAULT  

    """
class path(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_RNA.path_type_get, _RNA.path_type_set)
    en = property(_RNA.path_en_get, _RNA.path_en_set)
    s = property(_RNA.path_s_get, _RNA.path_s_set)
    move = property(_RNA.path_move_get, _RNA.path_move_set)

    def __init__(self, *args, **kwargs):
        _RNA.path_swiginit(self, _RNA.new_path(*args, **kwargs))
    __swig_destroy__ = _RNA.delete_path

    def __str__(self):
        return _RNA.path___str__(self)

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 


# Register path in _RNA:
_RNA.path_swigregister(path)

class path_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _RNA.path_options_swiginit(self, _RNA.new_path_options())
    __swig_destroy__ = _RNA.delete_path_options

# Register path_options in _RNA:
_RNA.path_options_swigregister(path_options)


def path_options_findpath(*args, **kwargs):
    r"""


    Create options data structure for findpath direct (re-)folding path heuristic.  

    This function returns an options data structure that switches the RNA.path_direct() and
    RNA.fold_compound.path_direct() API functions to use the *findpath* :cite:p:`flamm:2001`  heuristic. The
    parameter `width` specifies the width of the breadth-first search while the second parameter `type`
    allows one to set the type of the returned (re-)folding path.  

    Currently, the following return types are available:  

    *   A list of dot-bracket structures and corresponding free energy (flag:
        RNA.PATH_TYPE_DOT_BRACKET)  
    *   A list of transition moves and corresponding free energy changes (flag: RNA.PATH_TYPE_MOVES)  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `path_options_findpath()`. The optional
        parameter `width` defaults to 10 if omitted, while the optional parameter `type` defaults to
        RNA.PATH_TYPE_DOT_BRACKET. See, e.g.  :py:func:`RNA.path_options_findpath()` in the
        :doc:`/api_python`.  

    Parameters
    ----------
    width : int
        Width of the breath-first search strategy  
    type : unsigned int
        Setting that specifies how the return (re-)folding path should be encoded  

    Returns
    -------
    RNA.path_options()  
        An options data structure with settings for the findpath direct path heuristic  

    See Also
    --------
    RNA.PATH_TYPE_DOT_BRACKET, RNA.PATH_TYPE_MOVES, RNA.path_options_free(), RNA.path_direct(),
    RNA.fold_compound.path_direct()  

    """
    return _RNA.path_options_findpath(*args, **kwargs)

def get_path(seq, s1, s2, maxkeep):
    r"""get_path(std::string seq, std::string s1, std::string s2, int maxkeep) -> PathVector"""
    return _RNA.get_path(seq, s1, s2, maxkeep)
PATH_TYPE_DOT_BRACKET = _RNA.PATH_TYPE_DOT_BRACKET
r"""


    Flag to indicate producing a (re-)folding path as list of dot-bracket structures.  

    See Also
    --------
    RNA.path(), RNA.path_options_findpath(), RNA.path_direct(), RNA.fold_compound.path_direct()  

    """
PATH_TYPE_MOVES = _RNA.PATH_TYPE_MOVES
r"""


    Flag to indicate producing a (re-)folding path as list of transition moves.  

    See Also
    --------
    RNA.path(), RNA.path_options_findpath(), RNA.path_direct(), RNA.fold_compound.path_direct()  

    """

def find_saddle(seq, s1, s2, width):
    r"""


    Find energy of a saddle point between 2 structures (search only direct path)  

    .. deprecated:: 2.6.4
        Use RNA.path_findpath_saddle() instead!  

    Parameters
    ----------
    seq : const char *
        RNA sequence  
    s1 : const char *
        A pointer to the character array where the first secondary structure in dot-bracket notation
        will be written to  
    s2 : const char *
        A pointer to the character array where the second secondary structure in dot-bracket notation
        will be written to  
    width : int
        integer how many strutures are being kept during the search  

    Returns
    -------
    int  
        the saddle energy in 10cal/mol  

    """
    return _RNA.find_saddle(seq, s1, s2, width)

def free_path(path):
    r"""


    Free memory allocated by get_path() function.  

    .. deprecated:: 2.6.4
        Use RNA.path_free() instead!  

    Parameters
    ----------
    path : RNA.path() *
        pointer to memory to be freed  

    """
    return _RNA.free_path(path)
class heat_capacity_result(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    temperature = property(_RNA.heat_capacity_result_temperature_get, _RNA.heat_capacity_result_temperature_set)
    heat_capacity = property(_RNA.heat_capacity_result_heat_capacity_get, _RNA.heat_capacity_result_heat_capacity_set)

    def __str__(self):
        return _RNA.heat_capacity_result___str__(self)

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 


    def __init__(self):
        _RNA.heat_capacity_result_swiginit(self, _RNA.new_heat_capacity_result())
    __swig_destroy__ = _RNA.delete_heat_capacity_result

# Register heat_capacity_result in _RNA:
_RNA.heat_capacity_result_swigregister(heat_capacity_result)

class HeatCapacityVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RNA.HeatCapacityVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RNA.HeatCapacityVector___nonzero__(self)

    def __bool__(self):
        return _RNA.HeatCapacityVector___bool__(self)

    def __len__(self):
        return _RNA.HeatCapacityVector___len__(self)

    def __getslice__(self, i, j):
        return _RNA.HeatCapacityVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RNA.HeatCapacityVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RNA.HeatCapacityVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RNA.HeatCapacityVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RNA.HeatCapacityVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RNA.HeatCapacityVector___setitem__(self, *args)

    def pop(self):
        return _RNA.HeatCapacityVector_pop(self)

    def append(self, x):
        return _RNA.HeatCapacityVector_append(self, x)

    def empty(self):
        return _RNA.HeatCapacityVector_empty(self)

    def size(self):
        return _RNA.HeatCapacityVector_size(self)

    def swap(self, v):
        return _RNA.HeatCapacityVector_swap(self, v)

    def begin(self):
        return _RNA.HeatCapacityVector_begin(self)

    def end(self):
        return _RNA.HeatCapacityVector_end(self)

    def rbegin(self):
        return _RNA.HeatCapacityVector_rbegin(self)

    def rend(self):
        return _RNA.HeatCapacityVector_rend(self)

    def clear(self):
        return _RNA.HeatCapacityVector_clear(self)

    def get_allocator(self):
        return _RNA.HeatCapacityVector_get_allocator(self)

    def pop_back(self):
        return _RNA.HeatCapacityVector_pop_back(self)

    def erase(self, *args):
        return _RNA.HeatCapacityVector_erase(self, *args)

    def __init__(self, *args):
        _RNA.HeatCapacityVector_swiginit(self, _RNA.new_HeatCapacityVector(*args))

    def push_back(self, x):
        return _RNA.HeatCapacityVector_push_back(self, x)

    def front(self):
        return _RNA.HeatCapacityVector_front(self)

    def back(self):
        return _RNA.HeatCapacityVector_back(self)

    def assign(self, n, x):
        return _RNA.HeatCapacityVector_assign(self, n, x)

    def resize(self, *args):
        return _RNA.HeatCapacityVector_resize(self, *args)

    def insert(self, *args):
        return _RNA.HeatCapacityVector_insert(self, *args)

    def reserve(self, n):
        return _RNA.HeatCapacityVector_reserve(self, n)

    def capacity(self):
        return _RNA.HeatCapacityVector_capacity(self)
    __swig_destroy__ = _RNA.delete_HeatCapacityVector

# Register HeatCapacityVector in _RNA:
_RNA.HeatCapacityVector_swigregister(HeatCapacityVector)


def heat_capacity(sequence, T_min=0., T_max=100., T_increment=1., mpoints=2):
    r"""


    Compute the specific heat for an RNA (simplified variant)  

    Similar to RNA.fold_compound.heat_capacity(), this function computes an RNAs specific heat in a given temperature
    range from the partition function by numeric differentiation. This simplified version, however, only
    requires the RNA sequence as input instead of a RNA.fold_compound() data structure. The result is
    returned as a list of pairs of temperature in C and specific heat in Kcal/(Mol*K).  

    Users can specify the temperature range for the computation from `T_min` to `T_max`, as well as the
    increment step size `T_increment`. The latter also determines how many times the partition function
    is computed. Finally, the parameter `mpoints` determines how smooth the curve should be. The
    algorithm itself fits a parabola to :math:`2 \cdot mpoints + 1` data points to calculate 2nd
    derivatives. Increasing this parameter produces a smoother curve.  

    **SWIG Wrapper Notes**
        This function is available as overloaded function `heat_capacity()`. If the optional function
        arguments `T_min`, `T_max`, `T_increment`, and `mpoints` are omitted, they default to 0.0,
        100.0, 1.0 and 2, respectively. See, e.g.  :py:func:`RNA.head_capacity()` in the
        :doc:`/api_python`.  

    Parameters
    ----------
    sequence : const char *
        The RNA sequence input (must be uppercase)  
    T_min : float
        Lowest temperature in C  
    T_max : float
        Highest temperature in C  
    T_increment : float
        Stepsize for temperature incrementation in C (a reasonable choice might be 1C)  
    mpoints : unsigned int
        The number of interpolation points to calculate 2nd derivative (a reasonable choice might be 2,
        min: 1, max: 100)  

    Returns
    -------
    RNA.heat_capacity() *  
        A list of pairs of temperatures and corresponding heat capacity or *NULL* upon any failure. The
        last entry of the list is indicated by a **temperature** field set to a value smaller than
        `T_min`  

    See Also
    --------
    RNA.fold_compound.heat_capacity(), RNA.fold_compound.heat_capacity_cb(), RNA.heat_capacity(),
    RNA.heat_capacity()  

    """
    return _RNA.heat_capacity(sequence, T_min, T_max, T_increment, mpoints)
class basepair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    i = property(_RNA.basepair_i_get, _RNA.basepair_i_set)
    j = property(_RNA.basepair_j_get, _RNA.basepair_j_set)

    def __init__(self):
        _RNA.basepair_swiginit(self, _RNA.new_basepair())
    __swig_destroy__ = _RNA.delete_basepair

# Register basepair in _RNA:
_RNA.basepair_swigregister(basepair)


def fc_add_pycallback(vc, PyFunc):
    return _RNA.fc_add_pycallback(vc, PyFunc)

def fc_add_pydata(vc, data, PyFuncOrNone):
    return _RNA.fc_add_pydata(vc, data, PyFuncOrNone)

def sc_add_f_pycallback(vc, callback):
    return _RNA.sc_add_f_pycallback(vc, callback)

def sc_add_bt_pycallback(vc, PyFunc):
    return _RNA.sc_add_bt_pycallback(vc, PyFunc)

def sc_add_exp_f_pycallback(vc, PyFunc):
    return _RNA.sc_add_exp_f_pycallback(vc, PyFunc)

def sc_add_pydata(vc, data, callback):
    return _RNA.sc_add_pydata(vc, data, callback)

def ud_set_pydata(vc, data, PyFuncOrNone):
    return _RNA.ud_set_pydata(vc, data, PyFuncOrNone)

def ud_set_prod_cb(vc, prod_cb, eval_cb):
    return _RNA.ud_set_prod_cb(vc, prod_cb, eval_cb)

def ud_set_exp_prod_cb(vc, prod_cb, eval_cb):
    return _RNA.ud_set_exp_prod_cb(vc, prod_cb, eval_cb)

def ud_set_prob_cb(vc, setter, getter):
    return _RNA.ud_set_prob_cb(vc, setter, getter)

def Lfold_cb(string, window_size, PyFunc, data):
    r"""Lfold_cb(char * string, int window_size, PyObject * PyFunc, PyObject * data) -> float"""
    return _RNA.Lfold_cb(string, window_size, PyFunc, data)

def Lfoldz_cb(string, window_size, min_z, PyFunc, data):
    r"""Lfoldz_cb(char * string, int window_size, double min_z, PyObject * PyFunc, PyObject * data) -> float"""
    return _RNA.Lfoldz_cb(string, window_size, min_z, PyFunc, data)

def aliLfold_cb(alignment, window_size, PyFunc, data):
    r"""aliLfold_cb(StringVector alignment, int window_size, PyObject * PyFunc, PyObject * data) -> float"""
    return _RNA.aliLfold_cb(alignment, window_size, PyFunc, data)

def pfl_fold_cb(*args, **kwargs):
    r"""pfl_fold_cb(std::string sequence, int window_size, int max_bp_span, PyObject * PyFunc, PyObject * data=Py_None) -> int"""
    return _RNA.pfl_fold_cb(*args, **kwargs)

def pfl_fold_up_cb(*args, **kwargs):
    r"""pfl_fold_up_cb(std::string sequence, int ulength, int window_size, int max_bp_span, PyObject * PyFunc, PyObject * data=Py_None) -> int"""
    return _RNA.pfl_fold_up_cb(*args, **kwargs)
FC_TYPE_SINGLE = _RNA.FC_TYPE_SINGLE
FC_TYPE_COMPARATIVE = _RNA.FC_TYPE_COMPARATIVE
class fold_compound(object):
    r"""


    The most basic data structure required by many functions throughout the RNAlib.  

    Note
    ----
    Please read the documentation of this data structure carefully! Some attributes are only available
    for specific types this data structure can adopt.  

    Warnings
    --------
    Reading/Writing from/to attributes that are not within the scope of the current type usually result
    in undefined behavior!  

    See Also
    --------
    RNA.fold_compound().type, RNA.fold_compound(), RNA.fold_compound_comparative(),
    RNA.fold_compound_free(), RNA.FC_TYPE_SINGLE, RNA.FC_TYPE_COMPARATIVE  

    **SWIG Wrapper Notes**

        This data structure is wrapped as class `fold_compound` with several related functions attached
        as methods.  

        A new `fold_compound` can be obtained by calling one of its constructors:  

        *   `fold_compound(seq)` - Initialize with a single sequence, or two concatenated sequences
            separated by an ampersand character `&` (for cofolding)  
        *   `fold_compound(aln)` - Initialize with a sequence alignment *aln* stored as a list of
            sequences (with gap characters).  

        The resulting object has a list of attached methods which in most cases directly correspond to
        functions that mainly operate on the corresponding `C` data structure:  

        *   `type()` - Get the type of the *fold_compound* (See RNA.fc_type)  
        *   `length()` - Get the length of the sequence(s) or alignment stored within the
            `fold_compound`.  

        See, e.g.  :py:class:`RNA.fold_compound` in the :doc:`/api_python`.  

    Attributes
    ----------
    type : const vrna_fc_type_e  
        The type of the RNA.fold_compound().  

        Currently possible values are RNA.FC_TYPE_SINGLE, and RNA.FC_TYPE_COMPARATIVE  

        Warnings
        --------
        Do not edit this attribute, it will be automagically set by the corresponding get() methods for
        the RNA.fold_compound(). The value specified in this attribute dictates the set of other
        attributes to use within this data structure.  

    length : unsigned int  
        The length of the sequence (or sequence alignment)  

    cutpoint : int  
        The position of the (cofold) cutpoint within the provided sequence. If there is no cutpoint,
        this field will be set to -1.  

    strand_number : unsigned int *  
        The strand number a particular nucleotide is associated with.  

    strand_order : unsigned int *  
        The strand order, i.e. permutation of current concatenated sequence.  

    strand_order_uniq : unsigned int *  
        The strand order array where identical sequences have the same ID.  

    strand_start : unsigned int *  
        The start position of a particular strand within the current concatenated sequence.  

    strand_end : unsigned int *  
        The end (last) position of a particular strand within the current concatenated sequence.  

    strands : unsigned int  
        Number of interacting strands.  

    nucleotides : vrna_seq_t *  
        Set of nucleotide sequences.  

    alignment : vrna_msa_t *  
        Set of alignments.  

    hc : vrna_hc_t *  
        The hard constraints data structure used for structure prediction.  

    matrices : vrna_mx_mfe_t *  
        The MFE DP matrices.  

    exp_matrices : vrna_mx_pf_t *  
        The PF DP matrices  

    params : vrna_param_t *  
        The precomputed free energy contributions for each type of loop.  

    exp_params : vrna_exp_param_t *  
        The precomputed free energy contributions as Boltzmann factors  

    iindx : int *  
        DP matrix accessor  

    jindx : int *  
        DP matrix accessor  

    stat_cb : vrna_recursion_status_f  
        Recursion status callback (usually called just before, and after recursive computations in the
        library.  

        See Also
        --------
        RNA.recursion_status(), RNA.fold_compound.add_callback()  

    auxdata : void *  
        A pointer to auxiliary, user-defined data.  

        See Also
        --------
        RNA.fold_compound.add_auxdata(), RNA.fold_compound().free_auxdata  

    free_auxdata : vrna_auxdata_free_f  
        A callback to free auxiliary user data whenever the fold_compound itself is free'd.  

        See Also
        --------
        RNA.fold_compound().auxdata, RNA.auxdata_free()  

    domains_struc : vrna_sd_t *  
        Additional structured domains.  

    domains_up : vrna_ud_t *  
        Additional unstructured domains.  

    aux_grammar : vrna_gr_aux_t *  
        Additional decomposition grammar rules.  

    sequence : char *  
        The input sequence string.  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_SINGLE  

    sequence_encoding : short *  
        Numerical encoding of the input sequence.  

        See Also
        --------
        RNA.sequence_encode()  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_SINGLE  

    encoding5 : short *  

    encoding3 : short *  

    sequence_encoding2 : short *  

    ptype : char *  
        Pair type array.  

        Contains the numerical encoding of the pair type for each pair (i,j) used in MFE, Partition
        function and Evaluation computations.  

        Note
        ----
        This array is always indexed via jindx, in contrast to previously different indexing between mfe
        and pf variants!  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_SINGLE  

        See Also
        --------
        RNA.idx_col_wise(), RNA.ptypes()  

    ptype_pf_compat : char *  
        ptype array indexed via iindx  

        .. deprecated:: 2.6.4
            This attribute will vanish in the future! It's meant for backward compatibility only!  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_SINGLE  

    sc : vrna_sc_t *  
        The soft constraints for usage in structure prediction and evaluation.  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_SINGLE  

    sequences : char **  
        The aligned sequences.  

        Note
        ----
        The end of the alignment is indicated by a NULL pointer in the second dimension  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_COMPARATIVE  

    n_seq : unsigned int  
        The number of sequences in the alignment.  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_COMPARATIVE  

    cons_seq : char *  
        The consensus sequence of the aligned sequences.  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_COMPARATIVE  

    S_cons : short *  
        Numerical encoding of the consensus sequence.  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_COMPARATIVE  

    S : short **  
        Numerical encoding of the sequences in the alignment.  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_COMPARATIVE  

    S5 : short **  
        S5[s][i] holds next base 5' of i in sequence s.  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_COMPARATIVE  

    S3 : short **  
        Sl[s][i] holds next base 3' of i in sequence s.  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_COMPARATIVE  

    Ss : char **  

    a2s : unsigned int **  

    pscore : int *  
        Precomputed array of pair types expressed as pairing scores.  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_COMPARATIVE  

    pscore_local : int **  
        Precomputed array of pair types expressed as pairing scores.  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_COMPARATIVE  

    pscore_pf_compat : short *  
        Precomputed array of pair types expressed as pairing scores indexed via iindx.  

        .. deprecated:: 2.6.4
            This attribute will vanish in the future!  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_COMPARATIVE  

    scs : vrna_sc_t **  
        A set of soft constraints (for each sequence in the alignment)  

        Warnings
        --------
        Only available if  

            type==RNA.FC_TYPE_COMPARATIVE  

    oldAliEn : int  

    maxD1 : unsigned int  
        Maximum allowed base pair distance to first reference.  

    maxD2 : unsigned int  
        Maximum allowed base pair distance to second reference.  

    reference_pt1 : short *  
        A pairtable of the first reference structure.  

    reference_pt2 : short *  
        A pairtable of the second reference structure.  

    referenceBPs1 : unsigned int *  
        Matrix containing number of basepairs of reference structure1 in interval [i,j].  

    referenceBPs2 : unsigned int *  
        Matrix containing number of basepairs of reference structure2 in interval [i,j].  

    bpdist : unsigned int *  
        Matrix containing base pair distance of reference structure 1 and 2 on interval [i,j].  

    mm1 : unsigned int *  
        Maximum matching matrix, reference struct 1 disallowed.  

    mm2 : unsigned int *  
        Maximum matching matrix, reference struct 2 disallowed.  

    window_size : int  
        window size for local folding sliding window approach  

    ptype_local : char **  
        Pair type array (for local folding)  

    zscore_data : vrna_zsc_dat_t  
        Data structure with settings for z-score computations.  

    @17 : union vrna_fc_s::@16  

    C++ includes: ViennaRNA/fold_compound.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def params_reset(self, md=None):
        r"""


        Reset free energy parameters within a RNA.fold_compound() according to provided, or default model
        details.  

        This function allows one to rescale free energy parameters for subsequent structure prediction or
        evaluation according to a set of model details, e.g. temperature values. To do so, the caller
        provides either a pointer to a set of model details to be used for rescaling, or NULL if global
        default setting should be used.  

        **SWIG Wrapper Notes**
            This function is attached to RNA.fc() objects as overloaded `params_reset()` method.  

            When no parameter is passed to this method, the resulting action is the same as passing `NULL`
            as second parameter to RNA.fold_compound.params_reset(), i.e. global default model settings are
            used. Passing
            an object of type RNA.md() resets the fold compound according to the specifications stored
            within the RNA.md() object. See, e.g.  :py:meth:`RNA.fold_compound.params_reset()` in the
            :doc:`/api_python`.  

        Parameters
        ----------
        md : RNA.md() *
            A pointer to the new model details (or NULL for reset to defaults)  

        See Also
        --------
        RNA.fold_compound.exp_params_reset(), RNA.params_subs()  

        """
        return _RNA.fold_compound_params_reset(self, md)

    def params_subst(self, par=None):
        r"""


        Update/Reset energy parameters data structure within a RNA.fold_compound().  

        Passing NULL as second argument leads to a reset of the energy parameters within fc to their default
        values. Otherwise, the energy parameters provided will be copied over into fc.  

        **SWIG Wrapper Notes**
            This function is attached to RNA.fc() objects as overloaded `params_subst()` method.  

            When no parameter is passed, the resulting action is the same as passing `NULL` as second
            parameter to RNA.fold_compound.params_subst(), i.e. resetting the parameters to the global
            defaults. See,
            e.g.  :py:meth:`RNA.fold_compound.params_subst()` in the :doc:`/api_python`.  

        Parameters
        ----------
        par : RNA.param() *
            The energy parameters used to substitute those within fc (Maybe NULL)  

        See Also
        --------
        RNA.fold_compound.params_reset(), RNA.param(), RNA.md(), RNA.params()  

        """
        return _RNA.fold_compound_params_subst(self, par)

    def exp_params_rescale(self, *args):
        r"""


        Rescale Boltzmann factors for partition function computations.  

        This function may be used to (automatically) rescale the Boltzmann factors used in partition
        function computations. Since partition functions over subsequences can easily become extremely
        large, the RNAlib internally rescales them to avoid numerical over- and/or underflow. Therefore, a
        proper scaling factor :math:`s` needs to be chosen that in turn is then used to normalize the
        corresponding partition functions :math:`\hat{q}[i,j] = q[i,j] / s^{(j-i+1)}`.  

        This function provides two ways to automatically adjust the scaling factor.  

        1.  Automatic guess  
        2.  Automatic adjustment according to MFE  

        Passing `NULL` as second parameter activates the *automatic guess mode*. Here, the scaling factor is
        recomputed according to a mean free energy of `184.3*length` cal for random sequences.
        On the other hand, if the MFE for a sequence is known, it can be used to recompute a more robust
        scaling factor, since it represents the lowest free energy of the entire ensemble of structures,
        i.e. the highest Boltzmann factor. To activate this second mode of *automatic adjustment according
        to MFE*, a pointer to the MFE value needs to be passed as second argument. This value is then taken
        to compute the scaling factor as :math:`s = exp((sfact * MFE) / kT / length )`, where sfact is an
        additional scaling weight located in the RNA.md() data structure of `exp_params` in `fc`.  

        Note
        ----
        This recomputation only takes place if the `pf_scale` attribute of the `exp_params` data structure
        contained in `fc` has a value below `1.0`.  

        The computed scaling factor :math:`s` will be stored as `pf_scale` attribute of the `exp_params`
        data structure in `fc`.  

        **SWIG Wrapper Notes**
            This function is attached to RNA.fc() objects as overloaded `exp_params_rescale()` method.  

            When no parameter is passed to this method, the resulting action is the same as passing `NULL`
            as second parameter to RNA.fold_compound.exp_params_rescale(), i.e. default scaling of the
            partition
            function. Passing an energy in kcal/mol, e.g. as retrieved by a previous call to the `mfe()`
            method, instructs all subsequent calls to scale the partition function accordingly. See, e.g.
            :py:meth:`RNA.fold_compound.exp_params_rescale()` in the :doc:`/api_python`.  

        Parameters
        ----------
        mfe : double *
            A pointer to the MFE (in kcal/mol) or NULL  

        See Also
        --------
        RNA.fold_compound.exp_params_subst(), RNA.md(), RNA.exp_param(), RNA.fold_compound()  

        """
        return _RNA.fold_compound_exp_params_rescale(self, *args)

    def exp_params_reset(self, md=None):
        r"""


        Reset Boltzmann factors for partition function computations within a RNA.fold_compound() according
        to provided, or default model details.  

        This function allows one to rescale Boltzmann factors for subsequent partition function computations
        according to a set of model details, e.g. temperature values. To do so, the caller provides either a
        pointer to a set of model details to be used for rescaling, or NULL if global default setting should
        be used.  

        **SWIG Wrapper Notes**
            This function is attached to RNA.fc() objects as overloaded `exp_params_reset()` method.  

            When no parameter is passed to this method, the resulting action is the same as passing `NULL`
            as second parameter to RNA.fold_compound.exp_params_reset(), i.e. global default model settings
            are used.
            Passing an object of type RNA.md() resets the fold compound according to the specifications
            stored within the RNA.md() object. See, e.g.  :py:meth:`RNA.fold_compound.exp_params_reset()`
            in the :doc:`/api_python`.  

        Parameters
        ----------
        md : RNA.md() *
            A pointer to the new model details (or NULL for reset to defaults)  

        See Also
        --------
        RNA.fold_compound.params_reset(), RNA.fold_compound.exp_params_subst(),
        RNA.fold_compound.exp_params_rescale()  

        """
        return _RNA.fold_compound_exp_params_reset(self, md)

    def exp_params_subst(self, par):
        r"""


        Update the energy parameters for subsequent partition function computations.  

        This function can be used to properly assign new energy parameters for partition function
        computations to a RNA.fold_compound(). For this purpose, the data of the provided pointer `params`
        will be copied into `fc` and a recomputation of the partition function scaling factor is issued, if
        the `pf_scale` attribute of `params` is less than `1.0`.  

        Passing NULL as second argument leads to a reset of the energy parameters within fc to their default
        values  

        **SWIG Wrapper Notes**
            This function is attached to RNA.fc() objects as overloaded `exp_params_subst()` method.  

            When no parameter is passed, the resulting action is the same as passing `NULL` as second
            parameter to RNA.fold_compound.exp_params_subst(), i.e. resetting the parameters to the global
            defaults. See,
            e.g.  :py:meth:`RNA.fold_compound.exp_params_subst()` in the :doc:`/api_python`.  

        Parameters
        ----------
        params : RNA.exp_param() *
            A pointer to the new energy parameters  

        See Also
        --------
        RNA.fold_compound.exp_params_reset(), RNA.fold_compound.exp_params_rescale(), RNA.exp_param(),
        RNA.md(), RNA.exp_params()  

        """
        return _RNA.fold_compound_exp_params_subst(self, par)

    def plist_from_probs(self, cutoff):
        r"""
        plist_from_probs(fold_compound self, double cutoff) -> ElemProbVector


        Create a RNA.ep() from base pair probability matrix.  

        The probability matrix provided via the RNA.fold_compound() is parsed and all pair probabilities
        above the given threshold are used to create an entry in the plist  

        The end of the plist is marked by sequence positions i as well as j equal to 0. This condition
        should be used to stop looping over its entries  

        Parameters
        ----------
        cut_off : double
            The cutoff value  

        Returns
        -------
        RNA.ep() *  
            A pointer to the plist that is to be created  

        """
        return _RNA.fold_compound_plist_from_probs(self, cutoff)

    def db_from_probs(self):
        return _RNA.fold_compound_db_from_probs(self)

    def constraints_add(self, *args, **kwargs):
        r"""
        constraints_add(fold_compound self, char const * constraint, unsigned int options=)


        Add constraints to a RNA.fold_compound() data structure.  

        Use this function to add/update the hard/soft constraints The function allows for passing a string
        'constraint' that can either be a filename that points to a constraints definition file or it may be
        a pseudo dot-bracket notation indicating hard constraints. For the latter, the user has to pass the
        RNA.CONSTRAINT_DB option. Also, the user has to specify, which characters are allowed to be
        interpreted as constraints by passing the corresponding options via the third parameter.  

        The following is an example for adding hard constraints given in pseudo dot-bracket notation. Here,
        `fc` is the RNA.fold_compound() object, `structure` is a char array with the hard constraint in
        dot-bracket notation, and `enforceConstraints` is a flag indicating whether or not constraints for
        base pairs should be enforced instead of just doing a removal of base pair that conflict with the
        constraint.  

         In constrat to the above, constraints may also be read from file:  

        Parameters
        ----------
        constraint : const char *
            A string with either the filename of the constraint definitions or a pseudo dot-bracket notation
            of the hard constraint. May be NULL.  
        options : unsigned int
            The option flags  

        See Also
        --------
        RNA.fold_compound.hc_add_from_db(), RNA.fold_compound.hc_add_up(), RNA.hc_add_up_batch()
        RNA.hc_add_bp_unspecific(),
        RNA.fold_compound.hc_add_bp(), RNA.fold_compound.hc_init(), RNA.fold_compound.sc_set_up(),
        RNA.fold_compound.sc_set_bp(), RNA.fold_compound.sc_add_SHAPE_deigan(),
        RNA.fold_compound.sc_add_SHAPE_zarringhalam(), RNA.hc_free(), RNA.sc_free(), RNA.CONSTRAINT_DB,
        RNA.CONSTRAINT_DB_DEFAULT, RNA.CONSTRAINT_DB_PIPE, RNA.CONSTRAINT_DB_DOT, RNA.CONSTRAINT_DB_X,
        RNA.CONSTRAINT_DB_ANG_BRACK, RNA.CONSTRAINT_DB_RND_BRACK, RNA.CONSTRAINT_DB_INTRAMOL,
        RNA.CONSTRAINT_DB_INTERMOL, RNA.CONSTRAINT_DB_GQUAD  

        """
        return _RNA.fold_compound_constraints_add(self, *args, **kwargs)

    def hc_init(self):
        r"""


        Initialize/Reset hard constraints to default values.  

        This function resets the hard constraints to their default values, i.e. all positions may be
        unpaired in all contexts, and base pairs are allowed in all contexts, if they resemble canonical
        pairs. Previously set hard constraints will be removed before initialization.  

        **SWIG Wrapper Notes**
            This function is attached as method `hc_init()` to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.hc_init()` in the :doc:`/api_python` .  

        Parameters
        ----------

        See Also
        --------
        RNA.fold_compound.hc_add_bp(), RNA.fold_compound.hc_add_bp_nonspecific(),
        RNA.fold_compound.hc_add_up()  

        """
        return _RNA.fold_compound_hc_init(self)

    def hc_add_up(self, *args, **kwargs):
        r"""
        hc_add_up(fold_compound self, int i, unsigned int option=VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS)


        Make a certain nucleotide unpaired.  

        Parameters
        ----------
        i : int
            The position that needs to stay unpaired (1-based)  
        option : unsigned char
            The options flag indicating how/where to store the hard constraints  

        See Also
        --------
        RNA.fold_compound.hc_add_bp(), RNA.fold_compound.hc_add_bp_nonspecific(),
        RNA.fold_compound.hc_init(), RNA.CONSTRAINT_CONTEXT_EXT_LOOP,
        RNA.CONSTRAINT_CONTEXT_HP_LOOP, RNA.CONSTRAINT_CONTEXT_INT_LOOP, RNA.CONSTRAINT_CONTEXT_MB_LOOP,
        RNA.CONSTRAINT_CONTEXT_ALL_LOOPS  

        """
        return _RNA.fold_compound_hc_add_up(self, *args, **kwargs)

    def hc_add_bp_nonspecific(self, *args, **kwargs):
        r"""
        hc_add_bp_nonspecific(fold_compound self, int i, int d, unsigned int option=VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS)


        Enforce a nucleotide to be paired (upstream/downstream)  

        Parameters
        ----------
        i : int
            The position that needs to stay unpaired (1-based)  
        d : int
            The direction of base pairing ( :math:`d < 0`: pairs upstream, :math:`d > 0`: pairs downstream,
            :math:`d == 0`: no direction)  
        option : unsigned char
            The options flag indicating in which loop type context the pairs may appear  

        See Also
        --------
        RNA.fold_compound.hc_add_bp(), RNA.fold_compound.hc_add_up(), RNA.fold_compound.hc_init(),
        RNA.CONSTRAINT_CONTEXT_EXT_LOOP,
        RNA.CONSTRAINT_CONTEXT_HP_LOOP, RNA.CONSTRAINT_CONTEXT_INT_LOOP,
        RNA.CONSTRAINT_CONTEXT_INT_LOOP_ENC, RNA.CONSTRAINT_CONTEXT_MB_LOOP,
        RNA.CONSTRAINT_CONTEXT_MB_LOOP_ENC, RNA.CONSTRAINT_CONTEXT_ALL_LOOPS  

        """
        return _RNA.fold_compound_hc_add_bp_nonspecific(self, *args, **kwargs)

    def hc_add_bp(self, *args, **kwargs):
        r"""
        hc_add_bp(fold_compound self, int i, int j, unsigned int option=VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS)


        Favorize/Enforce a certain base pair (i,j)  

        Parameters
        ----------
        i : int
            The 5' located nucleotide position of the base pair (1-based)  
        j : int
            The 3' located nucleotide position of the base pair (1-based)  
        option : unsigned char
            The options flag indicating how/where to store the hard constraints  

        See Also
        --------
        RNA.fold_compound.hc_add_bp_nonspecific(), RNA.fold_compound.hc_add_up(),
        RNA.fold_compound.hc_init(), RNA.CONSTRAINT_CONTEXT_EXT_LOOP,
        RNA.CONSTRAINT_CONTEXT_HP_LOOP, RNA.CONSTRAINT_CONTEXT_INT_LOOP,
        RNA.CONSTRAINT_CONTEXT_INT_LOOP_ENC, RNA.CONSTRAINT_CONTEXT_MB_LOOP,
        RNA.CONSTRAINT_CONTEXT_MB_LOOP_ENC, RNA.CONSTRAINT_CONTEXT_ENFORCE,
        RNA.CONSTRAINT_CONTEXT_ALL_LOOPS  

        """
        return _RNA.fold_compound_hc_add_bp(self, *args, **kwargs)

    def hc_add_from_db(self, *args, **kwargs):
        r"""
        hc_add_from_db(fold_compound self, char const * constraint, unsigned int options=) -> int


        Add hard constraints from pseudo dot-bracket notation.  

        This function allows one to apply hard constraints from a pseudo dot-bracket notation. The `options`
        parameter controls, which characters are recognized by the parser. Use the
        RNA.CONSTRAINT_DB_DEFAULT convenience macro, if you want to allow all known characters  

        **SWIG Wrapper Notes**
            This function is attached as method `hc_add_from_db()` to objects of type `fold_compound`. See,
            e.g.   :py:meth:`RNA.fold_compound.hc_add_from_db()` in the :doc:`/api_python` .  

        Parameters
        ----------
        constraint : const char *
            A pseudo dot-bracket notation of the hard constraint.  
        options : unsigned int
            The option flags  

        See Also
        --------
        RNA.CONSTRAINT_DB_PIPE, RNA.CONSTRAINT_DB_DOT, RNA.CONSTRAINT_DB_X, RNA.CONSTRAINT_DB_ANG_BRACK,
        RNA.CONSTRAINT_DB_RND_BRACK, RNA.CONSTRAINT_DB_INTRAMOL, RNA.CONSTRAINT_DB_INTERMOL,
        RNA.CONSTRAINT_DB_GQUAD  

        """
        return _RNA.fold_compound_hc_add_from_db(self, *args, **kwargs)

    def sc_remove(self):
        r"""


        Remove soft constraints from RNA.fold_compound().  

        **SWIG Wrapper Notes**
            This function is attached as method `sc_remove()` to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.sc_remove()` in the :doc:`/api_python` .  

        Parameters
        ----------

        Note
        ----
        Accepts RNA.fold_compound() of type RNA.FC_TYPE_SINGLE and RNA.FC_TYPE_COMPARATIVE  

        """
        return _RNA.fold_compound_sc_remove(self)

    def sc_init(self):
        r"""


        Initialize an empty soft constraints data structure within a RNA.fold_compound().  

        This function adds a proper soft constraints data structure to the RNA.fold_compound() data
        structure. If soft constraints already exist within the fold compound, they are removed.  

        **SWIG Wrapper Notes**
            This function is attached as method `sc_init()` to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.sc_init()` in the :doc:`/api_python` .  

        Parameters
        ----------

        See Also
        --------
        RNA.fold_compound.sc_set_bp(), RNA.fold_compound.sc_set_up(),
        RNA.fold_compound.sc_add_SHAPE_deigan(), RNA.fold_compound.sc_add_SHAPE_zarringhalam(),
        RNA.fold_compound.sc_remove(), RNA.fold_compound.sc_add(), RNA.fold_compound.sc_add_exp(),
        RNA.sc_add_pre(), RNA.sc_add_post()  

        Note
        ----
        Accepts RNA.fold_compound() of type RNA.FC_TYPE_SINGLE and RNA.FC_TYPE_COMPARATIVE  

        """
        return _RNA.fold_compound_sc_init(self)

    def sc_add_up(self, *args):
        r"""


        Add soft constraints for unpaired nucleotides.  

        **SWIG Wrapper Notes**
            This function is attached as an overloaded method `sc_add_up()` to objects of type
            `fold_compound`. The method either takes arguments for a single nucleotide :math:`i` with the
            corresponding energy value:  
         or an entire vector that stores free energy contributions for each nucleotide :math:`i` with
        :math:`1 \leq i \leq n`:  In both variants, the optional argument `options` defaults to
        RNA.OPTION_DEFAULT. See, e.g.   :py:meth:`RNA.fold_compound.sc_add_up()` in the :doc:`/api_python`
        .  

        Parameters
        ----------
        i : int
            The nucleotide position the soft constraint is added for  
        energy : FLT_OR_DBL
            The free energy (soft-constraint) in :math:`kcal / mol`  
        options : unsigned int
            The options flag indicating how/where to store the soft constraints  

        Returns
        -------
        int  
            Non-zero on successful application of the constraint, 0 otherwise.  

        See Also
        --------
        RNA.fold_compound.sc_set_up(), RNA.fold_compound.sc_add_bp(), RNA.fold_compound.sc_set_bp()  

        """
        return _RNA.fold_compound_sc_add_up(self, *args)

    def sc_add_bp(self, *args):
        r"""


        Add soft constraints for paired nucleotides.  

        **SWIG Wrapper Notes**
            This function is attached as an overloaded method `sc_add_bp()` to objects of type
            `fold_compound`. The method either takes arguments for a single base pair (i,j) with the
            corresponding energy value:  
         or an entire 2-dimensional matrix with dimensions n x n that stores free energy contributions for
        any base pair (i,j) with :math:`1 \leq i < j \leq n`:  In both variants, the optional argument
        `options` defaults to RNA.OPTION_DEFAULT. See, e.g.   :py:meth:`RNA.fold_compound.sc_add_bp()` in
        the :doc:`/api_python` .  

        Parameters
        ----------
        i : int
            The 5' position of the base pair the soft constraint is added for  
        j : int
            The 3' position of the base pair the soft constraint is added for  
        energy : FLT_OR_DBL
            The free energy (soft-constraint) in :math:`kcal / mol`  
        options : unsigned int
            The options flag indicating how/where to store the soft constraints  

        Returns
        -------
        int  
            Non-zero on successful application of the constraint, 0 otherwise.  

        See Also
        --------
        RNA.fold_compound.sc_set_bp(), RNA.fold_compound.sc_set_up(), RNA.fold_compound.sc_add_up()  

        """
        return _RNA.fold_compound_sc_add_bp(self, *args)

    def sc_set_bp(self, *args, **kwargs):
        r"""
        sc_set_bp(fold_compound self, DoubleDoubleVector constraints, unsigned int options=) -> int


        Set soft constraints for paired nucleotides.  

        **SWIG Wrapper Notes**
            This function is attached as method `sc_set_bp()` to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.sc_set_bp()` in the :doc:`/api_python` .  

        Parameters
        ----------
        constraints : const FLT_OR_DBL **
            A two-dimensional array of pseudo free energies in :math:`kcal / mol`  
        options : unsigned int
            The options flag indicating how/where to store the soft constraints  

        Returns
        -------
        int  
            Non-zero on successful application of the constraint, 0 otherwise.  

        See Also
        --------
        RNA.fold_compound.sc_add_bp(), RNA.fold_compound.sc_set_up(), RNA.fold_compound.sc_add_up()  

        Note
        ----
        This function replaces any pre-exisitng soft constraints with the ones supplied in `constraints`.  

        """
        return _RNA.fold_compound_sc_set_bp(self, *args, **kwargs)

    def sc_set_up(self, *args, **kwargs):
        r"""
        sc_set_up(fold_compound self, DoubleVector constraints, unsigned int options=) -> int


        Set soft constraints for unpaired nucleotides.  

        **SWIG Wrapper Notes**
            This function is attached as method `sc_set_up()` to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.sc_set_up()` in the :doc:`/api_python` .  

        Parameters
        ----------
        constraints : const FLT_OR_DBL *
            A vector of pseudo free energies in :math:`kcal / mol`  
        options : unsigned int
            The options flag indicating how/where to store the soft constraints  

        Returns
        -------
        int  
            Non-zero on successful application of the constraint, 0 otherwise.  

        See Also
        --------
        RNA.fold_compound.sc_add_up(), RNA.fold_compound.sc_set_bp(), RNA.fold_compound.sc_add_bp()  

        Note
        ----
        This function replaces any pre-exisitng soft constraints with the ones supplied in `constraints`.  

        """
        return _RNA.fold_compound_sc_set_up(self, *args, **kwargs)

    def sc_set_stack(self, *args):
        r"""
        sc_set_stack(fold_compound self, DoubleVector constraints, unsigned int options=) -> int
        sc_set_stack(fold_compound self, DoubleDoubleVector constraints, unsigned int options=) -> int


        """
        return _RNA.fold_compound_sc_set_stack(self, *args)

    def sc_add_stack(self, *args):
        r"""
        sc_add_stack(fold_compound self, int i, double energy, unsigned int options=) -> int
        sc_add_stack(fold_compound self, int i, DoubleVector energies, unsigned int options=) -> int


        """
        return _RNA.fold_compound_sc_add_stack(self, *args)

    def sc_mod_json(self, *args, **kwargs):
        r"""


        Prepare soft constraint callbacks for modified base as specified in JSON string.  

        This function prepares all requirements to acknowledge modified bases as specified in the provided
        `json` string. All subsequent predictions will treat each modification site special and adjust
        energy contributions if necessary.  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `sc_mod_json()` to objects of type
            `fold_compound` with default `options` = RNA.SC_MOD_DEFAULT. See, e.g.
            :py:meth:`RNA.fold_compound.sc_mod_json()` in the :doc:`/api_python` .  

        Parameters
        ----------
        json : const char *
            The JSON formatted string with the modified base parameters  
        modification_sites : const unsigned int *
            A list of modification site, i.e. positions that contain the modified base (1-based, last
            element in the list indicated by 0)  
        options : unsigned int
            A bitvector of options how to handle the input, e.g. RNA.SC_MOD_DEFAULT  

        Returns
        -------
        int  
            Number of sequence positions modified base parameters will be used for  

        See Also
        --------
        RNA.fold_compound.sc_mod_jsonfile(), RNA.fold_compound.sc_mod(), RNA.fold_compound.sc_mod_m6A(),
        RNA.fold_compound.sc_mod_pseudouridine(),
        RNA.fold_compound.sc_mod_inosine(), RNA.fold_compound.sc_mod_7DA(),
        RNA.fold_compound.sc_mod_purine(), RNA.fold_compound.sc_mod_dihydrouridine(),
        RNA.SC_MOD_CHECK_FALLBACK, RNA.SC_MOD_CHECK_UNMOD, RNA.SC_MOD_SILENT, RNA.SC_MOD_DEFAULT,
        modified-bases-params  

        """
        return _RNA.fold_compound_sc_mod_json(self, *args, **kwargs)

    def sc_mod_jsonfile(self, *args, **kwargs):
        r"""


        Prepare soft constraint callbacks for modified base as specified in JSON string.  

        Similar to RNA.fold_compound.sc_mod_json(), this function prepares all requirements to acknowledge modified bases
        as specified in the provided `json` file. All subsequent predictions will treat each modification
        site special and adjust energy contributions if necessary.  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `sc_mod_jsonfile()` to objects of type
            `fold_compound` with default `options` = RNA.SC_MOD_DEFAULT. See, e.g.
            :py:meth:`RNA.fold_compound.sc_mod_jsonfile()` in the :doc:`/api_python` .  

        Parameters
        ----------
        json :
            The JSON formatted string with the modified base parameters  
        modification_sites : const unsigned int *
            A list of modification site, i.e. positions that contain the modified base (1-based, last
            element in the list indicated by 0)  

        Returns
        -------
        int  
            Number of sequence positions modified base parameters will be used for  

        See Also
        --------
        RNA.fold_compound.sc_mod_json(), RNA.fold_compound.sc_mod(), RNA.fold_compound.sc_mod_m6A(),
        RNA.fold_compound.sc_mod_pseudouridine(),
        RNA.fold_compound.sc_mod_inosine(), RNA.fold_compound.sc_mod_7DA(),
        RNA.fold_compound.sc_mod_purine(), RNA.fold_compound.sc_mod_dihydrouridine(),
        RNA.SC_MOD_CHECK_FALLBACK, RNA.SC_MOD_CHECK_UNMOD, RNA.SC_MOD_SILENT, RNA.SC_MOD_DEFAULT,
        modified-bases-params  

        """
        return _RNA.fold_compound_sc_mod_jsonfile(self, *args, **kwargs)

    def sc_mod(self, *args, **kwargs):
        r"""


        Prepare soft constraint callbacks for modified base as specified in JSON string.  

        This function takes a RNA.sc_mod_param() data structure as obtained from
        RNA.sc_mod_read_from_json() or RNA.sc_mod_read_from_jsonfile() and prepares all requirements to
        acknowledge modified bases as specified in the provided `params` data structure. All subsequent
        predictions will treat each modification site special and adjust energy contributions if necessary.  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `sc_mod()` to objects of type `fold_compound`
            with default `options` = RNA.SC_MOD_DEFAULT. See, e.g.   :py:meth:`RNA.fold_compound.sc_mod()`
            in the :doc:`/api_python` .  

        Parameters
        ----------
        json :
            The JSON formatted string with the modified base parameters  
        modification_sites : const unsigned int *
            A list of modification site, i.e. positions that contain the modified base (1-based, last
            element in the list indicated by 0)  
        options : unsigned int
            A bitvector of options how to handle the input, e.g. RNA.SC_MOD_DEFAULT  

        Returns
        -------
        int  
            Number of sequence positions modified base parameters will be used for  

        See Also
        --------
        RNA.sc_mod_read_from_json(), RNA.sc_mod_read_from_jsonfile(), RNA.fold_compound.sc_mod_json(),
        RNA.fold_compound.sc_mod_jsonfile(), RNA.fold_compound.sc_mod_m6A(),
        RNA.fold_compound.sc_mod_pseudouridine(), RNA.fold_compound.sc_mod_inosine(),
        RNA.fold_compound.sc_mod_7DA(), RNA.fold_compound.sc_mod_purine(),
        RNA.sc_mod_dihydrouridine()RNA.SC_MOD_CHECK_FALLBACK,
        RNA.SC_MOD_CHECK_UNMOD, RNA.SC_MOD_SILENT, RNA.SC_MOD_DEFAULT  

        """
        return _RNA.fold_compound_sc_mod(self, *args, **kwargs)

    def sc_mod_m6A(self, *args, **kwargs):
        r"""


        Add soft constraint callbacks for N6-methyl-adenosine (m6A)  

        This is a convenience wrapper to add support for m6A using the soft constraint callback mechanism.
        Modification sites are provided as a list of sequence positions (1-based). Energy parameter
        corrections are derived from  :cite:t:`kierzek:2022` .  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `sc_mod_m6A()` to objects of type `fold_compound`
            with default `options` = RNA.SC_MOD_DEFAULT. See, e.g.
            :py:meth:`RNA.fold_compound.sc_mod_m6A()` in the :doc:`/api_python` .  

        Parameters
        ----------
        modification_sites : const unsigned int *
            A list of modification site, i.e. positions that contain the modified base (1-based, last
            element in the list indicated by 0)  
        options : unsigned int
            A bitvector of options how to handle the input, e.g. RNA.SC_MOD_DEFAULT  

        Returns
        -------
        int  
            Number of sequence positions modified base parameters will be used for  

        See Also
        --------
        RNA.SC_MOD_CHECK_FALLBACK, RNA.SC_MOD_CHECK_UNMOD, RNA.SC_MOD_SILENT, RNA.SC_MOD_DEFAULT  

        """
        return _RNA.fold_compound_sc_mod_m6A(self, *args, **kwargs)

    def sc_mod_pseudouridine(self, *args, **kwargs):
        r"""


        Add soft constraint callbacks for Pseudouridine.  

        This is a convenience wrapper to add support for pseudouridine using the soft constraint callback
        mechanism. Modification sites are provided as a list of sequence positions (1-based). Energy
        parameter corrections are derived from  :cite:t:`hudson:2013` .  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `sc_mod_pseudouridine()` to objects of type
            `fold_compound` with default `options` = RNA.SC_MOD_DEFAULT. See, e.g.
            :py:meth:`RNA.fold_compound.sc_mod_pseudouridine()` in the :doc:`/api_python` .  

        Parameters
        ----------
        modification_sites : const unsigned int *
            A list of modification site, i.e. positions that contain the modified base (1-based, last
            element in the list indicated by 0)  
        options : unsigned int
            A bitvector of options how to handle the input, e.g. RNA.SC_MOD_DEFAULT  

        Returns
        -------
        int  
            Number of sequence positions modified base parameters will be used for  

        See Also
        --------
        RNA.SC_MOD_CHECK_FALLBACK, RNA.SC_MOD_CHECK_UNMOD, RNA.SC_MOD_SILENT, RNA.SC_MOD_DEFAULT  

        """
        return _RNA.fold_compound_sc_mod_pseudouridine(self, *args, **kwargs)

    def sc_mod_inosine(self, *args, **kwargs):
        r"""


        Add soft constraint callbacks for Inosine.  

        This is a convenience wrapper to add support for inosine using the soft constraint callback
        mechanism. Modification sites are provided as a list of sequence positions (1-based). Energy
        parameter corrections are derived from  :cite:t:`wright:2007`  and  :cite:t:`wright:2018` .  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `sc_mod_inosine()` to objects of type
            `fold_compound` with default `options` = RNA.SC_MOD_DEFAULT. See, e.g.
            :py:meth:`RNA.fold_compound.sc_mod_inosine()` in the :doc:`/api_python` .  

        Parameters
        ----------
        modification_sites : const unsigned int *
            A list of modification site, i.e. positions that contain the modified base (1-based, last
            element in the list indicated by 0)  
        options : unsigned int
            A bitvector of options how to handle the input, e.g. RNA.SC_MOD_DEFAULT  

        Returns
        -------
        int  
            Number of sequence positions modified base parameters will be used for  

        See Also
        --------
        RNA.SC_MOD_CHECK_FALLBACK, RNA.SC_MOD_CHECK_UNMOD, RNA.SC_MOD_SILENT, RNA.SC_MOD_DEFAULT  

        """
        return _RNA.fold_compound_sc_mod_inosine(self, *args, **kwargs)

    def sc_mod_7DA(self, *args, **kwargs):
        r"""


        Add soft constraint callbacks for 7-deaza-adenosine (7DA)  

        This is a convenience wrapper to add support for 7-deaza-adenosine using the soft constraint
        callback mechanism. Modification sites are provided as a list of sequence positions (1-based).
        Energy parameter corrections are derived from  :cite:t:`richardson:2016` .  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `sc_mod_7DA()` to objects of type `fold_compound`
            with default `options` = RNA.SC_MOD_DEFAULT. See, e.g.
            :py:meth:`RNA.fold_compound.sc_mod_7DA()` in the :doc:`/api_python` .  

        Parameters
        ----------
        modification_sites : const unsigned int *
            A list of modification site, i.e. positions that contain the modified base (1-based, last
            element in the list indicated by 0)  
        options : unsigned int
            A bitvector of options how to handle the input, e.g. RNA.SC_MOD_DEFAULT  

        Returns
        -------
        int  
            Number of sequence positions modified base parameters will be used for  

        See Also
        --------
        RNA.SC_MOD_CHECK_FALLBACK, RNA.SC_MOD_CHECK_UNMOD, RNA.SC_MOD_SILENT, RNA.SC_MOD_DEFAULT  

        """
        return _RNA.fold_compound_sc_mod_7DA(self, *args, **kwargs)

    def sc_mod_purine(self, *args, **kwargs):
        r"""


        Add soft constraint callbacks for Purine (a.k.a. nebularine)  

        This is a convenience wrapper to add support for Purine using the soft constraint callback
        mechanism. Modification sites are provided as a list of sequence positions (1-based). Energy
        parameter corrections are derived from  :cite:t:`jolley:2017` .  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `sc_mod_purine()` to objects of type
            `fold_compound` with default `options` = RNA.SC_MOD_DEFAULT. See, e.g.
            :py:meth:`RNA.fold_compound.sc_mod_purine()` in the :doc:`/api_python` .  

        Parameters
        ----------
        modification_sites : const unsigned int *
            A list of modification site, i.e. positions that contain the modified base (1-based, last
            element in the list indicated by 0)  
        options : unsigned int
            A bitvector of options how to handle the input, e.g. RNA.SC_MOD_DEFAULT  

        Returns
        -------
        int  
            Number of sequence positions modified base parameters will be used for  

        See Also
        --------
        RNA.SC_MOD_CHECK_FALLBACK, RNA.SC_MOD_CHECK_UNMOD, RNA.SC_MOD_SILENT, RNA.SC_MOD_DEFAULT  

        """
        return _RNA.fold_compound_sc_mod_purine(self, *args, **kwargs)

    def sc_mod_dihydrouridine(self, *args, **kwargs):
        r"""


        Add soft constraint callbacks for dihydrouridine.  

        This is a convenience wrapper to add support for dihydrouridine using the soft constraint callback
        mechanism. Modification sites are provided as a list of sequence positions (1-based). Energy
        parameter corrections are derived from Rosetta/RECESS predictions.  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `sc_mod_dihydrouridine()` to objects of type
            `fold_compound` with default `options` = RNA.SC_MOD_DEFAULT. See, e.g.
            :py:meth:`RNA.fold_compound.sc_mod_dihydrouridine()` in the :doc:`/api_python` .  

        Parameters
        ----------
        modification_sites : const unsigned int *
            A list of modification site, i.e. positions that contain the modified base (1-based, last
            element in the list indicated by 0)  
        options : unsigned int
            A bitvector of options how to handle the input, e.g. RNA.SC_MOD_DEFAULT  

        Returns
        -------
        int  
            Number of sequence positions modified base parameters will be used for  

        See Also
        --------
        RNA.SC_MOD_CHECK_FALLBACK, RNA.SC_MOD_CHECK_UNMOD, RNA.SC_MOD_SILENT, RNA.SC_MOD_DEFAULT  

        """
        return _RNA.fold_compound_sc_mod_dihydrouridine(self, *args, **kwargs)

    def sc_add_SHAPE_deigan(self, *args, **kwargs):
        r"""
        sc_add_SHAPE_deigan(fold_compound self, DoubleVector reactivities, double m, double b, unsigned int options=) -> int


        Add SHAPE reactivity data as soft constraints (Deigan et al. method)  

        This approach of SHAPE directed RNA folding uses the simple linear ansatz  

        .. math::

          \Delta G_{\text{SHAPE}}(i) = m \ln(\text{SHAPE reactivity}(i)+1)+ b  

        to convert SHAPE reactivity values to pseudo energies whenever a nucleotide :math:`i` contributes to
        a stacked pair. A positive slope :math:`m` penalizes high reactivities in paired regions, while a
        negative intercept :math:`b` results in a confirmatory `bonus' free energy for correctly predicted
        base pairs. Since the energy evaluation of a base pair stack involves two pairs, the pseudo energies
        are added for all four contributing nucleotides. Consequently, the energy term is applied twice for
        pairs inside a helix and only once for pairs adjacent to other structures. For all other loop types
        the energy model remains unchanged even when the experimental data highly disagrees with a certain
        motif.  

        **SWIG Wrapper Notes**
            This function is attached as method `sc_add_SHAPE_deigan()` to objects of type `fold_compound`.
            See, e.g.   :py:meth:`RNA.fold_compound.sc_add_SHAPE_deigan()` in the :doc:`/api_python` .  

        Parameters
        ----------
        reactivities : const double *
            A vector of normalized SHAPE reactivities  
        m : double
            The slope of the conversion function  
        b : double
            The intercept of the conversion function  
        options : unsigned int
            The options flag indicating how/where to store the soft constraints  

        Returns
        -------
        int  
            1 on successful extraction of the method, 0 on errors  

        See Also
        --------
        RNA.fold_compound.sc_remove(), RNA.fold_compound.sc_add_SHAPE_zarringhalam(),
        RNA.sc_minimize_pertubation()  

        Note
        ----
        For further details, we refer to  :cite:t:`deigan:2009` .  

        """
        return _RNA.fold_compound_sc_add_SHAPE_deigan(self, *args, **kwargs)

    def sc_add_SHAPE_deigan_ali(self, *args, **kwargs):
        r"""
        sc_add_SHAPE_deigan_ali(fold_compound self, StringVector shape_files, IntVector shape_file_association, double m, double b, unsigned int options=) -> int


        Add SHAPE reactivity data from files as soft constraints for consensus structure prediction (Deigan
        et al. method)  

        **SWIG Wrapper Notes**
            This function is attached as method `sc_add_SHAPE_deigan_ali()` to objects of type
            `fold_compound`. See, e.g.   :py:meth:`RNA.fold_compound.sc_add_SHAPE_deigan_ali()` in the
            :doc:`/api_python` .  

        Parameters
        ----------
        shape_files : const char **
            A set of filenames that contain normalized SHAPE reactivity data  
        shape_file_association : const int *
            An array of integers that associate the files with sequences in the alignment  
        m : double
            The slope of the conversion function  
        b : double
            The intercept of the conversion function  
        options : unsigned int
            The options flag indicating how/where to store the soft constraints  

        Returns
        -------
        int  
            1 on successful extraction of the method, 0 on errors  

        """
        return _RNA.fold_compound_sc_add_SHAPE_deigan_ali(self, *args, **kwargs)

    def sc_add_SHAPE_zarringhalam(self, *args, **kwargs):
        r"""
        sc_add_SHAPE_zarringhalam(fold_compound self, DoubleVector reactivities, double b, double default_value, char const * shape_conversion, unsigned int options=) -> int


        Add SHAPE reactivity data as soft constraints (Zarringhalam et al. method)  

        This method first converts the observed SHAPE reactivity of nucleotide :math:`i` into a probability
        :math:`q_{i}` that position :math:`i` is unpaired by means of a non-linear map. Then pseudo-energies
        of the form  

        .. math::

          \Delta G_{\text{SHAPE}}(x,i) = \beta\ |x_{i} - q_{i}|  

        are computed, where :math:`x_{i}=0` if position :math:`i` is unpaired and :math:`x_{i}=1` if
        :math:`i` is paired in a given secondary structure. The parameter :math:`\beta` serves as scaling
        factor. The magnitude of discrepancy between prediction and experimental observation is represented
        by :math:`|x_{i} - q_{i}|`.  

        **SWIG Wrapper Notes**
            This function is attached as method `sc_add_SHAPE_zarringhalam()` to objects of type
            `fold_compound`. See, e.g.   :py:meth:`RNA.fold_compound.sc_add_SHAPE_zarringhalam()` in the
            :doc:`/api_python` .  

        Parameters
        ----------
        reactivities : const double *
            A vector of normalized SHAPE reactivities  
        b : double
            The scaling factor :math:`\beta` of the conversion function  
        default_value : double
            The default value for a nucleotide where reactivity data is missing for  
        shape_conversion : const char *
            A flag that specifies how to convert reactivities to probabilities  
        options : unsigned int
            The options flag indicating how/where to store the soft constraints  

        Returns
        -------
        int  
            1 on successful extraction of the method, 0 on errors  

        See Also
        --------
        RNA.fold_compound.sc_remove(), RNA.fold_compound.sc_add_SHAPE_deigan(),
        RNA.sc_minimize_pertubation()  

        Note
        ----
        For further details, we refer to  :cite:t:`zarringhalam:2012`  

        """
        return _RNA.fold_compound_sc_add_SHAPE_zarringhalam(self, *args, **kwargs)

    def sc_add_hi_motif(self, *args, **kwargs):
        r"""
        sc_add_hi_motif(fold_compound self, char const * seq, char const * structure, FLT_OR_DBL energy, unsigned int options=) -> int


        Add soft constraints for hairpin or interior loop binding motif.  

        Here is an example that adds a theophylline binding motif. Free energy contribution is derived from
        :math:`k_{d} = 0.1 \mu M`, taken from Jenison et al. 1994. At :math:`1M` concentration the
        corresponding binding free energy amounts to :math:`-9.93~kcal/mol`.  

        theo_aptamer.svg  


        **SWIG Wrapper Notes**
            This function is attached as method `sc_add_hi_motif()` to objects of type `fold_compound`. The
            last parameter is optional an defaults to `options` = RNA.OPTION_DEFAULT. See, e.g.
            :py:meth:`RNA.fold_compound.sc_add_hi_motif()` in the :doc:`/api_python` .  

        Parameters
        ----------
        seq : const char *
            The sequence motif (may be interspaced by '&' character  
        structure : const char *
            The structure motif (may be interspaced by '&' character  
        energy : FLT_OR_DBL
            The free energy of the motif (e.g. binding free energy)  
        options : unsigned int
            Options  

        Returns
        -------
        int  
            non-zero value if application of the motif using soft constraints was successful  

        """
        return _RNA.fold_compound_sc_add_hi_motif(self, *args, **kwargs)

    def eval_structure(self, structure):
        r"""


        Calculate the free energy of an already folded RNA.  

        This function allows for energy evaluation of a given pair of structure and sequence (alignment).
        Model details, energy parameters, and possibly soft constraints are used as provided via the
        parameter 'fc'. The RNA.fold_compound() does not need to contain any DP matrices, but requires all
        most basic init values as one would get from a call like this:  

        **SWIG Wrapper Notes**
            This function is attached as method `eval_structure()` to objects of type `fold_compound`. See,
            e.g.   :py:meth:`RNA.fold_compound.eval_structure()` in the :doc:`/api_python` .  

        Parameters
        ----------
        structure : const char *
            Secondary structure in dot-bracket notation  

        Returns
        -------
        float  
            The free energy of the input structure given the input sequence in kcal/mol  

        See Also
        --------
        RNA.fold_compound.eval_structure_pt(), RNA.fold_compound.eval_structure_verbose(),
        RNA.fold_compound.eval_structure_pt_verbose(),
        RNA.fold_compound(), RNA.fold_compound_comparative(), RNA.fold_compound.eval_covar_structure()  

        Note
        ----
        Accepts RNA.fold_compound() of type RNA.FC_TYPE_SINGLE and RNA.FC_TYPE_COMPARATIVE  

        """
        return _RNA.fold_compound_eval_structure(self, structure)

    def eval_structure_pt(self, *args):
        r"""


        Calculate the free energy of an already folded RNA.  

        This function allows for energy evaluation of a given sequence/structure pair where the structure is
        provided in pair_table format as obtained from RNA.ptable(). Model details, energy parameters, and
        possibly soft constraints are used as provided via the parameter 'fc'. The fold_compound does not
        need to contain any DP matrices, but all the most basic init values as one would get from a call
        like this:  

        **SWIG Wrapper Notes**
            This function is attached as method `eval_structure_pt()` to objects of type `fold_compound`.
            See, e.g.   :py:meth:`RNA.fold_compound.eval_structure_pt()` in the :doc:`/api_python` .  

        Parameters
        ----------
        pt : const short *
            Secondary structure as pair_table  

        Returns
        -------
        int  
            The free energy of the input structure given the input sequence in 10cal/mol  

        See Also
        --------
        RNA.ptable(), RNA.fold_compound.eval_structure(), RNA.fold_compound.eval_structure_pt_verbose()  

        """
        return _RNA.fold_compound_eval_structure_pt(self, *args)

    def eval_structure_verbose(self, structure, nullfile=None):
        r"""


        Calculate the free energy of an already folded RNA and print contributions on a per-loop base.  

        This function is a simplyfied version of RNA.eval_structure_v() that uses the *default* verbosity
        level.  

        **SWIG Wrapper Notes**
            This function is attached as method `eval_structure_verbose()` to objects of type
            `fold_compound`. See, e.g.   :py:meth:`RNA.fold_compound.eval_structure_verbose()` in the
            :doc:`/api_python` .  

        Parameters
        ----------
        structure : const char *
            Secondary structure in dot-bracket notation  
        file : FILE *
            A file handle where this function should print to (may be NULL).  

        Returns
        -------
        float  
            The free energy of the input structure given the input sequence in kcal/mol  

        See Also
        --------
        RNA.fold_compound.eval_structure_pt(), RNA.fold_compound.eval_structure_verbose(),
        RNA.fold_compound.eval_structure_pt_verbose(),  

        """
        return _RNA.fold_compound_eval_structure_verbose(self, structure, nullfile)

    def eval_structure_pt_verbose(self, *args):
        r"""


        Calculate the free energy of an already folded RNA.  

        This function is a simplyfied version of RNA.eval_structure_simple_v() that uses the *default*
        verbosity level.  

        **SWIG Wrapper Notes**
            This function is attached as method `eval_structure_pt_verbose()` to objects of type
            `fold_compound`. See, e.g.   :py:meth:`RNA.fold_compound.eval_structure_pt_verbose()` in the
            :doc:`/api_python` .  

        Parameters
        ----------
        pt : const short *
            Secondary structure as pair_table  
        file : FILE *
            A file handle where this function should print to (may be NULL).  

        Returns
        -------
        int  
            The free energy of the input structure given the input sequence in 10cal/mol  

        See Also
        --------
        RNA.eval_structure_pt_v(), RNA.ptable(), RNA.fold_compound.eval_structure_pt(),
        RNA.fold_compound.eval_structure_verbose()  

        """
        return _RNA.fold_compound_eval_structure_pt_verbose(self, *args)

    def eval_covar_structure(self, structure):
        r"""


        Calculate the pseudo energy derived by the covariance scores of a set of aligned sequences.  

        Consensus structure prediction is driven by covariance scores of base pairs in rows of the provided
        alignment. This function allows one to retrieve the total amount of this covariance pseudo energy
        scores. The RNA.fold_compound() does not need to contain any DP matrices, but requires all most
        basic init values as one would get from a call like this:  

        **SWIG Wrapper Notes**
            This function is attached as method `eval_covar_structure()` to objects of type `fold_compound`.
            See, e.g.   :py:meth:`RNA.fold_compound.eval_covar_structure()` in the :doc:`/api_python` .  

        Parameters
        ----------
        structure : const char *
            Secondary (consensus) structure in dot-bracket notation  

        Returns
        -------
        float  
            The covariance pseudo energy score of the input structure given the input sequence alignment in
            kcal/mol  

        See Also
        --------
        RNA.fold_compound_comparative(), RNA.fold_compound.eval_structure()  

        Note
        ----
        Accepts RNA.fold_compound() of type RNA.FC_TYPE_COMPARATIVE only!  

        """
        return _RNA.fold_compound_eval_covar_structure(self, structure)

    def eval_loop_pt(self, *args):
        r"""


        Calculate energy of a loop.  

        **SWIG Wrapper Notes**
            This function is attached as method `eval_loop_pt()` to objects of type `fold_compound`. See,
            e.g.   :py:meth:`RNA.fold_compound.eval_loop_pt()` in the :doc:`/api_python` .  

        Parameters
        ----------
        i : int
            position of covering base pair  
        pt : const short *
            the pair table of the secondary structure  

        Returns
        -------
        int  
            free energy of the loop in 10cal/mol  

        """
        return _RNA.fold_compound_eval_loop_pt(self, *args)

    def eval_move(self, structure, m1, m2):
        r"""


        Calculate energy of a move (closing or opening of a base pair)  

        If the parameters m1 and m2 are negative, it is deletion (opening) of a base pair, otherwise it is
        insertion (opening).  

        **SWIG Wrapper Notes**
            This function is attached as method `eval_move()` to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.eval_move()` in the :doc:`/api_python` .  

        Parameters
        ----------
        structure : const char *
            secondary structure in dot-bracket notation  
        m1 : int
            first coordinate of base pair  
        m2 : int
            second coordinate of base pair  

        Returns
        -------
        float  
            energy change of the move in kcal/mol (INF / 100. upon any error)  

        See Also
        --------
        RNA.fold_compound.eval_move_pt()  

        """
        return _RNA.fold_compound_eval_move(self, structure, m1, m2)

    def eval_move_pt(self, *args):
        r"""


        Calculate energy of a move (closing or opening of a base pair)  

        If the parameters m1 and m2 are negative, it is deletion (opening) of a base pair, otherwise it is
        insertion (opening).  

        **SWIG Wrapper Notes**
            This function is attached as method `eval_move_pt()` to objects of type `fold_compound`. See,
            e.g.   :py:meth:`RNA.fold_compound.eval_move_pt()` in the :doc:`/api_python` .  

        Parameters
        ----------
        pt : short *
            the pair table of the secondary structure  
        m1 : int
            first coordinate of base pair  
        m2 : int
            second coordinate of base pair  

        Returns
        -------
        int  
            energy change of the move in 10cal/mol  

        See Also
        --------
        RNA.fold_compound.eval_move()  

        """
        return _RNA.fold_compound_eval_move_pt(self, *args)

    def eval_ext_stem(self, i, j):
        r"""


        Evaluate the free energy of a base pair in the exterior loop.  

        Evalue the free energy of a base pair connecting two nucleotides in the exterior loop and take hard
        constraints into account.  

        Typically, this is simply dangling end contributions of the adjacent nucleotides, potentially a
        terminal A-U mismatch penalty, and maybe some generic soft constraint contribution for that
        decomposition.  

        Parameters
        ----------
        i : int
            5' position of the base pair  
        j : int
            3' position of the base pair  

        Returns
        -------
        int  
            Free energy contribution that arises when this pair is formed in the exterior loop  

        Note
        ----
        For dangles == 1 || 3 this function also evaluates the three additional pairs (i + 1, j), (i, j -
        1), and (i + 1, j - 1) and returns the minimum for all four possibilities in total.  

        """
        return _RNA.fold_compound_eval_ext_stem(self, i, j)

    def E_hp_loop(self, i, j):
        r"""


        Evaluate the free energy of a hairpin loop and consider hard constraints if they apply.  

        This function evaluates the free energy of a hairpin loop  

        In case the base pair is not allowed due to a constraint conflict, this function returns INF.  

        Parameters
        ----------
        i : int
            The 5' nucleotide of the base pair (3' to evaluate the pair as exterior hairpin loop)  
        j : int
            The 3' nucleotide of the base pair (5' to evaluate the pair as exterior hairpin loop)  

        Returns
        -------
        int  
            The free energy of the hairpin loop in 10cal/mol  

        Note
        ----
        This function is polymorphic! The provided RNA.fold_compound() may be of type RNA.FC_TYPE_SINGLE
        or RNA.FC_TYPE_COMPARATIVE  

        """
        return _RNA.fold_compound_E_hp_loop(self, i, j)

    def E_ext_hp_loop(self, i, j):
        r"""


        Evaluate the free energy of an exterior hairpin loop and consider possible hard constraints.  

        Note
        ----
        This function is polymorphic! The provided RNA.fold_compound() may be of type RNA.FC_TYPE_SINGLE
        or RNA.FC_TYPE_COMPARATIVE  

        """
        return _RNA.fold_compound_E_ext_hp_loop(self, i, j)

    def eval_ext_hp_loop(self, i, j):
        r"""


        Evaluate free energy of an exterior hairpin loop.  

        """
        return _RNA.fold_compound_eval_ext_hp_loop(self, i, j)

    def eval_hp_loop(self, i, j):
        r"""
        eval_hp_loop(fold_compound self, int i, int j) -> int


        Evaluate free energy of a hairpin loop.  

        **SWIG Wrapper Notes**
            This function is attached as method `eval_hp_loop()` to objects of type `fold_compound`. See,
            e.g.   :py:meth:`RNA.fold_compound.eval_hp_loop()` in the :doc:`/api_python` .  

        Parameters
        ----------
        i : int
            5'-position of the base pair  
        j : int
            3'-position of the base pair  

        Returns
        -------
        int  
            Free energy of the hairpin loop closed by :math:`(i,j)` in deka-kal/mol  

        Note
        ----
        This function is polymorphic! The provided RNA.fold_compound() may be of type RNA.FC_TYPE_SINGLE
        or RNA.FC_TYPE_COMPARATIVE  

        """
        return _RNA.fold_compound_eval_hp_loop(self, i, j)

    def exp_E_hp_loop(self, i, j):
        r"""


        High-Level function for hairpin loop energy evaluation (partition function variant)  

        See Also
        --------
        RNA.fold_compound.E_hp_loop() for it's free energy counterpart  

        Note
        ----
        This function is polymorphic! The provided RNA.fold_compound() may be of type RNA.FC_TYPE_SINGLE
        or RNA.FC_TYPE_COMPARATIVE  

        """
        return _RNA.fold_compound_exp_E_hp_loop(self, i, j)

    def E_int_loop(self, i, j):
        r"""


        """
        return _RNA.fold_compound_E_int_loop(self, i, j)

    def eval_int_loop(self, i, j, k, l):
        r"""
        eval_int_loop(fold_compound self, int i, int j, int k, int l) -> int


        Evaluate the free energy contribution of an interior loop with delimiting base pairs :math:`(i,j)`
        and :math:`(k,l)`.  

        **SWIG Wrapper Notes**
            This function is attached as method `eval_int_loop()` to objects of type `fold_compound`. See,
            e.g.   :py:meth:`RNA.fold_compound.eval_int_loop()` in the :doc:`/api_python` .  

        Note
        ----
        This function is polymorphic, i.e. it accepts RNA.fold_compound() of type RNA.FC_TYPE_SINGLE as
        well as RNA.FC_TYPE_COMPARATIVE  

        """
        return _RNA.fold_compound_eval_int_loop(self, i, j, k, l)

    def E_ext_int_loop(self, i, j):
        r"""


        """
        return _RNA.fold_compound_E_ext_int_loop(self, i, j)

    def E_stack(self, i, j):
        r"""


        """
        return _RNA.fold_compound_E_stack(self, i, j)

    def exp_E_int_loop(self, i, j):
        r"""


        """
        return _RNA.fold_compound_exp_E_int_loop(self, i, j)

    def exp_E_interior_loop(self, i, j, k, l):
        r"""


        """
        return _RNA.fold_compound_exp_E_interior_loop(self, i, j, k, l)

    def exp_E_ext_stem(self, i, j):
        r"""


        Evaluate a stem branching off the exterior loop (Boltzmann factor version)  

        Given a base pair :math:`(i,j)` encoded by *type*, compute the energy contribution including
        dangling-end/terminal-mismatch contributions. Instead of returning the energy contribution per-se,
        this function returns the corresponding Boltzmann factor. If either of the adjacent nucleotides
        :math:`(i - 1)` and :math:`(j+1)` must not contribute stacking energy, the corresponding encoding
        must be :math:`-1`.  

        Parameters
        ----------
        type : unsigned int
            The base pair encoding  
        n5d : int
            The encoded nucleotide directly adjacent at the 5' side of the base pair (may be -1)  
        n3d : int
            The encoded nucleotide directly adjacent at the 3' side of the base pair (may be -1)  
        p : RNA.exp_param() *
            The pre-computed energy parameters (Boltzmann factor version)  

        Returns
        -------
        FLT_OR_DBL  
            The Boltzmann weighted energy contribution of the introduced exterior-loop stem  

        See Also
        --------
        RNA.E_ext_stem()  

        """
        return _RNA.fold_compound_exp_E_ext_stem(self, i, j)

    def maxmimum_matching(self):
        return _RNA.fold_compound_maxmimum_matching(self)

    def mfe(self):
        r"""
        mfe() -> (structure, energy)


        Compute minimum free energy and an appropriate secondary structure of an RNA sequence, or RNA
        sequence alignment.  

        Depending on the type of the provided RNA.fold_compound(), this function predicts the MFE for a
        single sequence (or connected component of multiple sequences), or an averaged MFE for a sequence
        alignment. If backtracking is activated, it also constructs the corresponding secondary structure,
        or consensus structure. Therefore, the second parameter, *structure*, has to point to an allocated
        block of memory with a size of at least :math:`\mathrm{strlen}(\mathrm{sequence})+1` to store the
        backtracked MFE structure. (For consensus structures, this is the length of the alignment + 1. If
        `NULL` is passed, no backtracking will be performed.  

        **SWIG Wrapper Notes**
            This function is attached as method `mfe()` to objects of type `fold_compound`. The parameter
            `structure` is returned along with the MFE und must not be provided. See e.g.
            :py:meth:`RNA.fold_compound.mfe()` in the :doc:`/api_python`.  

        Parameters
        ----------
        structure : char *
            A pointer to the character array where the secondary structure in dot-bracket notation will be
            written to (Maybe NULL)  

        Returns
        -------
        float  
            the minimum free energy (MFE) in kcal/mol  

        See Also
        --------
        RNA.fold_compound(), RNA.fold_compound(), RNA.fold(), RNA.circfold(),
        RNA.fold_compound_comparative(), RNA.alifold(), RNA.circalifold()  

        Note
        ----
        This function is polymorphic. It accepts RNA.fold_compound() of type RNA.FC_TYPE_SINGLE, and
        RNA.FC_TYPE_COMPARATIVE.  

        """
        return _RNA.fold_compound_mfe(self)

    def mfe_dimer(self):
        r"""
        mfe_dimer(fold_compound self) -> char *


        Compute the minimum free energy of two interacting RNA molecules.  

        The code is analog to the RNA.fold_compound.mfe() function.  

        .. deprecated:: 2.6.4
            This function is obsolete since RNA.fold_compound.mfe() can handle complexes multiple sequences
        since v2.5.0.
            Use RNA.fold_compound.mfe() for connected component MFE instead and compute MFEs of unconnected
        states
            separately.  

        **SWIG Wrapper Notes**
            This function is attached as method `mfe_dimer()` to objects of type `fold_compound`. The
            parameter `structure` is returned along with the MFE und must not be provided. See e.g.
            :py:meth:`RNA.fold_compound.mfe_dimer()` in the :doc:`/api_python`.  

        Parameters
        ----------
        structure : char *
            Will hold the barcket dot structure of the dimer molecule  

        Returns
        -------
        float  
            minimum free energy of the structure  

        See Also
        --------
        RNA.fold_compound.mfe()  

        """
        return _RNA.fold_compound_mfe_dimer(self)

    def backtrack(self, *args):
        r"""
        backtrack(fold_compound self, unsigned int length) -> char
        backtrack(fold_compound self) -> char *


        Backtrack an MFE (sub)structure.  

        This function allows one to backtrack the MFE structure for a (sub)sequence  

        **Precondition**
            Requires pre-filled MFE dynamic programming matrices, i.e. one has to call
        RNA.fold_compound.mfe() prior to
            calling this function  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `backtrack()` to objects of type `fold_compound`.
            The parameter `length` defaults to the total length of the RNA sequence and may be omitted. The
            parameter `structure` is returned along with the MFE und must not be provided. See e.g.
            :py:meth:`RNA.fold_compound.backtrack()` in the :doc:`/api_python`.  

        Parameters
        ----------
        length : unsigned int
            The length of the subsequence, starting from the 5' end  
        structure : char *
            A pointer to the character array where the secondary structure in dot-bracket notation will be
            written to. (Must have size of at least $p length + 1)  

        Returns
        -------
        float  
            The minimum free energy (MFE) for the specified `length` in kcal/mol and a corresponding
            secondary structure in dot-bracket notation (stored in `structure`)  

        See Also
        --------
        RNA.fold_compound.mfe(), RNA.fold_compound.pbacktrack5()  

        Note
        ----
        On error, the function returns INF / 100. and stores the empty string in `structure`.  

        """
        return _RNA.fold_compound_backtrack(self, *args)

    def mfe_window(self, nullfile=None):
        r"""


        Local MFE prediction using a sliding window approach.  

        Computes minimum free energy structures using a sliding window approach, where base pairs may not
        span outside the window. In contrast to RNA.fold_compound.mfe(), where a maximum base pair span may be set using
        the RNA.md().max_bp_span attribute and one globally optimal structure is predicted, this function
        uses a sliding window to retrieve all locally optimal structures within each window. The size of the
        sliding window is set in the RNA.md().window_size attribute, prior to the retrieval of the
        RNA.fold_compound() using RNA.fold_compound() with option RNA.OPTION_WINDOW  

        The predicted structures are written on-the-fly, either to stdout, if a NULL pointer is passed as
        file parameter, or to the corresponding filehandle.  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `mfe_window()` to objects of type
            `fold_compound`. The parameter `FILE` has default value of `NULL` and can be omitted. See e.g.
            :py:meth:`RNA.fold_compound.mfe_window()` in the :doc:`/api_python`.  

        Parameters
        ----------
        file : FILE *
            The output file handle where predictions are written to (maybe NULL)  

        See Also
        --------
        RNA.fold_compound(), RNA.fold_compound.mfe_window_zscore(), RNA.fold_compound.mfe(), RNA.Lfold(),
        RNA.Lfoldz(),
        RNA.OPTION_WINDOW, RNA.md().max_bp_span, RNA.md().window_size  

        """
        return _RNA.fold_compound_mfe_window(self, nullfile)

    def mfe_window_zscore(self, min_z, nullfile=None):
        r"""


        Local MFE prediction using a sliding window approach (with z-score cut-off)  

        Computes minimum free energy structures using a sliding window approach, where base pairs may not
        span outside the window. This function is the z-score version of RNA.fold_compound.mfe_window(), i.e. only
        predictions above a certain z-score cut-off value are printed. As for RNA.fold_compound.mfe_window(), the size of
        the sliding window is set in the RNA.md().window_size attribute, prior to the retrieval of the
        RNA.fold_compound() using RNA.fold_compound() with option RNA.OPTION_WINDOW.  

        The predicted structures are written on-the-fly, either to stdout, if a NULL pointer is passed as
        file parameter, or to the corresponding filehandle.  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `mfe_window_zscore()` to objects of type
            `fold_compound`. The parameter `FILE` has default value of `NULL` and can be omitted. See e.g.
            :py:meth:`RNA.fold_compound.mfe_window_zscore()` in the :doc:`/api_python`.  

        Parameters
        ----------
        min_z : double
            The minimal z-score for a predicted structure to appear in the output  
        file : FILE *
            The output file handle where predictions are written to (maybe NULL)  

        See Also
        --------
        RNA.fold_compound(), RNA.fold_compound.mfe_window_zscore(), RNA.fold_compound.mfe(), RNA.Lfold(),
        RNA.Lfoldz(),
        RNA.OPTION_WINDOW, RNA.md().max_bp_span, RNA.md().window_size  

        """
        return _RNA.fold_compound_mfe_window_zscore(self, min_z, nullfile)

    def zsc_filter_init(self, *args, **kwargs):
        r"""


        """
        return _RNA.fold_compound_zsc_filter_init(self, *args, **kwargs)

    def zsc_filter_update(self, *args, **kwargs):
        r"""


        """
        return _RNA.fold_compound_zsc_filter_update(self, *args, **kwargs)

    def zsc_filter_free(self):
        r"""


        """
        return _RNA.fold_compound_zsc_filter_free(self)

    def zsc_filter_on(self):
        r"""


        """
        return _RNA.fold_compound_zsc_filter_on(self)

    def zsc_filter_threshold(self):
        r"""


        """
        return _RNA.fold_compound_zsc_filter_threshold(self)

    def zsc_compute(self, i, j, e):
        r"""


        """
        return _RNA.fold_compound_zsc_compute(self, i, j, e)

    def zsc_compute_raw(self, i, j, e):
        r"""


        """
        return _RNA.fold_compound_zsc_compute_raw(self, i, j, e)

    def pf(self):
        r"""


        Compute the partition function :math:`Q` for a given RNA sequence, or sequence alignment.  

        If *structure* is not a NULL pointer on input, it contains on return a string consisting of the
        letters " . , | { } ( ) " denoting bases that are essentially unpaired, weakly paired, strongly
        paired without preference, weakly upstream (downstream) paired, or strongly up- (down-)stream paired
        bases, respectively. If the model's compute_bpp is set to 0 base pairing probabilities will not be
        computed (saving CPU time), otherwise after calculations took place pr will contain the probability
        that bases *i* and *j* pair.  

        **SWIG Wrapper Notes**
            This function is attached as method `pf()` to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.pf()` in the :doc:`/api_python`.  

        Parameters
        ----------
        structure : char *
            A pointer to the character array where position-wise pairing propensity will be stored. (Maybe
            NULL)  

        Returns
        -------
        FLT_OR_DBL  
            The ensemble free energy :math:`G = -RT \cdot \log(Q)` in kcal/mol  

        See Also
        --------
        RNA.fold_compound(), RNA.fold_compound(), RNA.pf_fold(), RNA.pf_circfold(),
        RNA.fold_compound_comparative(), RNA.pf_alifold(), RNA.pf_circalifold(), RNA.db_from_probs(),
        RNA.exp_params(), RNA.aln_pinfo()  

        Note
        ----
        This function is polymorphic. It accepts RNA.fold_compound() of type RNA.FC_TYPE_SINGLE, and
        RNA.FC_TYPE_COMPARATIVE. Also, this function may return INF / 100. in case of contradicting
        constraints or numerical over-/underflow. In the latter case, a corresponding warning will be issued
        to `stdout`.  

        """
        return _RNA.fold_compound_pf(self)

    def mean_bp_distance(self):
        r"""


        Get the mean base pair distance in the thermodynamic ensemble.  

        .. math::

          <d> = \sum_{a,b} p_{a} p_{b} d(S_{a},S_{b})  

        this can be computed from the pair probs :math:`p_{ij}` as  

        .. math::

          <d> = \sum_{ij} p_{ij}(1-p_{ij})  

        **SWIG Wrapper Notes**
            This function is attached as method `mean_bp_distance()` to objects of type `fold_compound`.
            See, e.g.  :py:meth:`RNA.fold_compound.mean_bp_distance()` in the :doc:`/api_python`.  

        Parameters
        ----------

        Returns
        -------
        double  
            The mean pair distance of the structure ensemble  

        """
        return _RNA.fold_compound_mean_bp_distance(self)

    def ensemble_defect(self, *args):
        r"""


        Compute the Ensemble Defect for a given target structure.  

        This is a wrapper around **RNA.ensemble_defect_pt()**. Given a target structure :math:`s`, compute
        the average dissimilarity of a randomly drawn structure from the ensemble, i.e.:  

        .. math::

          ED(s) = 1 - \frac{1}{n} \sum_{ij, (i,j) \in s} p_{ij} - \frac{1}{n} \sum_{i}(1 - s_{i})q_{i}  

        with sequence length :math:`n`, the probability :math:`p_{ij}` of a base pair :math:`(i,j)`, the
        probability :math:`q_{i} = 1 - \sum_{j} p_{ij}` of nucleotide :math:`i` being unpaired, and the
        indicator variable :math:`s_{i} = 1` if :math:`\exists (i,j) \in s`, and :math:`s_{i} = 0`
        otherwise.  

        **Precondition**
            The RNA.fold_compound() input parameter `fc` must contain a valid base pair probability matrix.
            This means that partition function and base pair probabilities must have been computed using
            `fc` before execution of this function!  

        **SWIG Wrapper Notes**
            This function is attached as method `ensemble_defect()` to objects of type `fold_compound`. Note
            that the SWIG wrapper takes a structure in dot-bracket notation and converts it into a pair
            table using RNA.ptable_from_string(). The resulting pair table is then internally passed to
            RNA.ensemble_defect_pt(). To control which kind of matching brackets will be used during
            conversion, the optional argument `options` can be used. See also the description of
            RNA.ptable_from_string() for available options. (default: `RNA.BRACKETS_RND`). See, e.g.
            :py:meth:`RNA.fold_compound.ensemble_defect()` in the :doc:`/api_python`.  

        Parameters
        ----------
        structure : const char *
            A target structure in dot-bracket notation  

        Returns
        -------
        double  
            The ensemble defect with respect to the target structure, or -1. upon failure, e.g. pre-
            conditions are not met  

        See Also
        --------
        RNA.fold_compound.pf(), RNA.pairing_probs(), RNA.ensemble_defect_pt()  

        """
        return _RNA.fold_compound_ensemble_defect(self, *args)

    def positional_entropy(self):
        r"""


        Compute a vector of positional entropies.  

        This function computes the positional entropies from base pair probabilities as  

        .. math::

          S(i) = - \sum_{j} p_{ij} \log(p_{ij}) - q_{i} \log(q_{i})  

        with unpaired probabilities :math:`q_{i} = 1 - \sum_{j} p_{ij}`.  

        Low entropy regions have little structural flexibility and the reliability of the predicted
        structure is high. High entropy implies many structural alternatives. While these alternatives may
        be functionally important, they make structure prediction more difficult and thus less reliable.  

        **Precondition**
            This function requires pre-computed base pair probabilities! Thus, RNA.fold_compound.pf() must
        be called
            beforehand.  

        **SWIG Wrapper Notes**
            This function is attached as method `positional_entropy()` to objects of type `fold_compound`.
            See, e.g.  :py:meth:`RNA.fold_compound.positional_entropy()` in the :doc:`/api_python`.  

        Parameters
        ----------

        Returns
        -------
        double *  
            A 1-based vector of positional entropies :math:`S(i)`. (position 0 contains the sequence length)  

        """
        return _RNA.fold_compound_positional_entropy(self)

    def pr_structure(self, structure):
        r"""


        Compute the equilibrium probability of a particular secondary structure.  

        The probability :math:`p(s)` of a particular secondary structure :math:`s` can be computed as  

        .. math::

          p(s) = \frac{exp(-\beta E(s)}{Z}  

        from the structures free energy :math:`E(s)` and the partition function  

        .. math::

          Z = \sum_{s} exp(-\beta E(s)),\quad\mathrm{with}\quad\beta = \frac{1}{RT}  

        where :math:`R` is the gas constant and :math:`T` the thermodynamic temperature.  

        **Precondition**
            The fold compound `fc` must have went through a call to RNA.fold_compound.pf() to fill the
        dynamic
            programming matrices with the corresponding partition function.  

        **SWIG Wrapper Notes**
            This function is attached as method `pr_structure()` to objects of type `fold_compound`. See,
            e.g.  :py:meth:`RNA.fold_compound.pr_structure()` in the :doc:`/api_python`.  

        Parameters
        ----------
        structure : const char *
            The secondary structure to compute the probability for in dot-bracket notation  

        Returns
        -------
        double  
            The probability of the input structure (range :math:`[0:1]`)  

        """
        return _RNA.fold_compound_pr_structure(self, structure)

    def pr_energy(self, e):
        r"""


        **SWIG Wrapper Notes**
            This function is attached as method `pr_energy()` to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.pr_energy()` in the :doc:`/api_python`.  

        """
        return _RNA.fold_compound_pr_energy(self, e)

    def pf_dimer(self):
        r"""


        Calculate partition function and base pair probabilities of nucleic acid/nucleic acid dimers.  

        This is the cofold partition function folding.  

        **SWIG Wrapper Notes**
            This function is attached as method `pf_dimer()` to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.pf_dimer()` in the :doc:`/api_python`.  

        Parameters
        ----------
        structure : char *
            Will hold the structure or constraints  

        Returns
        -------
        RNA.dimer_pf()  
            RNA.dimer_pf() structure containing a set of energies needed for concentration computations.  

        See Also
        --------
        RNA.fold_compound() for how to retrieve the necessary data structure  

        Note
        ----
        This function may return INF / 100. for the `FA`, `FB`, `FAB`, `F0AB` members of the output data
        structure in case of contradicting constraints or numerical over-/underflow. In the latter case, a
        corresponding warning will be issued to `stdout`.  

        """
        return _RNA.fold_compound_pf_dimer(self)

    def bpp(self):
        return _RNA.fold_compound_bpp(self)

    def centroid(self):
        r"""
        centroid(fold_compound self) -> char *


        Get the centroid structure of the ensemble.  

        The centroid is the structure with the minimal average distance to all other structures
        :math:`<d(S)> = \sum_{(i,j) \in S} (1-p_{ij}) + \sum_{(i,j) \notin S} p_{ij}`  
        Thus, the centroid is simply the structure containing all pairs with :math:`p_{i}j>0.5` The distance
        of the centroid to the ensemble is written to the memory adressed by *dist*.  

        Parameters
        ----------
        dist : double *
            A pointer to the distance variable where the centroid distance will be written to  

        Returns
        -------
        char *  
            The centroid structure of the ensemble in dot-bracket notation (`NULL` on error)  

        """
        return _RNA.fold_compound_centroid(self)

    def MEA(self, *args):
        r"""
        MEA(fold_compound self) -> char
        MEA(fold_compound self, double gamma) -> char *


        Compute a MEA (maximum expected accuracy) structure.  

        The algorithm maximizes the expected accuracy  

        .. math::

          A(S) = \sum_{(i,j) \in S} 2 \gamma p_{ij} + \sum_{i \notin S} p^u_{i}  

        Higher values of :math:`\gamma` result in more base pairs of lower probability and thus higher
        sensitivity. Low values of :math:`\gamma` result in structures containing only highly likely pairs
        (high specificity). The code of the MEA function also demonstrates the use of sparse dynamic
        programming scheme to reduce the time and memory complexity of folding.  

        **Precondition**
            RNA.fold_compound.pf() must be executed on input parameter `fc`  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `MEA`(gamma = 1.) to objects of type
            `fold_compound`. Note, that it returns the MEA structure and MEA value as a tuple
            (MEA_structure, MEA). See, e.g.  :py:meth:`RNA.fold_compound.MEA()` in the :doc:`/api_python`.  

        Parameters
        ----------
        gamma : double
            The weighting factor for base pairs vs. unpaired nucleotides  
        mea : float *
            A pointer to a variable where the MEA value will be written to  

        Returns
        -------
        char *  
            An MEA structure (or NULL on any error)  

        """
        return _RNA.fold_compound_MEA(self, *args)

    def subopt(self, delta, sorted=1, nullfile=None):
        r"""
        subopt(fold_compound self, int delta, int sorted=1, FILE * nullfile=None) -> SuboptVector


        Returns list of subopt structures or writes to fp.  

        This function produces **all** suboptimal secondary structures within 'delta' * 0.01 kcal/mol of the
        optimum, see  :cite:t:`wuchty:1999` . The results are either directly written to a 'fp' (if 'fp' is
        not NULL), or (fp==NULL) returned in a RNA.subopt_solution() * list terminated by an entry were the
        'structure' member is NULL.  

        **SWIG Wrapper Notes**
            This function is attached as method **subopt()** to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.subopt()` in the :doc:`/api_python`.  

        Parameters
        ----------
        delta : int
        sorted : int
            Sort results by energy in ascending order  
        fp : FILE *

        Returns
        -------
        RNA.subopt_solution() *  

        See Also
        --------
        RNA.fold_compound.subopt_cb(), RNA.fold_compound.subopt_zuker()  

        Note
        ----
        This function requires all multibranch loop DP matrices for unique multibranch loop backtracing.
        Therefore, the supplied RNA.fold_compound()`fc` (argument 1) must be initialized with
        RNA.md().uniq_ML = 1, for instance like this:  

        """
        return _RNA.fold_compound_subopt(self, delta, sorted, nullfile)

    def subopt_zuker(self):
        r"""


        Compute Zuker type suboptimal structures.  

        Compute Suboptimal structures according to  :cite:t:`zuker:1989`  , i.e. for every possible base
        pair the minimum energy structure containing the resp. base pair. Returns a list of these structures
        and their energies.  

        **SWIG Wrapper Notes**
            This function is attached as method **subopt_zuker()** to objects of type `fold_compound`. See,
            e.g.  :py:meth:`RNA.fold_compound.subopt_zuker()` in the :doc:`/api_python`.  

        Parameters
        ----------

        Returns
        -------
        RNA.subopt_solution() *  
            List of zuker suboptimal structures  

        See Also
        --------
        RNA.fold_compound.subopt(), zukersubopt(), zukersubopt_par()  

        """
        return _RNA.fold_compound_subopt_zuker(self)

    def sequence_add(self, *args, **kwargs):
        r"""


        """
        return _RNA.fold_compound_sequence_add(self, *args, **kwargs)

    def sequence_remove(self, i):
        r"""


        """
        return _RNA.fold_compound_sequence_remove(self, i)

    def sequence_remove_all(self):
        r"""


        """
        return _RNA.fold_compound_sequence_remove_all(self)

    def sequence_prepare(self):
        r"""


        """
        return _RNA.fold_compound_sequence_prepare(self)

    def ud_add_motif(self, *args, **kwargs):
        r"""
        ud_add_motif(fold_compound self, std::string motif, double motif_en, std::string name="", unsigned int options=)


        Add an unstructured domain motif, e.g. for ligand binding.  

        This function adds a ligand binding motif and the associated binding free energy to the RNA.ud()
        attribute of a RNA.fold_compound(). The motif data will then be used in subsequent secondary
        structure predictions. Multiple calls to this function with different motifs append all additional
        data to a list of ligands, which all will be evaluated. Ligand motif data can be removed from the
        RNA.fold_compound() again using the RNA.fold_compound.ud_remove() function. The loop type parameter allows one
        to limit the ligand binding to particular loop type, such as the exterior loop, hairpin loops,
        interior loops, or multibranch loops.  

        Parameters
        ----------
        motif : const char *
            The sequence motif the ligand binds to  
        motif_en : double
            The binding free energy of the ligand in kcal/mol  
        motif_name : const char *
            The name/id of the motif (may be `NULL`)  
        loop_type : unsigned int
            The loop type the ligand binds to  

        See Also
        --------
        RNA.UNSTRUCTURED_DOMAIN_EXT_LOOP, RNA.UNSTRUCTURED_DOMAIN_HP_LOOP,
        RNA.UNSTRUCTURED_DOMAIN_INT_LOOP, RNA.UNSTRUCTURED_DOMAIN_MB_LOOP,
        RNA.UNSTRUCTURED_DOMAIN_ALL_LOOPS, RNA.fold_compound.ud_remove()  

        """
        return _RNA.fold_compound_ud_add_motif(self, *args, **kwargs)

    def ud_remove(self):
        r"""


        Remove ligand binding to unpaired stretches.  

        This function removes all ligand motifs that were bound to a RNA.fold_compound() using the
        RNA.fold_compound.ud_add_motif() function.  

        **SWIG Wrapper Notes**
            This function is attached as method `ud_remove()` to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.ud_remove()` in the :doc:`/api_python`.  

        Parameters
        ----------  

        """
        return _RNA.fold_compound_ud_remove(self)

    def commands_apply(self, *args, **kwargs):
        r"""
        commands_apply(fold_compound self, cmd commands, unsigned int options=) -> int


        Apply a list of commands to a RNA.fold_compound().  

        **SWIG Wrapper Notes**
            This function is attached as method `commands_apply()` to objects of type `fold_compound`. See,
            e.g.   :py:meth:`RNA.fold_compound.commands_apply()` in the :doc:`/api_python` .  

        Parameters
        ----------
        commands : RNA.cmd()
            The commands to apply  
        options : unsigned int
            Options to limit the type of commands read from the file  

        Returns
        -------
        int  
            The number of commands successfully applied  

        """
        return _RNA.fold_compound_commands_apply(self, *args, **kwargs)

    def file_commands_apply(self, *args, **kwargs):
        r"""file_commands_apply(fold_compound self, std::string filename, unsigned int options=) -> int"""
        return _RNA.fold_compound_file_commands_apply(self, *args, **kwargs)

    def rotational_symmetry_db(self, structure):
        r"""


        Determine the order of rotational symmetry for a dot-bracket structure.  

        Given a (permutation of multiple) RNA strand(s) and a particular secondary structure in dot-bracket
        notation, compute the degree of rotational symmetry. In case there is only a single linear RNA
        strand, the structure always has degree 1, as there are no rotational symmetries due to the
        direction of the nucleic acid sequence and the fixed positions of 5' and 3' ends. However, for
        circular RNAs, rotational symmetries might arise if the sequence consists of a concatenation of
        :math:`k` identical subsequences.  

        If the argument `positions` is not `NULL`, the function stores an array of string start positions
        for rotational shifts that map the string back onto itself. This array has length of order of
        rotational symmetry, i.e. the number returned by this function. The first element `positions`[0]
        always contains a shift value of `0` representing the trivial rotation.  

        **SWIG Wrapper Notes**
            This function is attached as method `rotational_symmetry_db()` to objects of type
            `fold_compound` (i.e. RNA.fold_compound()). Thus, the first argument must be omitted. In
            contrast to our C-implementation, this function doesn't simply return the order of rotational
            symmetry of the secondary structure, but returns the list `position` of cyclic permutation
            shifts that result in a rotationally symmetric structure. The length of the list then determines
            the order of rotational symmetry. See, e.g.
            :py:meth:`RNA.fold_compound.rotational_symmetry_db()` in the :doc:`/api_python` .  

        Parameters
        ----------
        structure : const char *
            The dot-bracket structure the degree of rotational symmetry is checked for  
        positions : unsigned int **
            A pointer to an (undefined) list of alternative string start positions that lead to an identity
            mapping (may be NULL)  

        Returns
        -------
        unsigned int  
            The degree of rotational symmetry of the `structure` (0 in case of any errors)  

        See Also
        --------
        RNA.rotational_symmetry_db(), RNA.rotational_symmetry_pos(), RNA.rotational_symmetry_pos_num()  

        Note
        ----
        Do not forget to release the memory occupied by `positions` after a successful execution of this
        function.  

        """
        return _RNA.fold_compound_rotational_symmetry_db(self, structure)

    def neighbors(self, *args, **kwargs):
        r"""
        neighbors(fold_compound self, varArrayShort pt, unsigned int options=(4|8)) -> varArrayMove


        Generate neighbors of a secondary structure.  

        This function allows one to generate all structural neighbors (according to a particular move set)
        of an RNA secondary structure. The neighborhood is then returned as a list of transitions / moves
        required to transform the current structure into the actual neighbor.  

        **SWIG Wrapper Notes**
            This function is attached as an overloaded method `neighbors()` to objects of type
            `fold_compound`. The optional parameter `options` defaults to RNA.MOVESET_DEFAULT if it is
            omitted. See, e.g.  :py:meth:`RNA.fold_compound.neighbors()` in the :doc:`/api_python`.  

        Parameters
        ----------
        pt : const short *
            The pair table representation of the structure  
        options : unsigned int
            Options to modify the behavior of this function, e.g. available move set  

        Returns
        -------
        RNA.move() *  
            Neighbors as a list of moves / transitions (the last element in the list has both of its fields
            set to 0)  

        See Also
        --------
        RNA.neighbors_successive(), RNA.move_apply(), RNA.MOVESET_INSERTION, RNA.MOVESET_DELETION,
        RNA.MOVESET_SHIFT, RNA.MOVESET_DEFAULT  

        """
        return _RNA.fold_compound_neighbors(self, *args, **kwargs)

    def path(self, *args):
        r"""
        path(fold_compound self, IntVector pt, unsigned int steps, unsigned int options=) -> MoveVector
        path(fold_compound self, varArrayShort pt, unsigned int steps, unsigned int options=) -> MoveVector


        Compute a path, store the final structure, and return a list of transition moves from the start to
        the final structure.  

        This function computes, given a start structure in pair table format, a transition path, updates the
        pair table to the final structure of the path. Finally, if not requested otherwise by using the
        RNA.PATH_NO_TRANSITION_OUTPUT flag in the `options` field, this function returns a list of
        individual transitions that lead from the start to the final structure if requested.  

        The currently available transition paths are  

        *   Steepest Descent / Gradient walk (flag: RNA.PATH_STEEPEST_DESCENT)  
        *   Random walk (flag: RNA.PATH_RANDOM)  

        The type of transitions must be set through the `options` parameter  

        **SWIG Wrapper Notes**
            This function is attached as an overloaded method `path()` to objects of type `fold_compound`.
            The optional parameter `options` defaults to RNA.PATH_DEFAULT if it is omitted. See, e.g.
            :py:meth:`RNA.fold_compound.path()` in the :doc:`/api_python`.  

        Parameters
        ----------
        pt : short *
            The pair table containing the start structure. Used to update to the final structure after
            execution of this function  
        options : unsigned int
            Options to modify the behavior of this function  

        Returns
        -------
        RNA.move() *  
            A list of transition moves (default), or NULL (if options & RNA.PATH_NO_TRANSITION_OUTPUT)  

        See Also
        --------
        RNA.fold_compound.path_gradient(), RNA.fold_compound.path_random(), RNA.ptable(), RNA.ptable_copy(),
        RNA.fold_compound()RNA.PATH_STEEPEST_DESCENT, RNA.PATH_RANDOM, RNA.MOVESET_DEFAULT,
        RNA.MOVESET_SHIFT, RNA.PATH_NO_TRANSITION_OUTPUT  

        Note
        ----
        Since the result is written to the input structure you may want to use RNA.ptable_copy() before
        calling this function to keep the initial structure  

        """
        return _RNA.fold_compound_path(self, *args)

    def path_gradient(self, *args):
        r"""
        path_gradient(fold_compound self, IntVector pt, unsigned int options=) -> MoveVector
        path_gradient(fold_compound self, varArrayShort pt, unsigned int options=) -> MoveVector


        Compute a steepest descent / gradient path, store the final structure, and return a list of
        transition moves from the start to the final structure.  

        This function computes, given a start structure in pair table format, a steepest descent path,
        updates the pair table to the final structure of the path. Finally, if not requested otherwise by
        using the RNA.PATH_NO_TRANSITION_OUTPUT flag in the `options` field, this function returns a list
        of individual transitions that lead from the start to the final structure if requested.  

        **SWIG Wrapper Notes**
            This function is attached as an overloaded method `path_gradient()` to objects of type
            `fold_compound`. The optional parameter `options` defaults to RNA.PATH_DEFAULT if it is
            omitted. See, e.g.  :py:meth:`RNA.fold_compound.path_gradient()` in the :doc:`/api_python`.  

        Parameters
        ----------
        pt : short *
            The pair table containing the start structure. Used to update to the final structure after
            execution of this function  
        options : unsigned int
            Options to modify the behavior of this function  

        Returns
        -------
        RNA.move() *  
            A list of transition moves (default), or NULL (if options & RNA.PATH_NO_TRANSITION_OUTPUT)  

        See Also
        --------
        RNA.fold_compound.path_random(), RNA.fold_compound.path(), RNA.ptable(), RNA.ptable_copy(),
        RNA.fold_compound()RNA.MOVESET_DEFAULT, RNA.MOVESET_SHIFT, RNA.PATH_NO_TRANSITION_OUTPUT  

        Note
        ----
        Since the result is written to the input structure you may want to use RNA.ptable_copy() before
        calling this function to keep the initial structure  

        """
        return _RNA.fold_compound_path_gradient(self, *args)

    def path_random(self, *args):
        r"""
        path_random(fold_compound self, IntVector pt, unsigned int steps, unsigned int options=) -> MoveVector
        path_random(fold_compound self, varArrayShort pt, unsigned int steps, unsigned int options=) -> MoveVector


        Generate a random walk / path of a given length, store the final structure, and return a list of
        transition moves from the start to the final structure.  

        This function generates, given a start structure in pair table format, a random walk / path, updates
        the pair table to the final structure of the path. Finally, if not requested otherwise by using the
        RNA.PATH_NO_TRANSITION_OUTPUT flag in the `options` field, this function returns a list of
        individual transitions that lead from the start to the final structure if requested.  

        **SWIG Wrapper Notes**
            This function is attached as an overloaded method `path_gradient()` to objects of type
            `fold_compound`. The optional parameter `options` defaults to RNA.PATH_DEFAULT if it is
            omitted. See, e.g.  :py:meth:`RNA.fold_compound.path_random()` in the :doc:`/api_python`.  

        Parameters
        ----------
        pt : short *
            The pair table containing the start structure. Used to update to the final structure after
            execution of this function  
        steps : unsigned int
            The length of the path, i.e. the total number of transitions / moves  
        options : unsigned int
            Options to modify the behavior of this function  

        Returns
        -------
        RNA.move() *  
            A list of transition moves (default), or NULL (if options & RNA.PATH_NO_TRANSITION_OUTPUT)  

        See Also
        --------
        RNA.fold_compound.path_gradient(), RNA.fold_compound.path(), RNA.ptable(), RNA.ptable_copy(),
        RNA.fold_compound()RNA.MOVESET_DEFAULT, RNA.MOVESET_SHIFT, RNA.PATH_NO_TRANSITION_OUTPUT  

        Note
        ----
        Since the result is written to the input structure you may want to use RNA.ptable_copy() before
        calling this function to keep the initial structure  

        """
        return _RNA.fold_compound_path_random(self, *args)

    def path_findpath_saddle(self, *args, **kwargs):
        r"""
        path_findpath_saddle(fold_compound self, std::string s1, std::string s2, int width=1, int maxE=INT_MAX) -> PyObject *


        Find energy of a saddle point between 2 structures (search only direct path)  

        This function uses an inplementation of the *findpath* algorithm  :cite:p:`flamm:2001`  for near-
        optimal direct refolding path prediction.  

        Model details, and energy parameters are used as provided via the parameter 'fc'. The
        RNA.fold_compound() does not require memory for any DP matrices, but requires all most basic init
        values as one would get from a call like this:  

        **SWIG Wrapper Notes**
            This function is attached as an overloaded method `path_findpath_saddle()` to objects of type
            `fold_compound`. The optional parameter `width` defaults to 1 if it is omitted, while the
            optional parameter `maxE` defaults to INF. In case the function did not find a path with
            :math:`E_{saddle} < E_{max}` the function returns a `NULL` object, i.e. `undef` for Perl and
            `None` for Python. See, e.g.  :py:meth:`RNA.fold_compound.path_findpath_saddle()` in the
            :doc:`/api_python`.  

        Parameters
        ----------
        s1 : const char *
            The start structure in dot-bracket notation  
        s2 : const char *
            The target structure in dot-bracket notation  
        width : int
            A number specifying how many strutures are being kept at each step during the search  
        maxE : int
            An upper bound for the saddle point energy in 10cal/mol  

        Returns
        -------
        int  
            The saddle energy in 10cal/mol  

        Warnings
        --------
        The argument `maxE` ( :math:`E_{max}`) enables one to specify an upper bound, or maximum free energy
        for the saddle point between the two input structures. If no path with :math:`E_{saddle} < E_{max}`
        is found, the function simply returns `maxE`  

        See Also
        --------
        RNA.path_findpath_saddle(), RNA.fold_compound(), RNA.fold_compound(), RNA.path_findpath()  

        """
        return _RNA.fold_compound_path_findpath_saddle(self, *args, **kwargs)

    def path_findpath(self, *args, **kwargs):
        r"""path_findpath(fold_compound self, std::string s1, std::string s2, int width=1, int maxE=INT_MAX-1) -> PathVector"""
        return _RNA.fold_compound_path_findpath(self, *args, **kwargs)

    def path_direct(self, *args, **kwargs):
        r"""
        path_direct(fold_compound self, std::string s1, std::string s2, int maxE=INT_MAX-1, path_options options=None) -> PathVector


        Determine an optimal direct (re-)folding path between two secondary structures.  

        This function is similar to RNA.path_direct(), but allows to specify an *upper-bound* for the
        saddle point energy. The underlying algorithms will stop determining an (optimal) (re-)folding path,
        if none can be found that has a saddle point below the specified upper-bound threshold `maxE`.  

        **SWIG Wrapper Notes**
            This function is attached as an overloaded method `path_direct()` to objects of type
            `fold_compound`. The optional parameter `maxE` defaults to #INT_MAX - 1 if it is omitted, while
            the optional parameter `options` defaults to `NULL`. In case the function did not find a path
            with :math:`E_{saddle} < E_{max}` it returns an empty list. See, e.g.
            :py:meth:`RNA.fold_compound.path_direct()` in the :doc:`/api_python`.  

        Parameters
        ----------
        s1 : const char *
            The start structure in dot-bracket notation  
        s2 : const char *
            The target structure in dot-bracket notation  
        maxE : int
            Upper bound for the saddle point along the (re-)folding path  
        options : RNA.path_options()
            An options data structure that specifies the path heuristic and corresponding settings (maybe
            *NULL*)  

        Returns
        -------
        RNA.path() *  
            An optimal (re-)folding path between the two input structures  

        Warnings
        --------
        The argument `maxE` enables one to specify an upper bound, or maximum free energy for the saddle
        point between the two input structures. If no path with :math:`E_{saddle} < E_{max}` is found, the
        function simply returns *NULL*  

        See Also
        --------
        RNA.fold_compound.path_direct(), RNA.path_options_findpath(), RNA.path_options_free(),
        RNA.path_free()  

        """
        return _RNA.fold_compound_path_direct(self, *args, **kwargs)

    def heat_capacity(self, T_min=0., T_max=100., T_increment=1., mpoints=2):
        r"""
        heat_capacity(fold_compound self, float T_min=0., float T_max=100., float T_increment=1., unsigned int mpoints=2) -> HeatCapacityVector


        Compute the specific heat for an RNA.  

        This function computes an RNAs specific heat in a given temperature range from the partition
        function by numeric differentiation. The result is returned as a list of pairs of temperature in C
        and specific heat in Kcal/(Mol*K).  

        Users can specify the temperature range for the computation from `T_min` to `T_max`, as well as the
        increment step size `T_increment`. The latter also determines how many times the partition function
        is computed. Finally, the parameter `mpoints` determines how smooth the curve should be. The
        algorithm itself fits a parabola to :math:`2 \cdot mpoints + 1` data points to calculate 2nd
        derivatives. Increasing this parameter produces a smoother curve.  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `heat_capacity()` to objects of type
            `fold_compound`. If the optional function arguments `T_min`, `T_max`, `T_increment`, and
            `mpoints` are omitted, they default to 0.0, 100.0, 1.0 and 2, respectively. See, e.g.
            :py:meth:`RNA.fold_compound.heat_capacity()` in the :doc:`/api_python`.  

        Parameters
        ----------
        T_min : float
            Lowest temperature in C  
        T_max : float
            Highest temperature in C  
        T_increment : float
            Stepsize for temperature incrementation in C (a reasonable choice might be 1C)  
        mpoints : unsigned int
            The number of interpolation points to calculate 2nd derivative (a reasonable choice might be 2,
            min: 1, max: 100)  

        Returns
        -------
        RNA.heat_capacity() *  
            A list of pairs of temperatures and corresponding heat capacity or *NULL* upon any failure. The
            last entry of the list is indicated by a **temperature** field set to a value smaller than
            `T_min`  

        See Also
        --------
        RNA.fold_compound.heat_capacity_cb(), RNA.heat_capacity(), RNA.heat_capacity()  

        """
        return _RNA.fold_compound_heat_capacity(self, T_min, T_max, T_increment, mpoints)

    def add_auxdata(self, *args, **kwargs):
        r"""
        add_auxdata(fold_compound self, PyObject * data, PyObject * PyFuncOrNone=Py_None) -> PyObject *


        Add auxiliary data to the RNA.fold_compound().  

        This function allows one to bind arbitrary data to a RNA.fold_compound() which may later on be used
        by one of the callback functions, e.g. RNA.recursion_status(). To allow for proper cleanup of the
        memory occupied by this auxiliary data, the user may also provide a pointer to a cleanup function
        that free's the corresponding memory. This function will be called automatically when the
        RNA.fold_compound() is free'd with RNA.fold_compound_free().  

        Parameters
        ----------
        data : void *
            A pointer to an arbitrary data structure  
        f : RNA.auxdata_free
            A pointer to function that free's memory occupied by the arbitrary data (May be NULL)  

        See Also
        --------
        RNA.auxdata_free()  

        Note
        ----
        Before attaching the arbitrary data pointer, this function will call the RNA.auxdata_free() on
        any pre-existing data that is already attached.  

        """
        return _RNA.fold_compound_add_auxdata(self, *args, **kwargs)

    def add_callback(self, PyFunc):
        r"""
        add_callback(fold_compound self, PyObject * PyFunc) -> PyObject *


        Add a recursion status callback to the RNA.fold_compound().  

        Binding a recursion status callback function to a RNA.fold_compound() allows one to perform
        arbitrary operations just before, or after an actual recursive computations, e.g. MFE prediction, is
        performed by the RNAlib. The callback function will be provided with a pointer to its
        RNA.fold_compound(), and a status message. Hence, it has complete access to all variables that
        incluence the recursive computations.  

        Parameters
        ----------
        f : RNA.recursion_status
            The pointer to the recursion status callback function  

        See Also
        --------
        RNA.recursion_status(), RNA.fold_compound(), RNA.STATUS_MFE_PRE, RNA.STATUS_MFE_POST,
        RNA.STATUS_PF_PRE, RNA.STATUS_PF_POST  

        """
        return _RNA.fold_compound_add_callback(self, PyFunc)

    def sc_add_data(self, *args, **kwargs):
        r"""
        sc_add_data(fold_compound self, PyObject * data, PyObject * callback=Py_None) -> int


        Add an auxiliary data structure for the generic soft constraints callback function.  

        **SWIG Wrapper Notes**
            This function is attached as method `sc_add_data()` to objects of type `fold_compound`. See,
            e.g.   :py:meth:`RNA.fold_compound.sc_add_data()` in the :doc:`/api_python` .  

        Parameters
        ----------
        data : void *
            A pointer to the data structure that holds required data for function 'f'  
        free_data : RNA.auxdata_free
            A pointer to a function that free's the memory occupied by `data` (Maybe NULL)  

        Returns
        -------
        int  
            Non-zero on successful binding the data (and free-function), 0 otherwise  

        See Also
        --------
        RNA.fold_compound.sc_add(), RNA.fold_compound.sc_add_exp(), RNA.fold_compound.sc_add_bt()  

        """
        return _RNA.fold_compound_sc_add_data(self, *args, **kwargs)

    def sc_add_f(self, callback):
        r"""
        sc_add_f(fold_compound self, PyObject * callback) -> int


        Bind a function pointer for generic soft constraint feature (MFE version)  

        This function allows one to easily bind a function pointer and corresponding data structure to the
        soft constraint part RNA.sc() of the RNA.fold_compound(). The function for evaluating the generic
        soft constraint feature has to return a pseudo free energy :math:`\hat{E}` in :math:`dacal/mol`,
        where :math:`1 dacal/mol = 10 cal/mol`.  

        **SWIG Wrapper Notes**
            This function is attached as method `sc_add()` to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.sc_add()` in the :doc:`/api_python` .  

        Parameters
        ----------
        f : RNA.sc
            A pointer to the function that evaluates the generic soft constraint feature  

        Returns
        -------
        int  
            Non-zero on successful binding the callback function, 0 otherwise  

        See Also
        --------
        RNA.fold_compound.sc_add_data(), RNA.fold_compound.sc_add_bt(), RNA.fold_compound.sc_add_exp()  

        """
        return _RNA.fold_compound_sc_add_f(self, callback)

    def sc_add_bt(self, PyFunc):
        r"""
        sc_add_bt(fold_compound self, PyObject * PyFunc) -> int


        Bind a backtracking function pointer for generic soft constraint feature.  

        This function allows one to easily bind a function pointer to the soft constraint part RNA.sc() of
        the RNA.fold_compound(). The provided function should be used for backtracking purposes in loop
        regions that were altered via the generic soft constraint feature. It has to return an array of
        RNA.basepair() data structures, were the last element in the list is indicated by a value of -1 in
        it's i position.  

        **SWIG Wrapper Notes**
            This function is attached as method `sc_add_bt()` to objects of type `fold_compound`. See, e.g.
            :py:meth:`RNA.fold_compound.sc_add_bt()` in the :doc:`/api_python` .  

        Parameters
        ----------
        f : RNA.sc_bt
            A pointer to the function that returns additional base pairs  

        Returns
        -------
        int  
            Non-zero on successful binding the callback function, 0 otherwise  

        See Also
        --------
        RNA.fold_compound.sc_add_data(), RNA.fold_compound.sc_add(), RNA.fold_compound.sc_add_exp()  

        """
        return _RNA.fold_compound_sc_add_bt(self, PyFunc)

    def sc_add_exp_f(self, PyFunc):
        r"""
        sc_add_exp_f(fold_compound self, PyObject * PyFunc) -> int


        Bind a function pointer for generic soft constraint feature (PF version)  

        This function allows one to easily bind a function pointer and corresponding data structure to the
        soft constraint part RNA.sc() of the RNA.fold_compound(). The function for evaluating the generic
        soft constraint feature has to return a pseudo free energy :math:`\hat{E}` as Boltzmann factor,
        i.e. :math:`exp(- \hat{E} / kT)`. The required unit for :math:`E` is :math:`cal/mol`.  

        **SWIG Wrapper Notes**
            This function is attached as method `sc_add_exp()` to objects of type `fold_compound`. See,
            e.g.   :py:meth:`RNA.fold_compound.sc_add_exp()` in the :doc:`/api_python` .  

        Parameters
        ----------
        exp : RNA.sc_exp
            A pointer to the function that evaluates the generic soft constraint feature  

        Returns
        -------
        int  
            Non-zero on successful binding the callback function, 0 otherwise  

        See Also
        --------
        RNA.fold_compound.sc_add_bt(), RNA.fold_compound.sc_add(), RNA.fold_compound.sc_add_data()  

        """
        return _RNA.fold_compound_sc_add_exp_f(self, PyFunc)

    def ud_set_data(self, *args, **kwargs):
        r"""
        ud_set_data(fold_compound self, PyObject * data, PyObject * free_cb=Py_None) -> PyObject *


        Attach an auxiliary data structure.  

        This function binds an arbitrary, auxiliary data structure for user-implemented ligand binding. The
        optional callback `free_cb` will be passed the bound data structure whenever the
        RNA.fold_compound() is removed from memory to avoid memory leaks.  

        **SWIG Wrapper Notes**
            This function is attached as method `ud_set_data()` to objects of type `fold_compound`. See,
            e.g.  :py:meth:`RNA.fold_compound.ud_set_data()` in the :doc:`/api_python`.  

        Parameters
        ----------
        data : void *
            A pointer to the auxiliary data structure  
        free_cb : RNA.auxdata_free
            A pointer to a callback function that free's memory occupied by `data`  

        See Also
        --------
        RNA.fold_compound.ud_set_prod_rule_cb(), RNA.fold_compound.ud_set_exp_prod_rule_cb(),
        RNA.fold_compound.ud_remove()  

        """
        return _RNA.fold_compound_ud_set_data(self, *args, **kwargs)

    def ud_set_prod_rule_cb(self, prod_cb, eval_cb):
        r"""
        ud_set_prod_rule_cb(fold_compound self, PyObject * prod_cb, PyObject * eval_cb) -> PyObject *


        Attach production rule callbacks for free energies computations.  

        Use this function to bind a user-implemented grammar extension for unstructured domains.  

        The callback `e_cb` needs to evaluate the free energy contribution :math:`f(i,j)` of the unpaired
        segment :math:`[i,j]`. It will be executed in each of the regular secondary structure production
        rules. Whenever the callback is passed the RNA.UNSTRUCTURED_DOMAIN_MOTIF flag via its `loop_type`
        parameter the contribution of any ligand that consecutively binds from position :math:`i` to
        :math:`j` (the white box) is requested. Otherwise, the callback usually performs a lookup in the
        precomputed `B` matrices. Which `B` matrix is addressed will be indicated by the flags
        RNA.UNSTRUCTURED_DOMAIN_EXT_LOOP,
        RNA.UNSTRUCTURED_DOMAIN_HP_LOOPRNA.UNSTRUCTURED_DOMAIN_INT_LOOP, and
        RNA.UNSTRUCTURED_DOMAIN_MB_LOOP. As their names already imply, they specify exterior loops (`F`
        production rule), hairpin loops and interior loops (`C` production rule), and multibranch loops (`M`
        and `M1` production rule).  

        ligands_up_callback.svg  

        The `pre_cb` callback will be executed as a pre-processing step right before the regular secondary
        structure rules. Usually one would use this callback to fill the dynamic programming matrices `U`
        and preparations of the auxiliary data structure RNA.unstructured_domain().data  

        B_prod_rule.svg  

        **SWIG Wrapper Notes**
            This function is attached as method `ud_set_prod_rule_cb()` to objects of type `fold_compound`.
            See, e.g.  :py:meth:`RNA.fold_compound.ud_set_prod_rule_cb()` in the :doc:`/api_python`.  

        Parameters
        ----------
        pre_cb : RNA.ud_production
            A pointer to a callback function for the `B` production rule  
        e_cb : RNA.ud
            A pointer to a callback function for free energy evaluation  

        """
        return _RNA.fold_compound_ud_set_prod_rule_cb(self, prod_cb, eval_cb)

    def ud_set_exp_prod_rule_cb(self, prod_cb, eval_cb):
        r"""
        ud_set_exp_prod_rule_cb(fold_compound self, PyObject * prod_cb, PyObject * eval_cb) -> PyObject *


        Attach production rule for partition function.  

        This function is the partition function companion of RNA.fold_compound.ud_set_prod_rule_cb().  

        Use it to bind callbacks to (i) fill the `U` production rule dynamic programming matrices and/or
        prepare the RNA.unstructured_domain().data, and (ii) provide a callback to retrieve partition
        functions for subsegments :math:`[i,j]`.  

        B_prod_rule.svg  

        ligands_up_callback.svg  

        **SWIG Wrapper Notes**
            This function is attached as method `ud_set_exp_prod_rule_cb()` to objects of type
            `fold_compound`. See, e.g.  :py:meth:`RNA.fold_compound.ud_set_exp_prod_rule_cb()` in the
            :doc:`/api_python`.  

        Parameters
        ----------
        pre_cb : RNA.ud_exp_production
            A pointer to a callback function for the `B` production rule  
        exp_e_cb : RNA.ud_exp
            A pointer to a callback function that retrieves the partition function for a segment
            :math:`[i,j]` that may be bound by one or more ligands.  

        See Also
        --------
        RNA.fold_compound.ud_set_prod_rule_cb()  

        """
        return _RNA.fold_compound_ud_set_exp_prod_rule_cb(self, prod_cb, eval_cb)

    def ud_set_prob_cb(self, setter_cb, getter_cb):
        r"""
        ud_set_prob_cb(fold_compound self, PyObject * setter_cb, PyObject * getter_cb) -> PyObject *


        **SWIG Wrapper Notes**
            This function is attached as method `ud_set_prob_cb()` to objects of type `fold_compound`. See,
            e.g.  :py:meth:`RNA.fold_compound.ud_set_prob_cb()` in the :doc:`/api_python`.  

        """
        return _RNA.fold_compound_ud_set_prob_cb(self, setter_cb, getter_cb)

    def subopt_cb(self, *args, **kwargs):
        r"""
        subopt_cb(fold_compound self, int delta, PyObject * PyFunc, PyObject * data=Py_None) -> PyObject *


        Generate suboptimal structures within an energy band arround the MFE.  

        This is the most generic implementation of the suboptimal structure generator according to
        :cite:t:`wuchty:1999` . Identical to RNA.fold_compound.subopt(), it computes all secondary structures within an
        energy band `delta` arround the MFE. However, this function does not print the resulting structures
        and their corresponding free energies to a file pointer, or returns them as a list. Instead, it
        calls a user-provided callback function which it passes the structure in dot-bracket format, the
        corresponding free energy in kcal/mol, and a user-provided data structure each time a structure was
        backtracked successfully. This function indicates the final output, i.e. the end of the backtracking
        procedure by passing NULL instead of an actual dot-bracket string to the callback.  

        **SWIG Wrapper Notes**
            This function is attached as method **subopt_cb()** to objects of type `fold_compound`. See,
            e.g.  :py:meth:`RNA.fold_compound.subopt_cb()` in the :doc:`/api_python`.  

        Parameters
        ----------
        delta : int
            Energy band arround the MFE in 10cal/mol, i.e. deka-calories  
        cb : RNA.subopt_result
            Pointer to a callback function that handles the backtracked structure and its free energy in
            kcal/mol  
        data : void *
            Pointer to some data structure that is passed along to the callback  

        See Also
        --------
        RNA.subopt_result, RNA.fold_compound.subopt(), RNA.fold_compound.subopt_zuker()  

        Note
        ----
        This function requires all multibranch loop DP matrices for unique multibranch loop backtracing.
        Therefore, the supplied RNA.fold_compound()`fc` (argument 1) must be initialized with
        RNA.md().uniq_ML = 1, for instance like this:  

        """
        return _RNA.fold_compound_subopt_cb(self, *args, **kwargs)

    def pbacktrack(self, *args):
        r"""
        pbacktrack(fold_compound self) -> char
        pbacktrack(fold_compound self, unsigned int num_samples, unsigned int options=) -> StringVector
        pbacktrack(fold_compound self, unsigned int num_samples, pbacktrack_mem nr_memory, unsigned int options=) -> StringVector
        pbacktrack(self, num_samples, PyFunc, data=Py_None, options=0) -> unsigned int

        Parameters
        ----------
        num_samples: unsigned int
        PyFunc: PyObject *
        data: PyObject *
        options: unsigned int

        pbacktrack(self, num_samples, PyFunc, data, nr_memory, options=0) -> unsigned int

        Parameters
        ----------
        num_samples: unsigned int
        PyFunc: PyObject *
        data: PyObject *
        nr_memory: vrna_pbacktrack_mem_t *
        options: unsigned int



        Sample a secondary structure from the Boltzmann ensemble according its probability.  

        Perform a probabilistic (stochastic) backtracing in the partition function DP arrays to obtain a
        secondary structure.  

        The structure :math:`s` with free energy :math:`E(s)` is picked from the Boltzmann distributed
        ensemble according to its probability  

        .. math::

          p(s) = \frac{exp(-E(s) / kT)}{Z}  

        with partition function :math:`Z = \sum_{s} exp(-E(s) / kT)`, Boltzmann constant :math:`k` and
        thermodynamic temperature :math:`T`.  

        **Precondition**
            Unique multiloop decomposition has to be active upon creation of `fc` with RNA.fold_compound()
            or similar. This can be done easily by passing RNA.fold_compound() a model details parameter
            with RNA.md().uniq_ML = 1.  RNA.fold_compound.pf() has to be called first to fill the partition
        function
            matrices  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `pbacktrack()` to objects of type
            `fold_compound`. See, e.g.   :py:meth:`RNA.fold_compound.pbacktrack()` in the :doc:`/api_python`
            and the  :ref:`examples/python:boltzmann sampling` Python examples .  

        Parameters
        ----------

        Returns
        -------
        char *  
            A sampled secondary structure in dot-bracket notation (or NULL on error)  

        See Also
        --------
        RNA.fold_compound.pbacktrack5(), RNA.pbacktrack_num, RNA.pbacktrack_cb()  

        Note
        ----
        This function is polymorphic. It accepts RNA.fold_compound() of type RNA.FC_TYPE_SINGLE, and
        RNA.FC_TYPE_COMPARATIVE.  

        """
        return _RNA.fold_compound_pbacktrack(self, *args)

    def pbacktrack5(self, *args):
        r"""
        pbacktrack5(fold_compound self, unsigned int length) -> char
        pbacktrack5(fold_compound self, unsigned int num_samples, unsigned int length, unsigned int options=) -> StringVector
        pbacktrack5(fold_compound self, unsigned int num_samples, unsigned int length, pbacktrack_mem nr_memory, unsigned int options=) -> StringVector
        pbacktrack5(fold_compound self, unsigned int num_samples, unsigned int length, PyObject * PyFunc, PyObject * data=Py_None, unsigned int options=0) -> unsigned int
        pbacktrack5(fold_compound self, unsigned int num_samples, unsigned int length, PyObject * PyFunc, PyObject * data, pbacktrack_mem nr_memory, unsigned int options=0) -> unsigned int


        Sample a secondary structure of a subsequence from the Boltzmann ensemble according its probability.  

        Perform a probabilistic (stochastic) backtracing in the partition function DP arrays to obtain a
        secondary structure. The parameter `length` specifies the length of the substructure starting from
        the 5' end.  

        The structure :math:`s` with free energy :math:`E(s)` is picked from the Boltzmann distributed
        ensemble according to its probability  

        .. math::

          p(s) = \frac{exp(-E(s) / kT)}{Z}  

        with partition function :math:`Z = \sum_{s} exp(-E(s) / kT)`, Boltzmann constant :math:`k` and
        thermodynamic temperature :math:`T`.  

        **Precondition**
            Unique multiloop decomposition has to be active upon creation of `fc` with RNA.fold_compound()
            or similar. This can be done easily by passing RNA.fold_compound() a model details parameter
            with RNA.md().uniq_ML = 1.  RNA.fold_compound.pf() has to be called first to fill the partition
        function
            matrices  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `pbacktrack5()` to objects of type
            `fold_compound`. See, e.g.   :py:meth:`RNA.fold_compound.pbacktrack5()` in the
            :doc:`/api_python`  and the  :ref:`examples/python:boltzmann sampling` Python examples .  

        Parameters
        ----------
        length : unsigned int
            The length of the subsequence to consider (starting with 5' end)  

        Returns
        -------
        char *  
            A sampled secondary structure in dot-bracket notation (or NULL on error)  

        See Also
        --------
        RNA.pbacktrack5_num(), RNA.pbacktrack5_cb(), RNA.fold_compound.pbacktrack()  

        Note
        ----
        This function is polymorphic. It accepts RNA.fold_compound() of type RNA.FC_TYPE_SINGLE, and
        RNA.FC_TYPE_COMPARATIVE.  

        """
        return _RNA.fold_compound_pbacktrack5(self, *args)

    def pbacktrack_sub(self, *args):
        r"""
        pbacktrack_sub(fold_compound self, unsigned int start, unsigned int end) -> char
        pbacktrack_sub(fold_compound self, unsigned int num_samples, unsigned int start, unsigned int end, unsigned int options=) -> StringVector
        pbacktrack_sub(fold_compound self, unsigned int num_samples, unsigned int start, unsigned int end, pbacktrack_mem nr_memory, unsigned int options=) -> StringVector
        pbacktrack_sub(fold_compound self, unsigned int num_samples, unsigned int start, unsigned int end, PyObject * PyFunc, PyObject * data=Py_None, unsigned int options=0) -> unsigned int
        pbacktrack_sub(fold_compound self, unsigned int num_samples, unsigned int start, unsigned int end, PyObject * PyFunc, PyObject * data, pbacktrack_mem nr_memory, unsigned int options=0) -> unsigned int


        Sample a secondary structure of a subsequence from the Boltzmann ensemble according its probability.  

        Perform a probabilistic (stochastic) backtracing in the partition function DP arrays to obtain a
        secondary structure. The parameters `start` and `end` specify the interval :math:`[start:end]` of
        the subsequence with :math:`1 \leq start < end \leq n` for sequence length :math:`n`, the
        structure :math:`s_{start,end}` should be drawn from.  

        The resulting substructure :math:`s_{start,end}` with free energy :math:`E(s_{start, end})` is
        picked from the Boltzmann distributed sub ensemble of all structures within the interval
        :math:`[start:end]` according to its probability  

        .. math::

          p(s_{start,end}) = \frac{exp(-E(s_{start,end}) / kT)}{Z_{start,end}}  

        with partition function :math:`Z_{start,end} = \sum_{s_{start,end}} exp(-E(s_{start,end}) / kT)`,
        Boltzmann constant :math:`k` and thermodynamic temperature :math:`T`.  

        **Precondition**
            Unique multiloop decomposition has to be active upon creation of `fc` with RNA.fold_compound()
            or similar. This can be done easily by passing RNA.fold_compound() a model details parameter
            with RNA.md().uniq_ML = 1.  RNA.fold_compound.pf() has to be called first to fill the partition
        function
            matrices  

        **SWIG Wrapper Notes**
            This function is attached as overloaded method `pbacktrack_sub()` to objects of type
            *fold_compound*. See, e.g.   :py:meth:`RNA.fold_compound.pbacktrack_sub()` in the
            :doc:`/api_python`  and the  :ref:`examples/python:boltzmann sampling` Python examples .  

        Parameters
        ----------
        start : unsigned int
            The start of the subsequence to consider, i.e. 5'-end position(1-based)  
        end : unsigned int
            The end of the subsequence to consider, i.e. 3'-end position (1-based)  

        Returns
        -------
        char *  
            A sampled secondary structure in dot-bracket notation (or NULL on error)  

        See Also
        --------
        RNA.pbacktrack_sub_num(), RNA.pbacktrack_sub_cb(), RNA.fold_compound.pbacktrack()  

        Note
        ----
        This function is polymorphic. It accepts RNA.fold_compound() of type RNA.FC_TYPE_SINGLE, and
        RNA.FC_TYPE_COMPARATIVE.  

        """
        return _RNA.fold_compound_pbacktrack_sub(self, *args)

    def mfe_window_cb(self, *args, **kwargs):
        r"""
        mfe_window_cb(fold_compound self, PyObject * PyFunc, PyObject * data=Py_None) -> float


        **SWIG Wrapper Notes**
            This function is attached as overloaded method `mfe_window_cb()` to objects of type
            `fold_compound`. The parameter `data` has default value of `NULL` and can be omitted. See e.g.
            :py:meth:`RNA.fold_compound.mfe_window_cb()` in the :doc:`/api_python`.  

        """
        return _RNA.fold_compound_mfe_window_cb(self, *args, **kwargs)

    def mfe_window_zscore_cb(self, *args, **kwargs):
        r"""mfe_window_zscore_cb(fold_compound self, double min_z, PyObject * PyFunc, PyObject * data=Py_None) -> float"""
        return _RNA.fold_compound_mfe_window_zscore_cb(self, *args, **kwargs)

    def probs_window(self, *args, **kwargs):
        r"""
        probs_window(fold_compound self, int ulength, unsigned int options, PyObject * PyFunc, PyObject * data=Py_None) -> int


        Compute various equilibrium probabilities under a sliding window approach.  

        This function applies a sliding window scan for the sequence provided with the argument `fc` and
        reports back equilibrium probabilities through the callback function `cb`. The data reported to the
        callback depends on the `options` flag.  

        #### Options:  
        Note
        ----
        The parameter `ulength` only affects computation and resulting data if unpaired probability
        computations are requested through the `options` flag.  

        *   RNA.PROBS_WINDOW_BPP - Trigger base pairing probabilities.  
        *   RNA.PROBS_WINDOW_UP - Trigger unpaired probabilities.  
        *   RNA.PROBS_WINDOW_UP_SPLIT - Trigger detailed unpaired probabilities split up into different
            loop type contexts.  

        Options may be OR-ed together  

        Parameters
        ----------
        ulength : int
            The maximal length of an unpaired segment (only for unpaired probability computations)  
        cb : RNA.probs_window
            The callback function which collects the pair probability data for further processing  
        data : void *
            Some arbitrary data structure that is passed to the callback `cb`  
        options : unsigned int
            Option flags to control the behavior of this function  

        Returns
        -------
        int  
            0 on failure, non-zero on success  

        See Also
        --------
        RNA.pfl_fold_cb(), RNA.pfl_fold_up_cb()  

        """
        return _RNA.fold_compound_probs_window(self, *args, **kwargs)

    def heat_capacity_cb(self, *args, **kwargs):
        r"""
        heat_capacity_cb(fold_compound self, float T_min, float T_max, float T_increment, unsigned int mpoints, PyObject * PyFunc, PyObject * data=Py_None) -> PyObject *


        Compute the specific heat for an RNA (callback variant)  

        Similar to RNA.fold_compound.heat_capacity(), this function computes an RNAs specific heat in a given temperature
        range from the partition function by numeric differentiation. Instead of returning a list of
        temperature/specific heat pairs, however, this function returns the individual results through a
        callback mechanism. The provided function will be called for each result and passed the
        corresponding temperature and specific heat values along with the arbitrary data as provided through
        the `data` pointer argument.  

        Users can specify the temperature range for the computation from `T_min` to `T_max`, as well as the
        increment step size `T_increment`. The latter also determines how many times the partition function
        is computed. Finally, the parameter `mpoints` determines how smooth the curve should be. The
        algorithm itself fits a parabola to :math:`2 \cdot mpoints + 1` data points to calculate 2nd
        derivatives. Increasing this parameter produces a smoother curve.  

        **SWIG Wrapper Notes**
            This function is attached as method `heat_capacity_cb()` to objects of type `fold_compound`.
            See, e.g.  :py:meth:`RNA.fold_compound.heat_capacity_cb()` in the :doc:`/api_python`.  

        Parameters
        ----------
        T_min : float
            Lowest temperature in C  
        T_max : float
            Highest temperature in C  
        T_increment : float
            Stepsize for temperature incrementation in C (a reasonable choice might be 1C)  
        mpoints : unsigned int
            The number of interpolation points to calculate 2nd derivative (a reasonable choice might be 2,
            min: 1, max: 100)  
        cb : RNA.heat_capacity
            The user-defined callback function that receives the individual results  
        data : void *
            An arbitrary data structure that will be passed to the callback in conjunction with the results  

        Returns
        -------
        int  
            Returns 0 upon failure, and non-zero otherwise  

        See Also
        --------
        RNA.fold_compound.heat_capacity(), RNA.heat_capacity  

        """
        return _RNA.fold_compound_heat_capacity_cb(self, *args, **kwargs)

    def move_neighbor_diff(self, *args):
        r"""
        move_neighbor_diff(self, pt, move, options=(4|8)) -> varArrayMove
        move_neighbor_diff(fold_compound self, varArrayShort pt, move move, PyObject * PyFunc, PyObject * data=Py_None, unsigned int options=(4|8)) -> int


        Apply a move to a secondary structure and indicate which neighbors have changed consequentially.  

        Similar to RNA.move_neighbor_diff_cb(), this function applies a move to a secondary structure and
        reports back the neighbors of the current structure become affected by this move. Instead of
        executing a callback for each of the affected neighbors, this function compiles two lists of
        neighbor moves, one that is returned and consists of all moves that are novel or may have changed in
        energy, and a second, `invalid_moves`, that consists of all the neighbor moves that become invalid,
        respectively.  

        Parameters
        ----------
        ptable : short *
            The current structure as pair table  
        move : RNA.move()
            The move to apply  
        invalid_moves : RNA.move() **
            The address of a move list where the function stores those moves that become invalid  
        options : unsigned int
            Options to modify the behavior of this function, .e.g available move set  

        Returns
        -------
        RNA.move() *  
            A list of moves that might have changed in energy or are novel compared to the structure before
            application of the move  

        """
        return _RNA.fold_compound_move_neighbor_diff(self, *args)
    type = property(_RNA.fold_compound_type_get)
    sequence = property(_RNA.fold_compound_sequence_get)
    length = property(_RNA.fold_compound_length_get)
    strands = property(_RNA.fold_compound_strands_get)
    params = property(_RNA.fold_compound_params_get)
    exp_params = property(_RNA.fold_compound_exp_params_get)
    matrices = property(_RNA.fold_compound_matrices_get)
    exp_matrices = property(_RNA.fold_compound_exp_matrices_get)
    hc = property(_RNA.fold_compound_hc_get)
    strand_number = property(_RNA.fold_compound_strand_number_get)
    strand_order = property(_RNA.fold_compound_strand_order_get)
    strand_start = property(_RNA.fold_compound_strand_start_get)
    strand_end = property(_RNA.fold_compound_strand_end_get)
    iindx = property(_RNA.fold_compound_iindx_get)
    jindx = property(_RNA.fold_compound_jindx_get)
    sequence_encoding = property(_RNA.fold_compound_sequence_encoding_get)
    sequence_encoding2 = property(_RNA.fold_compound_sequence_encoding2_get)

    def __init__(self, *args):
        r"""


        The most basic data structure required by many functions throughout the RNAlib.  

        Note
        ----
        Please read the documentation of this data structure carefully! Some attributes are only available
        for specific types this data structure can adopt.  

        Warnings
        --------
        Reading/Writing from/to attributes that are not within the scope of the current type usually result
        in undefined behavior!  

        See Also
        --------
        RNA.fold_compound().type, RNA.fold_compound(), RNA.fold_compound_comparative(),
        RNA.fold_compound_free(), RNA.FC_TYPE_SINGLE, RNA.FC_TYPE_COMPARATIVE  

        **SWIG Wrapper Notes**

            This data structure is wrapped as class `fold_compound` with several related functions attached
            as methods.  

            A new `fold_compound` can be obtained by calling one of its constructors:  

            *   `fold_compound(seq)` - Initialize with a single sequence, or two concatenated sequences
                separated by an ampersand character `&` (for cofolding)  
            *   `fold_compound(aln)` - Initialize with a sequence alignment *aln* stored as a list of
                sequences (with gap characters).  

            The resulting object has a list of attached methods which in most cases directly correspond to
            functions that mainly operate on the corresponding `C` data structure:  

            *   `type()` - Get the type of the *fold_compound* (See RNA.fc_type)  
            *   `length()` - Get the length of the sequence(s) or alignment stored within the
                `fold_compound`.  

            See, e.g.  :py:class:`RNA.fold_compound` in the :doc:`/api_python`.  

        Attributes
        ----------
        type : const vrna_fc_type_e  
            The type of the RNA.fold_compound().  

            Currently possible values are RNA.FC_TYPE_SINGLE, and RNA.FC_TYPE_COMPARATIVE  

            Warnings
            --------
            Do not edit this attribute, it will be automagically set by the corresponding get() methods for
            the RNA.fold_compound(). The value specified in this attribute dictates the set of other
            attributes to use within this data structure.  

        length : unsigned int  
            The length of the sequence (or sequence alignment)  

        cutpoint : int  
            The position of the (cofold) cutpoint within the provided sequence. If there is no cutpoint,
            this field will be set to -1.  

        strand_number : unsigned int *  
            The strand number a particular nucleotide is associated with.  

        strand_order : unsigned int *  
            The strand order, i.e. permutation of current concatenated sequence.  

        strand_order_uniq : unsigned int *  
            The strand order array where identical sequences have the same ID.  

        strand_start : unsigned int *  
            The start position of a particular strand within the current concatenated sequence.  

        strand_end : unsigned int *  
            The end (last) position of a particular strand within the current concatenated sequence.  

        strands : unsigned int  
            Number of interacting strands.  

        nucleotides : vrna_seq_t *  
            Set of nucleotide sequences.  

        alignment : vrna_msa_t *  
            Set of alignments.  

        hc : vrna_hc_t *  
            The hard constraints data structure used for structure prediction.  

        matrices : vrna_mx_mfe_t *  
            The MFE DP matrices.  

        exp_matrices : vrna_mx_pf_t *  
            The PF DP matrices  

        params : vrna_param_t *  
            The precomputed free energy contributions for each type of loop.  

        exp_params : vrna_exp_param_t *  
            The precomputed free energy contributions as Boltzmann factors  

        iindx : int *  
            DP matrix accessor  

        jindx : int *  
            DP matrix accessor  

        stat_cb : vrna_recursion_status_f  
            Recursion status callback (usually called just before, and after recursive computations in the
            library.  

            See Also
            --------
            RNA.recursion_status(), RNA.fold_compound.add_callback()  

        auxdata : void *  
            A pointer to auxiliary, user-defined data.  

            See Also
            --------
            RNA.fold_compound.add_auxdata(), RNA.fold_compound().free_auxdata  

        free_auxdata : vrna_auxdata_free_f  
            A callback to free auxiliary user data whenever the fold_compound itself is free'd.  

            See Also
            --------
            RNA.fold_compound().auxdata, RNA.auxdata_free()  

        domains_struc : vrna_sd_t *  
            Additional structured domains.  

        domains_up : vrna_ud_t *  
            Additional unstructured domains.  

        aux_grammar : vrna_gr_aux_t *  
            Additional decomposition grammar rules.  

        sequence : char *  
            The input sequence string.  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_SINGLE  

        sequence_encoding : short *  
            Numerical encoding of the input sequence.  

            See Also
            --------
            RNA.sequence_encode()  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_SINGLE  

        encoding5 : short *  

        encoding3 : short *  

        sequence_encoding2 : short *  

        ptype : char *  
            Pair type array.  

            Contains the numerical encoding of the pair type for each pair (i,j) used in MFE, Partition
            function and Evaluation computations.  

            Note
            ----
            This array is always indexed via jindx, in contrast to previously different indexing between mfe
            and pf variants!  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_SINGLE  

            See Also
            --------
            RNA.idx_col_wise(), RNA.ptypes()  

        ptype_pf_compat : char *  
            ptype array indexed via iindx  

            .. deprecated:: 2.6.4
                This attribute will vanish in the future! It's meant for backward compatibility only!  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_SINGLE  

        sc : vrna_sc_t *  
            The soft constraints for usage in structure prediction and evaluation.  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_SINGLE  

        sequences : char **  
            The aligned sequences.  

            Note
            ----
            The end of the alignment is indicated by a NULL pointer in the second dimension  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_COMPARATIVE  

        n_seq : unsigned int  
            The number of sequences in the alignment.  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_COMPARATIVE  

        cons_seq : char *  
            The consensus sequence of the aligned sequences.  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_COMPARATIVE  

        S_cons : short *  
            Numerical encoding of the consensus sequence.  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_COMPARATIVE  

        S : short **  
            Numerical encoding of the sequences in the alignment.  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_COMPARATIVE  

        S5 : short **  
            S5[s][i] holds next base 5' of i in sequence s.  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_COMPARATIVE  

        S3 : short **  
            Sl[s][i] holds next base 3' of i in sequence s.  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_COMPARATIVE  

        Ss : char **  

        a2s : unsigned int **  

        pscore : int *  
            Precomputed array of pair types expressed as pairing scores.  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_COMPARATIVE  

        pscore_local : int **  
            Precomputed array of pair types expressed as pairing scores.  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_COMPARATIVE  

        pscore_pf_compat : short *  
            Precomputed array of pair types expressed as pairing scores indexed via iindx.  

            .. deprecated:: 2.6.4
                This attribute will vanish in the future!  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_COMPARATIVE  

        scs : vrna_sc_t **  
            A set of soft constraints (for each sequence in the alignment)  

            Warnings
            --------
            Only available if  

                type==RNA.FC_TYPE_COMPARATIVE  

        oldAliEn : int  

        maxD1 : unsigned int  
            Maximum allowed base pair distance to first reference.  

        maxD2 : unsigned int  
            Maximum allowed base pair distance to second reference.  

        reference_pt1 : short *  
            A pairtable of the first reference structure.  

        reference_pt2 : short *  
            A pairtable of the second reference structure.  

        referenceBPs1 : unsigned int *  
            Matrix containing number of basepairs of reference structure1 in interval [i,j].  

        referenceBPs2 : unsigned int *  
            Matrix containing number of basepairs of reference structure2 in interval [i,j].  

        bpdist : unsigned int *  
            Matrix containing base pair distance of reference structure 1 and 2 on interval [i,j].  

        mm1 : unsigned int *  
            Maximum matching matrix, reference struct 1 disallowed.  

        mm2 : unsigned int *  
            Maximum matching matrix, reference struct 2 disallowed.  

        window_size : int  
            window size for local folding sliding window approach  

        ptype_local : char **  
            Pair type array (for local folding)  

        zscore_data : vrna_zsc_dat_t  
            Data structure with settings for z-score computations.  

        @17 : union vrna_fc_s::@16  

        C++ includes: ViennaRNA/fold_compound.h

        """
        _RNA.fold_compound_swiginit(self, _RNA.new_fold_compound(*args))
    __swig_destroy__ = _RNA.delete_fold_compound

    def __str__(self):
        return _RNA.fold_compound___str__(self)

    def __repr__(self):
    # reformat string representation (self.__str__()) to something
    # that looks like a constructor argument list
        strthis = self.__str__().replace(": ", "=").replace("{ ", "").replace(" }", "")
        return  "%s.%s(%s)" % (self.__class__.__module__, self.__class__.__name__, strthis) 


# Register fold_compound in _RNA:
_RNA.fold_compound_swigregister(fold_compound)

STATUS_MFE_PRE = _RNA.STATUS_MFE_PRE
r"""


    Status message indicating that MFE computations are about to begin.  

    See Also
    --------
    RNA.fold_compound().stat_cb, RNA.recursion_status(), RNA.fold_compound.mfe(), RNA.fold(),
    RNA.circfold(),
    RNA.alifold(), RNA.circalifold(), RNA.cofold()  

    """
STATUS_MFE_POST = _RNA.STATUS_MFE_POST
r"""


    Status message indicating that MFE computations are finished.  

    See Also
    --------
    RNA.fold_compound().stat_cb, RNA.recursion_status(), RNA.fold_compound.mfe(), RNA.fold(),
    RNA.circfold(),
    RNA.alifold(), RNA.circalifold(), RNA.cofold()  

    """
STATUS_PF_PRE = _RNA.STATUS_PF_PRE
r"""


    Status message indicating that Partition function computations are about to begin.  

    See Also
    --------
    RNA.fold_compound().stat_cb, RNA.recursion_status(), RNA.fold_compound.pf()  

    """
STATUS_PF_POST = _RNA.STATUS_PF_POST
r"""


    Status message indicating that Partition function computations are finished.  

    See Also
    --------
    RNA.fold_compound().stat_cb, RNA.recursion_status(), RNA.fold_compound.pf()  

    """
OPTION_DEFAULT = _RNA.OPTION_DEFAULT
r"""


    Option flag to specify default settings/requirements.  

    """
OPTION_MFE = _RNA.OPTION_MFE
r"""


    Option flag to specify requirement of Minimum Free Energy (MFE) DP matrices and corresponding set of
    energy parameters.  

    See Also
    --------
    RNA.fold_compound(), RNA.fold_compound_comparative(), RNA.OPTION_EVAL_ONLY  

    """
OPTION_PF = _RNA.OPTION_PF
r"""


    Option flag to specify requirement of Partition Function (PF) DP matrices and corresponding set of
    Boltzmann factors.  

    See Also
    --------
    RNA.fold_compound(), RNA.fold_compound_comparative(), RNA.OPTION_EVAL_ONLY  

    """
OPTION_HYBRID = _RNA.OPTION_HYBRID
r"""


    Option flag to specify requirement of dimer DP matrices.  

    """
OPTION_EVAL_ONLY = _RNA.OPTION_EVAL_ONLY
r"""


    Option flag to specify that neither MFE, nor PF DP matrices are required.  

    Use this flag in conjuntion with RNA.OPTION_MFE, and RNA.OPTION_PF to save memory for a
    RNA.fold_compound() obtained from RNA.fold_compound(), or RNA.fold_compound_comparative() in
    cases where only energy evaluation but no structure prediction is required.  

    See Also
    --------
    RNA.fold_compound(), RNA.fold_compound_comparative(), RNA.fold_compound.eval_structure()  

    """
OPTION_WINDOW = _RNA.OPTION_WINDOW
r"""


    Option flag to specify requirement of DP matrices for local folding approaches.  

    """
class mx_mfe(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_RNA.mx_mfe_type_get)
    length = property(_RNA.mx_mfe_length_get)
    strands = property(_RNA.mx_mfe_strands_get)
    f5 = property(_RNA.mx_mfe_f5_get)
    f3 = property(_RNA.mx_mfe_f3_get)
    c = property(_RNA.mx_mfe_c_get)
    fML = property(_RNA.mx_mfe_fML_get)
    fM1 = property(_RNA.mx_mfe_fM1_get)
    fM2 = property(_RNA.mx_mfe_fM2_get)
    ggg = property(_RNA.mx_mfe_ggg_get)
    Fc = property(_RNA.mx_mfe_Fc_get)
    FcH = property(_RNA.mx_mfe_FcH_get)
    FcI = property(_RNA.mx_mfe_FcI_get)
    FcM = property(_RNA.mx_mfe_FcM_get)

    def __init__(self):
        _RNA.mx_mfe_swiginit(self, _RNA.new_mx_mfe())
    __swig_destroy__ = _RNA.delete_mx_mfe

# Register mx_mfe in _RNA:
_RNA.mx_mfe_swigregister(mx_mfe)

class mx_pf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_RNA.mx_pf_type_get)
    length = property(_RNA.mx_pf_length_get)
    scale = property(_RNA.mx_pf_scale_get)
    expMLbase = property(_RNA.mx_pf_expMLbase_get)
    q = property(_RNA.mx_pf_q_get)
    qb = property(_RNA.mx_pf_qb_get)
    qm = property(_RNA.mx_pf_qm_get)
    qm1 = property(_RNA.mx_pf_qm1_get)
    probs = property(_RNA.mx_pf_probs_get)
    q1k = property(_RNA.mx_pf_q1k_get)
    qln = property(_RNA.mx_pf_qln_get)
    G = property(_RNA.mx_pf_G_get)
    qo = property(_RNA.mx_pf_qo_get)
    qm2 = property(_RNA.mx_pf_qm2_get)
    qho = property(_RNA.mx_pf_qho_get)
    qio = property(_RNA.mx_pf_qio_get)
    qmo = property(_RNA.mx_pf_qmo_get)

    def __init__(self):
        _RNA.mx_pf_swiginit(self, _RNA.new_mx_pf())
    __swig_destroy__ = _RNA.delete_mx_pf

# Register mx_pf in _RNA:
_RNA.mx_pf_swigregister(mx_pf)


parameter_set_dna_mathews1999 = cvar.parameter_set_dna_mathews1999
parameter_set_dna_mathews2004 = cvar.parameter_set_dna_mathews2004
parameter_set_rna_andronescu2007 = cvar.parameter_set_rna_andronescu2007
parameter_set_rna_langdon2018 = cvar.parameter_set_rna_langdon2018
parameter_set_rna_misc_special_hairpins = cvar.parameter_set_rna_misc_special_hairpins
parameter_set_rna_turner1999 = cvar.parameter_set_rna_turner1999
parameter_set_rna_turner2004 = cvar.parameter_set_rna_turner2004
parameter_set_rna_mod_7DA_parameters = cvar.parameter_set_rna_mod_7DA_parameters
parameter_set_rna_mod_inosine_parameters = cvar.parameter_set_rna_mod_inosine_parameters
parameter_set_rna_mod_m6A_parameters = cvar.parameter_set_rna_mod_m6A_parameters
parameter_set_rna_mod_pseudouridine_parameters = cvar.parameter_set_rna_mod_pseudouridine_parameters
parameter_set_rna_mod_purine_parameters = cvar.parameter_set_rna_mod_purine_parameters
parameter_set_rna_mod_dihydrouridine_parameters = cvar.parameter_set_rna_mod_dihydrouridine_parameters
base_pair = cvar.base_pair
pr = cvar.pr
iindx = cvar.iindx

